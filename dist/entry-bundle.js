if("undefined"!=typeof define)throw new Error('Global var "define" is occupied!');!function(){"use strict";function e(){return(e=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var r=arguments[n];for(var t in r)Object.prototype.hasOwnProperty.call(r,t)&&(e[t]=r[t])}return e}).apply(this,arguments)}var n=[".sass",".scss",".less",".styl"],r=[".md",".pug",".haml",".jade",".slim",".slm"],t=[".css"].concat(n,[".html"],r,[".js",".ts",".mjs",".cjs",".json",".json5",".svg",".txt",".wasm",".wasi",".xml",".yml",".yaml"]),i=/^(\S+?!)?(\S+?)\/?$/,o=/^((?:https?:)?\/\/)(.+)/;function a(e){void 0===e&&(e="");var n=e.trim();return n.length&&"/"===n[n.length-1]&&(n=n.slice(0,-1)),n}function u(e){void 0===e&&(e="");var n=a(e).split("/").pop(),r=n.lastIndexOf(".");if(-1!==r){var i=n.slice(r).toLowerCase();if(-1!==t.indexOf(i))return i}return""}function c(e){void 0===e&&(e="");var n=e.trim().match(i);if(!n)throw new Error('not a vaid module id: "'+e+'"');var r,t=n[1]||"",a=n[2],c=a.match(o);c&&(r=c[1].slice(0,-1),a=c[2]);var f=u(a);".json"===f&&"json!"===t&&(t="");var s=a.split("/").filter((function(e,n){return e||0===n}));if(r)s.unshift(r);else if(s.length>1&&s[0].length&&"@"===s[0][0]){var d=s.shift();s[0]=d+"/"+s[0]}for(var l=[],p=0,h=s.length;p<h;p++)0!=p&&"."===s[p]||l.push(s[p]);for(var v=[],m=0,y=l.length;m<y;m++){var w=l[m];if(0===m||".."!==w)v.push(w);else{var b=v.pop();".."===b?(v.push(b),v.push(w)):"."!==b&&void 0!==b||v.push(w)}}return{prefix:t,bareId:a=(s=v).join("/"),parts:s,ext:f,cleanId:t+a}}function f(e,n){var r=c(e),t=c(n);if("."!==t.bareId[0])return t.cleanId;var i=r.parts;return i.pop(),t.parts.forEach((function(e){".."===e?0===i.length?i.push(".."):i.pop():"."!==e&&i.push(e)})),c(t.prefix+i.join("/")).cleanId}function s(e){var t=c(e),i=[t.cleanId],o=t.ext;return".js"!==o&&".ts"!==o&&".mjs"!==o&&".cjs"!==o||i.push(t.cleanId.slice(0,-o.length)),-1!==n.indexOf(o)&&i.push(t.cleanId.slice(0,-o.length)+".css"),-1!==r.indexOf(o)&&i.push(t.cleanId.slice(0,-o.length)+".html"),i.push(t.cleanId+".js"),i.push(t.cleanId+".json"),i.push(t.cleanId+".mjs"),i.push(t.cleanId+".cjs"),i.push(t.cleanId+"/index"),i.push(t.cleanId+"/index.js"),i.push(t.cleanId+"/index.json"),i.push(t.cleanId+"/index.mjs"),i.push(t.cleanId+"/index.cjs"),i}function d(e,n){void 0===n&&(n={});for(var r=c(e),t=r.bareId,i=Object.keys(n).sort((function(e,n){return n.length-e.length})),o=0,a=i.length;o<a;o++){var u=i[o],f=c(u);if(r.parts.length>=f.parts.length&&r.parts.slice(0,f.parts.length).join("/")===u){t=n[u]+t.slice(u.length),""===n[u]&&(t=t.slice(1));break}}return""===t&&(t="index"),r.prefix?d(r.prefix.slice(0,-1),n)+"!"+t:t}function l(e,n){var r=0,t=e.length;return function i(o){if(r<t){var a=n(e[r]);return r+=1,a&&"function"==typeof a.then?a.then((function(e){return i([].concat(o,[e]))})):i([].concat(o,[a]))}return o}([])}var p=/\/\*[\s\S]*?\*\/|([^:"'=]|^)\/\/.*$/gm,h=/[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g;function v(e,n){return n||""}function m(e){var n={},r=null,t={},i={},o=Object.create(null);function a(e){for(var r=s(e),t=0,i=r.length;t<i;t++){var o=m(r[t]);if(n.hasOwnProperty(o))return n[o]}}function d(e){for(var n=s(e),r=0,i=n.length;r<i;r++){var o=m(n[r]);if(t.hasOwnProperty(o))return t[o]}}function m(e){return o[e]||e}return{ids:function(){return[].concat(Object.keys(n),Object.keys(t),Object.keys(o)).sort()},has:function(e){return a(e)||d(e)},registered:a,defined:d,definedValues:function(){var e={};return Object.keys(t).forEach((function(n){e[n]=t[n].val})),e},define:function(e,i,o){if("string"!=typeof e&&(o=i,i=e,e=null),Array.isArray(i)||(o=i,i=null),!e||!n.hasOwnProperty(e)&&!t.hasOwnProperty(e))if(i||(i=[],"function"==typeof o&&o.length&&(o.toString().replace(p,v).replace(h,(function(e,n){return i.push(n)})),i=(1===o.length?["require"]:["require","exports","module"]).concat(i))),e){var a=c(e);n[a.cleanId]={id:a.cleanId,deps:i,cb:o}}else r={deps:i,cb:o}},alias:function(e,n){o[e]=n},nameAnonymous:function(e){if(r){var t=r,i=t.deps,o=t.cb;r=null,n[e]={id:e,deps:i,cb:o}}},req:function r(o){if("require"===o||"exports"===o||"module"===o)throw new Error('cannot require reserved keyword "'+o+'"');var c=d(o=m(o));if(c)return c.val;var s=a(o);if(!s)return e.req(o);var p=s.id,h=s.deps,v=s.cb;if(i.hasOwnProperty(p))return i[p].exports;var y=u(p),w={exports:{},id:p,uri:p+(y?"":".js")},b=!1;i[p]=w;var g=function(n){var t,o=f(p,n),u=m(e.mappedId(o)),c=d(u);if(c)return c.val;if(i.hasOwnProperty(u))return i[u].exports;if((t=a(u)?r(u):e.req(u))&&"function"==typeof t.then)throw t.then((function(){}),(function(){})),new Error('module "'+u+'" cannot be resolved synchronously.');return t};g.toUrl=e.toUrl;var x,j=function(r){var o;try{o="function"==typeof v?v.apply(e.global,r):v}catch(e){throw delete i[p],e}return void 0===o&&b&&(o=w.exports),delete i[p],delete n[p],t[p]={id:p,deps:h,cb:v,val:o},o};try{x=l(h,(function(n){if("require"===n)return g;if("module"===n)return b=!0,w;if("exports"===n)return b=!0,w.exports;var t=f(p,n),i=m(e.mappedId(t)),o=d(i);return o?o.val:function(n,r){var t=Object.create(null);return function n(i){var o=a(i);if(o){var u=o.id,c=o.deps;if(r&&(t[i]=!0,r===u))return!0;for(var s=0,d=c.length;s<d;s++){var l=c[s];if("require"!==l&&"exports"!==l&&"module"!==l){var p=f(u,l),h=m(e.mappedId(p));if(!t[h]&&n(h))return!0}}}}(n)}(i,p)?void 0:r(i)}))}catch(e){throw delete i[p],e}return x&&"function"==typeof x.then?x.then(j,(function(e){throw delete i[p],e})):j(x)},undef:function(r){var i=d(r);if(i)return function r(i){var o=[];Object.keys(t).forEach((function(n){var r=t[n],a=r.id;r.deps.some((function(n){var r=f(a,n);return m(e.mappedId(r))===i}))&&o.push(n)})),o.forEach((function(e){r(e);var i=t[e],o=i.deps,a=i.cb;delete t[e],n[e]={id:e,deps:o,cb:a}}))}(i.id),void delete t[i.id];var o=a(r);o&&delete n[o.id]},purge:function(){n={},r=null,t={},o=Object.create(null)}}}var y="undefined"!=typeof self?self:"undefined"!=typeof global?global:new Function("return this")();function w(e,n){var r=c(e),t=r.prefix.slice(0,-1);if(t){if("text"!==t&&"raw"!==t)return new Promise((function(i,o){var a=function(e,n,r){return C(e,n,(function(e){if(r)try{r(e)}catch(e){}o(e)}))};try{var u=function(r){n.define(e,[],(function(){return r})),i(n.req(e))};u.error=function(e){return o(e)},C([t],(function(e){e.load(r.bareId,a,u,{})}))}catch(e){o(e)}}))}else if(r.ext&&".js"!==r.ext){var i="ext:"+r.ext.slice(1);if(b.has(i)||g.has(i))return new Promise((function(t,o){var a=function(e,n,r){return C(e,n,(function(e){if(r)try{r(e)}catch(e){}o(e)}))};try{var u=function(r){n.define(e,[],(function(){return r})),t(n.req(e))};u.error=function(e){return o(e)},C([i],(function(e){e.load(r.cleanId,a,u,{})}))}catch(e){o(e)}}));if(n===b||n.has("text!"+r.cleanId))return new Promise((function(t){n.alias(r.cleanId,"text!"+r.cleanId),t(n.req(e))}))}}var b=m({global:y,mappedId:P,toUrl:S,req:function(e){var n=function(e){var n=s(e),r=Object.keys(A).find((function(e){var r=A[e],t=r.nameSpace,i=r.user;return n.some((function(e){if(t){var n=c(e);n.bareId.slice(0,t.length+1)===t+"/"&&(e=n.prefix+n.bareId.slice(t.length+1))}if(i.hasOwnProperty(e))return!0;var r=c(e);return r.prefix?i.hasOwnProperty(r.bareId):void 0}))}));if(r)return F(r).then((function(){if(b.has(e))return b.req(e);var n=w(e,b);if(n)return n;throw new Error('module "'+e+'" is missing from bundle "'+r+'"')}))}(e);if(n)return n;try{return g.req(e)}catch(n){if(n&&n.__unkown===e){var r=w(e,b);return r||function(e){var n=c(e);return function(e){return _(S(e))}(n.cleanId).then((function(e){V.switchToUserSpace();for(var r=0,t=U.length;r<t;r++){var i=U[r](n,e);if(i&&"function"==typeof i.then)return i}throw new Error("no runtime translator to handle "+n.cleanId)})).then((function(){if(b.has(n.cleanId))return b.req(n.cleanId);throw new Error('module "'+n.cleanId+'" is missing from url "'+S(e)+'"')})).catch((function(e){throw console.error('could not load module "'+n.cleanId+'" from remote'),e}))}(e)}throw n}}}),g=m({global:y,mappedId:P,toUrl:S,req:function(e){try{return function(e){var n=s(e),r=Object.keys(A).find((function(e){return n.some((function(n){var r=A[e].package;if(r.hasOwnProperty(n))return!0;var t=c(n);return t.prefix?r.hasOwnProperty(t.bareId):void 0}))}));if(r)return F(r).then((function(){if(g.has(e))return g.req(e);var n=w(e,g);if(n)return n;throw new Error('module "'+e+'" is missing from bundle "'+r+'"')}));var t=new Error('no bundle for module "'+e+'"');throw t.__unkown=e,t}(e)}catch(r){if(r&&r.__unkown===e){var n=w(e,g);if(n)return n}throw r}}}),x=b;function j(){x=b}function I(){x=g}var O="",k={},E={},q={};function P(e){return d(e,E)}function S(e){var n=d(c(e).bareId,q);return"/"===n[0]||n.match(/^https?:\/\//)||(n=c(O+n).cleanId),u(n)||(n+=".js"),n}var A={},U=[function(e,n){if("json!"===e.prefix)return n.json().then((function(n){b.define(e.cleanId,[],n),".json"===e.ext&&b.define(e.bareId,[],n)}))},function(e,n){if("text!"===e.prefix)return n.text().then((function(n){b.define(e.cleanId,n)}))},function(e,n){if("raw!"===e.prefix)return b.define(e.cleanId,(function(){return n})),Promise.resolve()},function(e,n){if(!(e.prefix||e.ext&&".js"!==e.ext))return n.text().then((function(n){j(),new Function(n).call(y),b.nameAnonymous(e.cleanId)}))}],_=function(e){if(void 0===y.fetch)return Promise.reject(new Error('fetch API is not available, cannot fetch "'+e+'"'));var n=e.match(/^(?:https?:)?\/\//)?{mode:"cors"}:{credentials:"include"};return y.fetch(e,n).then((function(n){if(n.ok)return n;throw new Error("URL: "+e+"\nResponse: "+n.status+" "+n.statusText)}))};var T={};function F(e){if(!T[e]){var n,r=S(e),t=(A[e]||{}).nameSpace;V.__skip_script_load_test||!G||t&&!("currentScript"in y.document)||(n=new Promise((function(e,n){var i=document.createElement("script");t&&i.setAttribute("data-namespace",t),i.type="text/javascript",i.charset="utf-8",i.async=!0,i.addEventListener("load",e),i.addEventListener("error",n),i.src=r,10===document.documentMode?setTimeout((function(){document.head.appendChild(i)})):document.head.appendChild(i)}))),n||(n=_(r).then((function(e){return e.text()})).then((function(e){if(j(),t){var n=function(e,n,r){B(t,e,n,r)};n.amd=V.amd,n.switchToUserSpace=j,n.switchToPackageSpace=I,new Function("define",e).call(y,n)}else new Function(e).call(y)}))),T[e]=n}return T[e]}function L(e){var n=P(e);return b.defined(n)||g.defined(n)}function V(e,n,r){if(G&&y.document.currentScript){var t=y.document.currentScript.getAttribute("data-namespace");if(t)return B(t,e,n,r)}x.define(e,n,r)}function B(e,n,r,t){if(x===b&&"ext:"!==n.slice(0,4)){var i=c(n);b.define(i.prefix+e+"/"+i.bareId,r,t)}else x.define(n,r,t)}function C(e,n,r){if(!Array.isArray(e))throw new Error("missing deps array");if(n&&"function"!=typeof n)throw new Error("callback is not a function");if(r&&"function"!=typeof r)throw new Error("errback is not a function");var t,i=function(e){return n?n.apply(y,e):e};function o(){if("string"==typeof arguments[0]){var e=arguments[0],n=L(e);if(n)return n.val;throw new Error('commonjs dependency "'+e+'" is not prepared.')}return C.apply(null,arguments)}o.toUrl=S;try{t=l(e,(function(e){return"require"===e?o:e instanceof RegExp?l([].concat(b.ids(),g.ids()).filter((function(n){return s(n).some((function(n){return n.match(e)}))})),(function(e){return b.req(e)})):b.req(P(e))}))}catch(e){return r?r(e):Promise.reject(e)}return t&&"function"==typeof t.then?t.then(i,(function(e){if(r)return r(e);console.error(e)})):new Promise((function(e){e(i(t))}))}function R(e,n,r){n(["raw!"+e],(function(e){e.arrayBuffer().then((function(e){return WebAssembly.instantiate(e)})).then((function(e){r(e.instance.exports)}),r.error)}))}function M(e,n,r){n(["text!"+e],(function(e){var n;try{n=JSON.parse(e)}catch(e){return void r.error(e)}r(n)}))}function N(){O="",k={},E={},q={},A={},T={},b.purge(),g.purge(),I(),V("json",{load:M}),V("ext:json",{load:M}),V("ext:wasm",{load:R}),j()}function $(e){var n={};return e.forEach((function(e){return n[e]=1})),n}V.alias=function(e,n){x.alias(e,n)};var G=!(void 0===y.navigator||void 0===y.document);if(V.switchToUserSpace=j,V.switchToPackageSpace=I,V.currentSpace=function(){return x===b?"user":"package"},V.reset=N,C.config=function(e){if(e){e.baseUrl&&(O=c(e.baseUrl).bareId+"/"),e.paths&&Object.keys(e.paths).forEach((function(n){var r=e.paths[n];k[a(n)]=a(r)})),e.bundles&&Object.keys(e.bundles).forEach((function(n){var r=e.bundles[n];Array.isArray(r)?A[n]={user:$(r),package:$([])}:A[n]={nameSpace:r.nameSpace||null,user:$(r.user||[]),package:$(r.package||[])}}));var n={},r={};Object.keys(k).forEach((function(e){A.hasOwnProperty(e)||k[e].match(/^(?:https?:)?\//)?r[e]=k[e]:n[e]=k[e]})),E=n,q=r}},C.definedValues=function(){return e(e({},g.definedValues()),b.definedValues())},V.amd={jQuery:!0},C.defined=L,C.specified=function(e){var n=P(e);return b.has(n)||g.has(n)},C.isBrowser=G,C.version="1.1.10",C.undef=function(e){b.undef(e)},C.toUrl=function(e){return S(P(e))},C.resolveModuleId=f,G)for(var J=y.document.getElementsByTagName("script"),Q=function(e){var n=J[e].getAttribute("data-main");if(n)return setTimeout((function(){return C([P(n)])})),"break"},W=J.length-1;W>=0;W--){if("break"===Q(W))break}N(),y.define=V,y.requirejs=C}(),"undefined"==typeof require&&(require=requirejs);
define.switchToPackageSpace();
define('@aurelia/fetch-client/dist/esm/http-client-configuration.js',['require','exports','module','./retry-interceptor.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.HttpClientConfiguration = void 0;

var _retryInterceptor = require("./retry-interceptor.js");

/**
 * A class for configuring HttpClients.
 */
class HttpClientConfiguration {
  constructor() {
    /**
     * The base URL to be prepended to each Request's url before sending.
     */
    this.baseUrl = '';
    /**
     * Default values to apply to init objects when creating Requests. Note that
     * defaults cannot be applied when Request objects are manually created because
     * Request provides its own defaults and discards the original init object.
     * See also https://developer.mozilla.org/en-US/docs/Web/API/Request/Request
     */

    this.defaults = {};
    /**
     * Interceptors to be added to the HttpClient.
     */

    this.interceptors = [];
    this.dispatcher = null;
  }
  /**
   * Sets the baseUrl.
   *
   * @param baseUrl - The base URL.
   * @returns The chainable instance of this configuration object.
   * @chainable
   */


  withBaseUrl(baseUrl) {
    this.baseUrl = baseUrl;
    return this;
  }
  /**
   * Sets the defaults.
   *
   * @param defaults - The defaults.
   * @returns The chainable instance of this configuration object.
   * @chainable
   */


  withDefaults(defaults) {
    this.defaults = defaults;
    return this;
  }
  /**
   * Adds an interceptor to be run on all requests or responses.
   *
   * @param interceptor - An object with request, requestError,
   * response, or responseError methods. request and requestError act as
   * resolve and reject handlers for the Request before it is sent.
   * response and responseError act as resolve and reject handlers for
   * the Response after it has been received.
   * @returns The chainable instance of this configuration object.
   * @chainable
   */


  withInterceptor(interceptor) {
    this.interceptors.push(interceptor);
    return this;
  }
  /**
   * Applies a configuration that addresses common application needs, including
   * configuring same-origin credentials, and using rejectErrorResponses.
   *
   * @returns The chainable instance of this configuration object.
   * @chainable
   */


  useStandardConfiguration() {
    const standardConfig = {
      credentials: 'same-origin'
    };
    Object.assign(this.defaults, standardConfig, this.defaults);
    return this.rejectErrorResponses();
  }
  /**
   * Causes Responses whose status codes fall outside the range 200-299 to reject.
   * The fetch API only rejects on network errors or other conditions that prevent
   * the request from completing, meaning consumers must inspect Response.ok in the
   * Promise continuation to determine if the server responded with a success code.
   * This method adds a response interceptor that causes Responses with error codes
   * to be rejected, which is common behavior in HTTP client libraries.
   *
   * @returns The chainable instance of this configuration object.
   * @chainable
   */


  rejectErrorResponses() {
    return this.withInterceptor({
      response: rejectOnError
    });
  }

  withRetry(config) {
    const interceptor = new _retryInterceptor.RetryInterceptor(config);
    return this.withInterceptor(interceptor);
  }

  withDispatcher(dispatcher) {
    this.dispatcher = dispatcher;
    return this;
  }

}

exports.HttpClientConfiguration = HttpClientConfiguration;

function rejectOnError(response) {
  if (!response.ok) {
    throw response;
  }

  return response;
}
});

;define.alias('@aurelia/fetch-client/http-client-configuration.js','@aurelia/fetch-client/dist/esm/http-client-configuration.js');
define('@aurelia/fetch-client/dist/esm/http-client.js',['require','exports','module','@aurelia/kernel','./http-client-configuration.js','./retry-interceptor.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.HttpClient = exports.IHttpClient = void 0;

var _kernel = require("@aurelia/kernel");

var _httpClientConfiguration = require("./http-client-configuration.js");

var _retryInterceptor = require("./retry-interceptor.js");

const absoluteUrlRegexp = /^([a-z][a-z0-9+\-.]*:)?\/\//i;

const IHttpClient = _kernel.DI.createInterface('IHttpClient', x => x.singleton(HttpClient));
/**
 * An HTTP client based on the Fetch API.
 */


exports.IHttpClient = IHttpClient;

class HttpClient {
  /**
   * Creates an instance of HttpClient.
   */
  constructor() {
    this.dispatcher = null;
    this.activeRequestCount = 0;
    this.isRequesting = false;
    this.isConfigured = false;
    this.baseUrl = '';
    this.defaults = null;
    this.interceptors = [];
  }
  /**
   * Configure this client with default settings to be used by all requests.
   *
   * @param config - A configuration object, or a function that takes a config
   * object and configures it.
   * @returns The chainable instance of this HttpClient.
   * @chainable
   */


  configure(config) {
    let normalizedConfig;

    if (typeof config === 'object') {
      const requestInitConfiguration = {
        defaults: config
      };
      normalizedConfig = requestInitConfiguration;
    } else if (typeof config === 'function') {
      normalizedConfig = new _httpClientConfiguration.HttpClientConfiguration();
      normalizedConfig.baseUrl = this.baseUrl;
      normalizedConfig.defaults = { ...this.defaults
      };
      normalizedConfig.interceptors = this.interceptors;
      normalizedConfig.dispatcher = this.dispatcher;
      const c = config(normalizedConfig);

      if (Object.prototype.isPrototypeOf.call(_httpClientConfiguration.HttpClientConfiguration.prototype, c)) {
        normalizedConfig = c;
      }
    } else {
      throw new Error('invalid config');
    }

    const defaults = normalizedConfig.defaults;

    if (defaults !== undefined && Object.prototype.isPrototypeOf.call(Headers.prototype, defaults.headers)) {
      // Headers instances are not iterable in all browsers. Require a plain
      // object here to allow default headers to be merged into request headers.
      throw new Error('Default headers must be a plain object.');
    }

    const interceptors = normalizedConfig.interceptors;

    if (interceptors !== undefined && interceptors.length) {
      // find if there is a RetryInterceptor
      if (interceptors.filter(x => Object.prototype.isPrototypeOf.call(_retryInterceptor.RetryInterceptor.prototype, x)).length > 1) {
        throw new Error('Only one RetryInterceptor is allowed.');
      }

      const retryInterceptorIndex = interceptors.findIndex(x => Object.prototype.isPrototypeOf.call(_retryInterceptor.RetryInterceptor.prototype, x));

      if (retryInterceptorIndex >= 0 && retryInterceptorIndex !== interceptors.length - 1) {
        throw new Error('The retry interceptor must be the last interceptor defined.');
      }
    }

    this.baseUrl = normalizedConfig.baseUrl;
    this.defaults = defaults;
    this.interceptors = normalizedConfig.interceptors !== undefined ? normalizedConfig.interceptors : [];
    this.dispatcher = normalizedConfig.dispatcher;
    this.isConfigured = true;
    return this;
  }
  /**
   * Starts the process of fetching a resource. Default configuration parameters
   * will be applied to the Request. The constructed Request will be passed to
   * registered request interceptors before being sent. The Response will be passed
   * to registered Response interceptors before it is returned.
   *
   * See also https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
   *
   * @param input - The resource that you wish to fetch. Either a
   * Request object, or a string containing the URL of the resource.
   * @param init - An options object containing settings to be applied to
   * the Request.
   * @returns A Promise for the Response from the fetch request.
   */


  fetch(input, init) {
    this.trackRequestStart();
    let request = this.buildRequest(input, init);
    return this.processRequest(request, this.interceptors).then(result => {
      let response;

      if (Object.prototype.isPrototypeOf.call(Response.prototype, result)) {
        response = Promise.resolve(result);
      } else if (Object.prototype.isPrototypeOf.call(Request.prototype, result)) {
        request = result;
        response = fetch(request);
      } else {
        throw new Error(`An invalid result was returned by the interceptor chain. Expected a Request or Response instance, but got [${result}]`);
      }

      return this.processResponse(response, this.interceptors, request);
    }).then(result => {
      if (Object.prototype.isPrototypeOf.call(Request.prototype, result)) {
        return this.fetch(result);
      }

      return result;
    }).then(result => {
      this.trackRequestEnd();
      return result;
    }, error => {
      this.trackRequestEnd();
      throw error;
    });
  }

  buildRequest(input, init) {
    const defaults = this.defaults !== null ? this.defaults : {};
    let request;
    let body;
    let requestContentType;
    const parsedDefaultHeaders = parseHeaderValues(defaults.headers);

    if (Object.prototype.isPrototypeOf.call(Request.prototype, input)) {
      request = input;
      requestContentType = new Headers(request.headers).get('Content-Type');
    } else {
      if (!init) {
        init = {};
      }

      body = init.body;
      const bodyObj = body !== undefined ? {
        body: body
      } : null;
      const requestInit = { ...defaults,
        headers: {},
        ...init,
        ...bodyObj
      };
      requestContentType = new Headers(requestInit.headers).get('Content-Type');
      request = new Request(getRequestUrl(this.baseUrl, input), requestInit);
    }

    if (!requestContentType) {
      if (new Headers(parsedDefaultHeaders).has('content-type')) {
        request.headers.set('Content-Type', new Headers(parsedDefaultHeaders).get('content-type'));
      } else if (body !== undefined && isJSON(body)) {
        request.headers.set('Content-Type', 'application/json');
      }
    }

    setDefaultHeaders(request.headers, parsedDefaultHeaders);

    if (body !== undefined && Object.prototype.isPrototypeOf.call(Blob.prototype, body) && body.type) {
      // work around bug in IE & Edge where the Blob type is ignored in the request
      // https://connect.microsoft.com/IE/feedback/details/2136163
      request.headers.set('Content-Type', body.type);
    }

    return request;
  }
  /**
   * Calls fetch as a GET request.
   *
   * @param input - The resource that you wish to fetch. Either a
   * Request object, or a string containing the URL of the resource.
   * @param init - An options object containing settings to be applied to
   * the Request.
   * @returns A Promise for the Response from the fetch request.
   */


  get(input, init) {
    return this.fetch(input, init);
  }
  /**
   * Calls fetch with request method set to POST.
   *
   * @param input - The resource that you wish to fetch. Either a
   * Request object, or a string containing the URL of the resource.
   * @param body - The body of the request.
   * @param init - An options object containing settings to be applied to
   * the Request.
   * @returns A Promise for the Response from the fetch request.
   */


  post(input, body, init) {
    return this.callFetch(input, body, init, 'POST');
  }
  /**
   * Calls fetch with request method set to PUT.
   *
   * @param input - The resource that you wish to fetch. Either a
   * Request object, or a string containing the URL of the resource.
   * @param body - The body of the request.
   * @param init - An options object containing settings to be applied to
   * the Request.
   * @returns A Promise for the Response from the fetch request.
   */


  put(input, body, init) {
    return this.callFetch(input, body, init, 'PUT');
  }
  /**
   * Calls fetch with request method set to PATCH.
   *
   * @param input - The resource that you wish to fetch. Either a
   * Request object, or a string containing the URL of the resource.
   * @param body - The body of the request.
   * @param init - An options object containing settings to be applied to
   * the Request.
   * @returns A Promise for the Response from the fetch request.
   */


  patch(input, body, init) {
    return this.callFetch(input, body, init, 'PATCH');
  }
  /**
   * Calls fetch with request method set to DELETE.
   *
   * @param input - The resource that you wish to fetch. Either a
   * Request object, or a string containing the URL of the resource.
   * @param body - The body of the request.
   * @param init - An options object containing settings to be applied to
   * the Request.
   * @returns A Promise for the Response from the fetch request.
   */


  delete(input, body, init) {
    return this.callFetch(input, body, init, 'DELETE');
  }

  trackRequestStart() {
    this.isRequesting = !!++this.activeRequestCount;

    if (this.isRequesting && this.dispatcher !== null) {
      const evt = new this.dispatcher.ownerDocument.defaultView.CustomEvent('aurelia-fetch-client-request-started', {
        bubbles: true,
        cancelable: true
      });
      setTimeout(() => {
        this.dispatcher.dispatchEvent(evt);
      }, 1);
    }
  }

  trackRequestEnd() {
    this.isRequesting = !! --this.activeRequestCount;

    if (!this.isRequesting && this.dispatcher !== null) {
      const evt = new this.dispatcher.ownerDocument.defaultView.CustomEvent('aurelia-fetch-client-requests-drained', {
        bubbles: true,
        cancelable: true
      });
      setTimeout(() => {
        this.dispatcher.dispatchEvent(evt);
      }, 1);
    }
  }

  processRequest(request, interceptors) {
    return this.applyInterceptors(request, interceptors, 'request', 'requestError', this);
  }

  processResponse(response, interceptors, request) {
    return this.applyInterceptors(response, interceptors, 'response', 'responseError', request, this);
  }

  applyInterceptors(input, interceptors, successName, errorName, ...interceptorArgs) {
    return (interceptors !== undefined ? interceptors : []).reduce((chain, interceptor) => {
      const successHandler = interceptor[successName];
      const errorHandler = interceptor[errorName]; // TODO: Fix this, as it violates `strictBindCallApply`.

      return chain.then(successHandler ? value => successHandler.call(interceptor, value, ...interceptorArgs) : identity, errorHandler ? reason => errorHandler.call(interceptor, reason, ...interceptorArgs) : thrower);
    }, Promise.resolve(input));
  }

  callFetch(input, body, init, method) {
    if (!init) {
      init = {};
    }

    init.method = method;

    if (body) {
      init.body = body;
    }

    return this.fetch(input, init);
  }

}

exports.HttpClient = HttpClient;

function parseHeaderValues(headers) {
  const parsedHeaders = {};
  const $headers = headers !== undefined ? headers : {};

  for (const name in $headers) {
    if (Object.prototype.hasOwnProperty.call($headers, name)) {
      parsedHeaders[name] = typeof $headers[name] === 'function' ? $headers[name]() : $headers[name];
    }
  }

  return parsedHeaders;
}

function getRequestUrl(baseUrl, url) {
  if (absoluteUrlRegexp.test(url)) {
    return url;
  }

  return (baseUrl !== undefined ? baseUrl : '') + url;
}

function setDefaultHeaders(headers, defaultHeaders) {
  const $defaultHeaders = defaultHeaders !== undefined ? defaultHeaders : {};

  for (const name in $defaultHeaders) {
    if (Object.prototype.hasOwnProperty.call($defaultHeaders, name) && !headers.has(name)) {
      headers.set(name, $defaultHeaders[name]);
    }
  }
}

function isJSON(str) {
  try {
    JSON.parse(str);
  } catch (err) {
    return false;
  }

  return true;
}

function identity(x) {
  return x;
}

function thrower(x) {
  throw x;
}
});

;define.alias('@aurelia/fetch-client/http-client.js','@aurelia/fetch-client/dist/esm/http-client.js');
define('@aurelia/fetch-client/dist/esm/index.js',['require','exports','module','./util.js','./retry-interceptor.js','./http-client-configuration.js','./http-client.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.IHttpClient = exports.HttpClient = exports.HttpClientConfiguration = exports.RetryInterceptor = exports.retryStrategy = exports.json = void 0;

var _util = require("./util.js");

exports.json = _util.json;

var _retryInterceptor = require("./retry-interceptor.js");

exports.retryStrategy = _retryInterceptor.retryStrategy;
exports.RetryInterceptor = _retryInterceptor.RetryInterceptor;

var _httpClientConfiguration = require("./http-client-configuration.js");

exports.HttpClientConfiguration = _httpClientConfiguration.HttpClientConfiguration;

var _httpClient = require("./http-client.js");

exports.HttpClient = _httpClient.HttpClient;
exports.IHttpClient = _httpClient.IHttpClient;
});

;define.alias('@aurelia/fetch-client','@aurelia/fetch-client/dist/esm/index.js');
define('@aurelia/fetch-client/dist/esm/retry-interceptor.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.RetryInterceptor = exports.retryStrategy = void 0;
const retryStrategy = {
  fixed: 0,
  incremental: 1,
  exponential: 2,
  random: 3
};
exports.retryStrategy = retryStrategy;
const defaultRetryConfig = {
  maxRetries: 3,
  interval: 1000,
  strategy: retryStrategy.fixed
};
/**
 * Interceptor that retries requests on error, based on a given RetryConfiguration.
 */

class RetryInterceptor {
  /**
   * Creates an instance of RetryInterceptor.
   */
  constructor(retryConfig) {
    this.retryConfig = { ...defaultRetryConfig,
      ...(retryConfig !== undefined ? retryConfig : {})
    };

    if (this.retryConfig.strategy === retryStrategy.exponential && this.retryConfig.interval <= 1000) {
      throw new Error('An interval less than or equal to 1 second is not allowed when using the exponential retry strategy');
    }
  }
  /**
   * Called with the request before it is sent. It remembers the request so it can be retried on error.
   *
   * @param request - The request to be sent.
   * @returns The existing request, a new request or a response; or a Promise for any of these.
   */


  request(request) {
    if (!request.retryConfig) {
      request.retryConfig = { ...this.retryConfig
      };
      request.retryConfig.counter = 0;
    } // do this on every request


    request.retryConfig.requestClone = request.clone();
    return request;
  }
  /**
   * Called with the response after it is received. Clears the remembered request, as it was succesfull.
   *
   * @param response - The response.
   * @returns The response; or a Promise for one.
   */


  response(response, request) {
    // retry was successful, so clean up after ourselves
    Reflect.deleteProperty(request, 'retryConfig');
    return response;
  }
  /**
   * Handles fetch errors and errors generated by previous interceptors. This
   * function acts as a Promise rejection handler. It wil retry the remembered request based on the
   * configured RetryConfiguration.
   *
   * @param error - The rejection value from the fetch request or from a
   * previous interceptor.
   * @returns The response of the retry; or a Promise for one.
   */


  responseError(error, request, httpClient) {
    const {
      retryConfig
    } = request;
    const {
      requestClone
    } = retryConfig;
    return Promise.resolve().then(() => {
      if (retryConfig.counter < retryConfig.maxRetries) {
        const result = retryConfig.doRetry !== undefined ? retryConfig.doRetry(error, request) : true;
        return Promise.resolve(result).then(doRetry => {
          if (doRetry) {
            retryConfig.counter++;
            const delay = calculateDelay(retryConfig);
            return new Promise(resolve => setTimeout(resolve, !isNaN(delay) ? delay : 0)).then(() => {
              const newRequest = requestClone.clone();

              if (typeof retryConfig.beforeRetry === 'function') {
                return retryConfig.beforeRetry(newRequest, httpClient);
              }

              return newRequest;
            }).then(newRequest => {
              const retryableRequest = { ...newRequest,
                retryConfig
              };
              return httpClient.fetch(retryableRequest);
            });
          } // no more retries, so clean up


          Reflect.deleteProperty(request, 'retryConfig');
          throw error;
        });
      } // no more retries, so clean up


      Reflect.deleteProperty(request, 'retryConfig');
      throw error;
    });
  }

}

exports.RetryInterceptor = RetryInterceptor;

function calculateDelay(retryConfig) {
  const {
    interval,
    strategy,
    minRandomInterval,
    maxRandomInterval,
    counter
  } = retryConfig;

  if (typeof strategy === 'function') {
    return retryConfig.strategy(counter);
  }

  switch (strategy) {
    case retryStrategy.fixed:
      return retryStrategies[retryStrategy.fixed](interval);

    case retryStrategy.incremental:
      return retryStrategies[retryStrategy.incremental](counter, interval);

    case retryStrategy.exponential:
      return retryStrategies[retryStrategy.exponential](counter, interval);

    case retryStrategy.random:
      return retryStrategies[retryStrategy.random](counter, interval, minRandomInterval, maxRandomInterval);

    default:
      throw new Error('Unrecognized retry strategy');
  }
}

const retryStrategies = [// fixed
interval => interval, // incremental
(retryCount, interval) => interval * retryCount, // exponential
(retryCount, interval) => retryCount === 1 ? interval : interval ** retryCount / 1000, // random
(retryCount, interval, minRandomInterval = 0, maxRandomInterval = 60000) => {
  return Math.random() * (maxRandomInterval - minRandomInterval) + minRandomInterval;
}];
});

;define.alias('@aurelia/fetch-client/retry-interceptor.js','@aurelia/fetch-client/dist/esm/retry-interceptor.js');
define('@aurelia/fetch-client/dist/esm/util.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.json = json;

/**
 * Serialize an object to JSON. Useful for easily creating JSON fetch request bodies.
 *
 * @param body - The object to be serialized to JSON.
 * @param replacer - The JSON.stringify replacer used when serializing.
 * @returns A JSON string.
 */
function json(body, replacer) {
  return JSON.stringify(body !== undefined ? body : {}, replacer);
}
});

;define.alias('@aurelia/fetch-client/util.js','@aurelia/fetch-client/dist/esm/util.js');
define('@aurelia/kernel/dist/esm/di.js',['require','exports','module','@aurelia/metadata','./functions.js','./platform.js','./resource.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.transient = transient;
exports.singleton = singleton;
exports.ignore = ignore;
exports.validateKey = validateKey;
exports.InstanceProvider = exports.Registration = exports.ParameterizedRegistry = exports.Container = exports.Factory = exports.Resolver = exports.ResolverStrategy = exports.newInstanceOf = exports.newInstanceForScope = exports.optional = exports.lazy = exports.all = exports.inject = exports.IServiceLocator = exports.IContainer = exports.DI = exports.ContainerConfiguration = exports.DefaultResolver = exports.ResolverBuilder = void 0;

var _metadata = require("@aurelia/metadata");

var _functions = require("./functions.js");

var _platform = require("./platform.js");

var _resource = require("./resource.js");

(0, _metadata.applyMetadataPolyfill)(Reflect);

class ResolverBuilder {
  constructor(container, key) {
    this.container = container;
    this.key = key;
  }

  instance(value) {
    return this.registerResolver(0
    /* instance */
    , value);
  }

  singleton(value) {
    return this.registerResolver(1
    /* singleton */
    , value);
  }

  transient(value) {
    return this.registerResolver(2
    /* transient */
    , value);
  }

  callback(value) {
    return this.registerResolver(3
    /* callback */
    , value);
  }

  cachedCallback(value) {
    return this.registerResolver(3
    /* callback */
    , cacheCallbackResult(value));
  }

  aliasTo(destinationKey) {
    return this.registerResolver(5
    /* alias */
    , destinationKey);
  }

  registerResolver(strategy, state) {
    const {
      container,
      key
    } = this;
    this.container = this.key = void 0;
    return container.registerResolver(key, new Resolver(key, strategy, state));
  }

}

exports.ResolverBuilder = ResolverBuilder;

function cloneArrayWithPossibleProps(source) {
  const clone = source.slice();
  const keys = Object.keys(source);
  const len = keys.length;
  let key;

  for (let i = 0; i < len; ++i) {
    key = keys[i];

    if (!(0, _functions.isArrayIndex)(key)) {
      clone[key] = source[key];
    }
  }

  return clone;
}

const DefaultResolver = {
  none(key) {
    throw Error(`${key.toString()} not registered, did you forget to add @singleton()?`);
  },

  singleton(key) {
    return new Resolver(key, 1
    /* singleton */
    , key);
  },

  transient(key) {
    return new Resolver(key, 2
    /* transient */
    , key);
  }

};
exports.DefaultResolver = DefaultResolver;

class ContainerConfiguration {
  constructor(inheritParentResources, defaultResolver) {
    this.inheritParentResources = inheritParentResources;
    this.defaultResolver = defaultResolver;
  }

  static from(config) {
    if (config === void 0 || config === ContainerConfiguration.DEFAULT) {
      return ContainerConfiguration.DEFAULT;
    }

    return new ContainerConfiguration(config.inheritParentResources ?? false, config.defaultResolver ?? DefaultResolver.singleton);
  }

}

exports.ContainerConfiguration = ContainerConfiguration;
ContainerConfiguration.DEFAULT = ContainerConfiguration.from({});
const DI = {
  createContainer(config) {
    return new Container(null, ContainerConfiguration.from(config));
  },

  getDesignParamtypes(Type) {
    return _metadata.Metadata.getOwn('design:paramtypes', Type);
  },

  getAnnotationParamtypes(Type) {
    const key = _resource.Protocol.annotation.keyFor('di:paramtypes');

    return _metadata.Metadata.getOwn(key, Type);
  },

  getOrCreateAnnotationParamTypes(Type) {
    const key = _resource.Protocol.annotation.keyFor('di:paramtypes');

    let annotationParamtypes = _metadata.Metadata.getOwn(key, Type);

    if (annotationParamtypes === void 0) {
      _metadata.Metadata.define(key, annotationParamtypes = [], Type);

      _resource.Protocol.annotation.appendTo(Type, key);
    }

    return annotationParamtypes;
  },

  getDependencies(Type) {
    // Note: Every detail of this getDependencies method is pretty deliberate at the moment, and probably not yet 100% tested from every possible angle,
    // so be careful with making changes here as it can have a huge impact on complex end user apps.
    // Preferably, only make changes to the dependency resolution process via a RFC.
    const key = _resource.Protocol.annotation.keyFor('di:dependencies');

    let dependencies = _metadata.Metadata.getOwn(key, Type);

    if (dependencies === void 0) {
      // Type.length is the number of constructor parameters. If this is 0, it could mean the class has an empty constructor
      // but it could also mean the class has no constructor at all (in which case it inherits the constructor from the prototype).
      // Non-zero constructor length + no paramtypes means emitDecoratorMetadata is off, or the class has no decorator.
      // We're not doing anything with the above right now, but it's good to keep in mind for any future issues.
      const inject = Type.inject;

      if (inject === void 0) {
        // design:paramtypes is set by tsc when emitDecoratorMetadata is enabled.
        const designParamtypes = DI.getDesignParamtypes(Type); // au:annotation:di:paramtypes is set by the parameter decorator from DI.createInterface or by @inject

        const annotationParamtypes = DI.getAnnotationParamtypes(Type);

        if (designParamtypes === void 0) {
          if (annotationParamtypes === void 0) {
            // Only go up the prototype if neither static inject nor any of the paramtypes is defined, as
            // there is no sound way to merge a type's deps with its prototype's deps
            const Proto = Object.getPrototypeOf(Type);

            if (typeof Proto === 'function' && Proto !== Function.prototype) {
              dependencies = cloneArrayWithPossibleProps(DI.getDependencies(Proto));
            } else {
              dependencies = [];
            }
          } else {
            // No design:paramtypes so just use the au:annotation:di:paramtypes
            dependencies = cloneArrayWithPossibleProps(annotationParamtypes);
          }
        } else if (annotationParamtypes === void 0) {
          // No au:annotation:di:paramtypes so just use the design:paramtypes
          dependencies = cloneArrayWithPossibleProps(designParamtypes);
        } else {
          // We've got both, so merge them (in case of conflict on same index, au:annotation:di:paramtypes take precedence)
          dependencies = cloneArrayWithPossibleProps(designParamtypes);
          let len = annotationParamtypes.length;
          let auAnnotationParamtype;

          for (let i = 0; i < len; ++i) {
            auAnnotationParamtype = annotationParamtypes[i];

            if (auAnnotationParamtype !== void 0) {
              dependencies[i] = auAnnotationParamtype;
            }
          }

          const keys = Object.keys(annotationParamtypes);
          len = keys.length;
          let key;

          for (let i = 0; i < len; ++i) {
            key = keys[i];

            if (!(0, _functions.isArrayIndex)(key)) {
              dependencies[key] = annotationParamtypes[key];
            }
          }
        }
      } else {
        // Ignore paramtypes if we have static inject
        dependencies = cloneArrayWithPossibleProps(inject);
      }

      _metadata.Metadata.define(key, dependencies, Type);

      _resource.Protocol.annotation.appendTo(Type, key);
    }

    return dependencies;
  },

  /**
   * creates a decorator that also matches an interface and can be used as a {@linkcode Key}.
   * ```ts
   * const ILogger = DI.createInterface<Logger>('Logger');
   * container.register(Registration.singleton(ILogger, getSomeLogger()));
   * const log = container.get(ILogger);
   * log.info('hello world');
   * class Foo {
   *   constructor( @ILogger log: ILogger ) {
   *     log.info('hello world');
   *   }
   * }
   * ```
   * you can also build default registrations into your interface.
   * ```ts
   * export const ILogger = DI.createInterface<Logger>('Logger', builder => builder.cachedCallback(LoggerDefault));
   * const log = container.get(ILogger);
   * log.info('hello world');
   * class Foo {
   *   constructor( @ILogger log: ILogger ) {
   *     log.info('hello world');
   *   }
   * }
   * ```
   * but these default registrations won't work the same with other decorators that take keys, for example
   * ```ts
   * export const MyStr = DI.createInterface<string>('MyStr', builder => builder.instance('somestring'));
   * class Foo {
   *   constructor( @optional(MyStr) public readonly str: string ) {
   *   }
   * }
   * container.get(Foo).str; // returns undefined
   * ```
   * to fix this add this line somewhere before you do a `get`
   * ```ts
   * container.register(MyStr);
   * container.get(Foo).str; // returns 'somestring'
   * ```
   *
   * - @param friendlyName used to improve error messaging
   */
  createInterface(configureOrName, configuror) {
    const configure = typeof configureOrName === 'function' ? configureOrName : configuror;
    const friendlyName = typeof configureOrName === 'string' ? configureOrName : undefined;

    const Interface = function (target, property, index) {
      if (target == null || new.target !== undefined) {
        throw new Error(`No registration for interface: '${Interface.friendlyName}'`); // TODO: add error (trying to resolve an InterfaceSymbol that has no registrations)
      }

      const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target);
      annotationParamtypes[index] = Interface;
    };

    Interface.$isInterface = true;
    Interface.friendlyName = friendlyName == null ? '(anonymous)' : friendlyName;

    if (configure != null) {
      Interface.register = function (container, key) {
        return configure(new ResolverBuilder(container, key ?? Interface));
      };
    }

    Interface.toString = function toString() {
      return `InterfaceSymbol<${Interface.friendlyName}>`;
    };

    return Interface;
  },

  inject(...dependencies) {
    return function (target, key, descriptor) {
      if (typeof descriptor === 'number') {
        // It's a parameter decorator.
        const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target);
        const dep = dependencies[0];

        if (dep !== void 0) {
          annotationParamtypes[descriptor] = dep;
        }
      } else if (key) {
        // It's a property decorator. Not supported by the container without plugins.
        const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target.constructor);
        const dep = dependencies[0];

        if (dep !== void 0) {
          annotationParamtypes[key] = dep;
        }
      } else if (descriptor) {
        // It's a function decorator (not a Class constructor)
        const fn = descriptor.value;
        const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(fn);
        let dep;

        for (let i = 0; i < dependencies.length; ++i) {
          dep = dependencies[i];

          if (dep !== void 0) {
            annotationParamtypes[i] = dep;
          }
        }
      } else {
        // It's a class decorator.
        const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target);
        let dep;

        for (let i = 0; i < dependencies.length; ++i) {
          dep = dependencies[i];

          if (dep !== void 0) {
            annotationParamtypes[i] = dep;
          }
        }
      }
    };
  },

  /**
   * Registers the `target` class as a transient dependency; each time the dependency is resolved
   * a new instance will be created.
   *
   * @param target - The class / constructor function to register as transient.
   * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.
   *
   * @example ```ts
   * // On an existing class
   * class Foo { }
   * DI.transient(Foo);
   *
   * // Inline declaration
   * const Foo = DI.transient(class { });
   * // Foo is now strongly typed with register
   * Foo.register(container);
   * ```
   */
  transient(target) {
    target.register = function register(container) {
      const registration = Registration.transient(target, target);
      return registration.register(container, target);
    };

    target.registerInRequestor = false;
    return target;
  },

  /**
   * Registers the `target` class as a singleton dependency; the class will only be created once. Each
   * consecutive time the dependency is resolved, the same instance will be returned.
   *
   * @param target - The class / constructor function to register as a singleton.
   * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.
   * @example ```ts
   * // On an existing class
   * class Foo { }
   * DI.singleton(Foo);
   *
   * // Inline declaration
   * const Foo = DI.singleton(class { });
   * // Foo is now strongly typed with register
   * Foo.register(container);
   * ```
   */
  singleton(target, options = defaultSingletonOptions) {
    target.register = function register(container) {
      const registration = Registration.singleton(target, target);
      return registration.register(container, target);
    };

    target.registerInRequestor = options.scoped;
    return target;
  }

};
exports.DI = DI;
const IContainer = DI.createInterface('IContainer');
exports.IContainer = IContainer;
const IServiceLocator = IContainer;
exports.IServiceLocator = IServiceLocator;

function createResolver(getter) {
  return function (key) {
    const resolver = function (target, property, descriptor) {
      DI.inject(resolver)(target, property, descriptor);
    };

    resolver.$isResolver = true;

    resolver.resolve = function (handler, requestor) {
      return getter(key, handler, requestor);
    };

    return resolver;
  };
}

const inject = DI.inject;
exports.inject = inject;

function transientDecorator(target) {
  return DI.transient(target);
}

function transient(target) {
  return target == null ? transientDecorator : transientDecorator(target);
}

const defaultSingletonOptions = {
  scoped: false
};

function singletonDecorator(target) {
  return DI.singleton(target);
}

function singleton(targetOrOptions) {
  if (typeof targetOrOptions === 'function') {
    return DI.singleton(targetOrOptions);
  }

  return function ($target) {
    return DI.singleton($target, targetOrOptions);
  };
}

function createAllResolver(getter) {
  return function (key, searchAncestors) {
    searchAncestors = !!searchAncestors;

    const resolver = function (target, property, descriptor) {
      DI.inject(resolver)(target, property, descriptor);
    };

    resolver.$isResolver = true;

    resolver.resolve = function (handler, requestor) {
      return getter(key, handler, requestor, searchAncestors);
    };

    return resolver;
  };
}

const all = createAllResolver((key, handler, requestor, searchAncestors) => requestor.getAll(key, searchAncestors));
/**
 * Lazily inject a dependency depending on whether the [[`Key`]] is present at the time of function call.
 *
 * You need to make your argument a function that returns the type, for example
 * ```ts
 * class Foo {
 *   constructor( @lazy('random') public random: () => number )
 * }
 * const foo = container.get(Foo); // instanceof Foo
 * foo.random(); // throws
 * ```
 * would throw an exception because you haven't registered `'random'` before calling the method. This, would give you a
 * new [['Math.random()']] number each time.
 * ```ts
 * class Foo {
 *   constructor( @lazy('random') public random: () => random )
 * }
 * container.register(Registration.callback('random', Math.random ));
 * container.get(Foo).random(); // some random number
 * container.get(Foo).random(); // another random number
 * ```
 * `@lazy` does not manage the lifecycle of the underlying key. If you want a singleton, you have to register as a
 * `singleton`, `transient` would also behave as you would expect, providing you a new instance each time.
 *
 * - @param key [[`Key`]]
 * see { @link DI.createInterface } on interactions with interfaces
 */

exports.all = all;
const lazy = createResolver((key, handler, requestor) => {
  return () => requestor.get(key);
});
/**
 * Allows you to optionally inject a dependency depending on whether the [[`Key`]] is present, for example
 * ```ts
 * class Foo {
 *   constructor( @inject('mystring') public str: string = 'somestring' )
 * }
 * container.get(Foo); // throws
 * ```
 * would fail
 * ```ts
 * class Foo {
 *   constructor( @optional('mystring') public str: string = 'somestring' )
 * }
 * container.get(Foo).str // somestring
 * ```
 * if you use it without a default it will inject `undefined`, so rember to mark your input type as
 * possibly `undefined`!
 *
 * - @param key: [[`Key`]]
 *
 * see { @link DI.createInterface } on interactions with interfaces
 */

exports.lazy = lazy;
const optional = createResolver((key, handler, requestor) => {
  if (requestor.has(key, true)) {
    return requestor.get(key);
  } else {
    return undefined;
  }
});
/**
 * ignore tells the container not to try to inject a dependency
 */

exports.optional = optional;

function ignore(target, property, descriptor) {
  DI.inject(ignore)(target, property, descriptor);
}

ignore.$isResolver = true;

ignore.resolve = () => undefined;

const newInstanceForScope = createResolver((key, handler, requestor) => {
  const instance = createNewInstance(key, handler);
  const instanceProvider = new InstanceProvider(String(key));
  instanceProvider.prepare(instance);
  requestor.registerResolver(key, instanceProvider, true);
  return instance;
});
exports.newInstanceForScope = newInstanceForScope;
const newInstanceOf = createResolver((key, handler, _requestor) => createNewInstance(key, handler));
exports.newInstanceOf = newInstanceOf;

function createNewInstance(key, handler) {
  return handler.getFactory(key).construct(handler);
}
/** @internal */


var ResolverStrategy;
exports.ResolverStrategy = ResolverStrategy;

(function (ResolverStrategy) {
  ResolverStrategy[ResolverStrategy["instance"] = 0] = "instance";
  ResolverStrategy[ResolverStrategy["singleton"] = 1] = "singleton";
  ResolverStrategy[ResolverStrategy["transient"] = 2] = "transient";
  ResolverStrategy[ResolverStrategy["callback"] = 3] = "callback";
  ResolverStrategy[ResolverStrategy["array"] = 4] = "array";
  ResolverStrategy[ResolverStrategy["alias"] = 5] = "alias";
})(ResolverStrategy || (exports.ResolverStrategy = ResolverStrategy = {}));
/** @internal */


class Resolver {
  constructor(key, strategy, state) {
    this.key = key;
    this.strategy = strategy;
    this.state = state;
    this.resolving = false;
  }

  get $isResolver() {
    return true;
  }

  register(container, key) {
    return container.registerResolver(key || this.key, this);
  }

  resolve(handler, requestor) {
    switch (this.strategy) {
      case 0
      /* instance */
      :
        return this.state;

      case 1
      /* singleton */
      :
        {
          if (this.resolving) {
            throw new Error(`Cyclic dependency found: ${this.state.name}`);
          }

          this.resolving = true;
          this.state = handler.getFactory(this.state).construct(requestor);
          this.strategy = 0
          /* instance */
          ;
          this.resolving = false;
          return this.state;
        }

      case 2
      /* transient */
      :
        {
          // Always create transients from the requesting container
          const factory = handler.getFactory(this.state);

          if (factory === null) {
            throw new Error(`Resolver for ${String(this.key)} returned a null factory`);
          }

          return factory.construct(requestor);
        }

      case 3
      /* callback */
      :
        return this.state(handler, requestor, this);

      case 4
      /* array */
      :
        return this.state[0].resolve(handler, requestor);

      case 5
      /* alias */
      :
        return requestor.get(this.state);

      default:
        throw new Error(`Invalid resolver strategy specified: ${this.strategy}.`);
    }
  }

  getFactory(container) {
    switch (this.strategy) {
      case 1
      /* singleton */
      :
      case 2
      /* transient */
      :
        return container.getFactory(this.state);

      case 5
      /* alias */
      :
        return container.getResolver(this.state)?.getFactory?.(container) ?? null;

      default:
        return null;
    }
  }

}

exports.Resolver = Resolver;

function containerGetKey(d) {
  return this.get(d);
}

function transformInstance(inst, transform) {
  return transform(inst);
}
/** @internal */


class Factory {
  constructor(Type, dependencies) {
    this.Type = Type;
    this.dependencies = dependencies;
    this.transformers = null;
  }

  construct(container, dynamicDependencies) {
    let instance;

    if (dynamicDependencies === void 0) {
      instance = new this.Type(...this.dependencies.map(containerGetKey, container));
    } else {
      instance = new this.Type(...this.dependencies.map(containerGetKey, container), ...dynamicDependencies);
    }

    if (this.transformers == null) {
      return instance;
    }

    return this.transformers.reduce(transformInstance, instance);
  }

  registerTransformer(transformer) {
    (this.transformers ?? (this.transformers = [])).push(transformer);
  }

}

exports.Factory = Factory;
const containerResolver = {
  $isResolver: true,

  resolve(handler, requestor) {
    return requestor;
  }

};

function isRegistry(obj) {
  return typeof obj.register === 'function';
}

function isSelfRegistry(obj) {
  return isRegistry(obj) && typeof obj.registerInRequestor === 'boolean';
}

function isRegisterInRequester(obj) {
  return isSelfRegistry(obj) && obj.registerInRequestor;
}

function isClass(obj) {
  return obj.prototype !== void 0;
}

function isResourceKey(key) {
  return typeof key === 'string' && key.indexOf(':') > 0;
}

const InstrinsicTypeNames = new Set(['Array', 'ArrayBuffer', 'Boolean', 'DataView', 'Date', 'Error', 'EvalError', 'Float32Array', 'Float64Array', 'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Number', 'Object', 'Promise', 'RangeError', 'ReferenceError', 'RegExp', 'Set', 'SharedArrayBuffer', 'String', 'SyntaxError', 'TypeError', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'URIError', 'WeakMap', 'WeakSet']);
const factoryKey = 'di:factory';

const factoryAnnotationKey = _resource.Protocol.annotation.keyFor(factoryKey);
/** @internal */


class Container {
  constructor(parent, config) {
    this.parent = parent;
    this.config = config;
    this.registerDepth = 0;
    this.disposableResolvers = new Set();

    if (parent === null) {
      this.root = this;
      this.resolvers = new Map();
      this.factories = new Map();
      this.resourceResolvers = Object.create(null);
    } else {
      this.root = parent.root;
      this.resolvers = new Map();
      this.factories = parent.factories;

      if (config.inheritParentResources) {
        this.resourceResolvers = Object.assign(Object.create(null), parent.resourceResolvers, this.root.resourceResolvers);
      } else {
        this.resourceResolvers = Object.assign(Object.create(null), this.root.resourceResolvers);
      }
    }

    this.resolvers.set(IContainer, containerResolver);
  }

  get depth() {
    return this.parent === null ? 0 : this.parent.depth + 1;
  }

  register(...params) {
    if (++this.registerDepth === 100) {
      throw new Error(`Unable to autoregister dependency: [${params.map(String)}]`); // TODO: change to reporter.error and add various possible causes in description.
      // Most likely cause is trying to register a plain object that does not have a
      // register method and is not a class constructor
    }

    let current;
    let keys;
    let value;
    let j;
    let jj;

    for (let i = 0, ii = params.length; i < ii; ++i) {
      current = params[i];

      if (!(0, _metadata.isObject)(current)) {
        continue;
      }

      if (isRegistry(current)) {
        current.register(this);
      } else if (_resource.Protocol.resource.has(current)) {
        const defs = _resource.Protocol.resource.getAll(current);

        if (defs.length === 1) {
          // Fast path for the very common case
          defs[0].register(this);
        } else {
          const len = defs.length;

          for (let d = 0; d < len; ++d) {
            defs[d].register(this);
          }
        }
      } else if (isClass(current)) {
        Registration.singleton(current, current).register(this);
      } else {
        keys = Object.keys(current);
        j = 0;
        jj = keys.length;

        for (; j < jj; ++j) {
          value = current[keys[j]];

          if (!(0, _metadata.isObject)(value)) {
            continue;
          } // note: we could remove this if-branch and call this.register directly
          // - the extra check is just a perf tweak to create fewer unnecessary arrays by the spread operator


          if (isRegistry(value)) {
            value.register(this);
          } else {
            this.register(value);
          }
        }
      }
    }

    --this.registerDepth;
    return this;
  }

  registerResolver(key, resolver, isDisposable = false) {
    validateKey(key);
    const resolvers = this.resolvers;
    const result = resolvers.get(key);

    if (result == null) {
      resolvers.set(key, resolver);

      if (isResourceKey(key)) {
        this.resourceResolvers[key] = resolver;
      }
    } else if (result instanceof Resolver && result.strategy === 4
    /* array */
    ) {
        result.state.push(resolver);
      } else {
      resolvers.set(key, new Resolver(key, 4
      /* array */
      , [result, resolver]));
    }

    if (isDisposable) {
      this.disposableResolvers.add(resolver);
    }

    return resolver;
  } // public deregisterResolverFor<K extends Key, T = K>(key: K): void {
  //   // const console =  (globalThis as any).console;
  //   // console.group("deregisterResolverFor");
  //   validateKey(key);
  //   let current: Container = this;
  //   let resolver: IResolver | undefined;
  //   while (current != null) {
  //     resolver = current.resolvers.get(key);
  //     if (resolver != null) { break; }
  //     if (current.parent == null) { return; }
  //     current = current.parent;
  //   }
  //   if (resolver === void 0) { return; }
  //   if (resolver instanceof Resolver && resolver.strategy === ResolverStrategy.array) {
  //     throw new Error('Cannot deregister a resolver with array strategy');
  //   }
  //   if (this.disposableResolvers.has(resolver as IDisposableResolver<T>)) {
  //     (resolver as IDisposableResolver<T>).dispose();
  //   }
  //   if (isResourceKey(key)) {
  //     // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
  //     delete this.resourceResolvers[key];
  //   }
  //   // console.log(`BEFORE delete ${Array.from(current.resolvers.keys()).map((k) => k.toString())}`);
  //   current.resolvers.delete(key);
  //   // console.log(`AFTER delete ${Array.from(current.resolvers.keys()).map((k) => k.toString())}`);
  //   // console.groupEnd();
  // }


  registerTransformer(key, transformer) {
    const resolver = this.getResolver(key);

    if (resolver == null) {
      return false;
    }

    if (resolver.getFactory) {
      const factory = resolver.getFactory(this);

      if (factory == null) {
        return false;
      } // This type cast is a bit of a hacky one, necessary due to the duplicity of IResolverLike.
      // Problem is that that interface's type arg can be of type Key, but the getFactory method only works on
      // type Constructable. So the return type of that optional method has this additional constraint, which
      // seems to confuse the type checker.


      factory.registerTransformer(transformer);
      return true;
    }

    return false;
  }

  getResolver(key, autoRegister = true) {
    validateKey(key);

    if (key.resolve !== void 0) {
      return key;
    }

    let current = this;
    let resolver;

    while (current != null) {
      resolver = current.resolvers.get(key);

      if (resolver == null) {
        if (current.parent == null) {
          const handler = isRegisterInRequester(key) ? this : current;
          return autoRegister ? this.jitRegister(key, handler) : null;
        }

        current = current.parent;
      } else {
        return resolver;
      }
    }

    return null;
  }

  has(key, searchAncestors = false) {
    return this.resolvers.has(key) ? true : searchAncestors && this.parent != null ? this.parent.has(key, true) : false;
  }

  get(key) {
    validateKey(key);

    if (key.$isResolver) {
      return key.resolve(this, this);
    }

    let current = this;
    let resolver;

    while (current != null) {
      resolver = current.resolvers.get(key);

      if (resolver == null) {
        if (current.parent == null) {
          const handler = isRegisterInRequester(key) ? this : current;
          resolver = this.jitRegister(key, handler);
          return resolver.resolve(current, this);
        }

        current = current.parent;
      } else {
        return resolver.resolve(current, this);
      }
    }

    throw new Error(`Unable to resolve key: ${key}`);
  }

  getAll(key, searchAncestors = false) {
    validateKey(key);
    const requestor = this;
    let current = requestor;
    let resolver;

    if (searchAncestors) {
      let resolutions = _platform.emptyArray;

      while (current != null) {
        resolver = current.resolvers.get(key);

        if (resolver != null) {
          resolutions = resolutions.concat(buildAllResponse(resolver, current, requestor));
        }

        current = current.parent;
      }

      return resolutions;
    } else {
      while (current != null) {
        resolver = current.resolvers.get(key);

        if (resolver == null) {
          current = current.parent;

          if (current == null) {
            return _platform.emptyArray;
          }
        } else {
          return buildAllResponse(resolver, current, requestor);
        }
      }
    }

    return _platform.emptyArray;
  }

  getFactory(Type) {
    let factory = this.factories.get(Type);

    if (factory === void 0) {
      if ((0, _functions.isNativeFunction)(Type)) {
        throw new Error(`${Type.name} is a native function and therefore cannot be safely constructed by DI. If this is intentional, please use a callback or cachedCallback resolver.`);
      }

      this.factories.set(Type, factory = new Factory(Type, DI.getDependencies(Type)));
    }

    return factory;
  }

  registerFactory(key, factory) {
    this.factories.set(key, factory);
  }

  createChild(config) {
    if (config === void 0 && this.config.inheritParentResources) {
      if (this.config === ContainerConfiguration.DEFAULT) {
        return new Container(this, this.config);
      }

      return new Container(this, ContainerConfiguration.from({ ...this.config,
        inheritParentResources: false
      }));
    }

    return new Container(this, ContainerConfiguration.from(config ?? this.config));
  }

  disposeResolvers() {
    const disposables = Array.from(this.disposableResolvers);

    while (disposables.length > 0) {
      disposables.pop()?.dispose();
    }
  }

  find(kind, name) {
    const key = kind.keyFrom(name);
    let resolver = this.resourceResolvers[key];

    if (resolver === void 0) {
      resolver = this.root.resourceResolvers[key];

      if (resolver === void 0) {
        return null;
      }
    }

    if (resolver === null) {
      return null;
    }

    if (typeof resolver.getFactory === 'function') {
      const factory = resolver.getFactory(this);

      if (factory === null || factory === void 0) {
        return null;
      }

      const definition = _metadata.Metadata.getOwn(kind.name, factory.Type);

      if (definition === void 0) {
        // TODO: we may want to log a warning here, or even throw. This would happen if a dependency is registered with a resource-like key
        // but does not actually have a definition associated via the type's metadata. That *should* generally not happen.
        return null;
      }

      return definition;
    }

    return null;
  }

  create(kind, name) {
    const key = kind.keyFrom(name);
    let resolver = this.resourceResolvers[key];

    if (resolver === void 0) {
      resolver = this.root.resourceResolvers[key];

      if (resolver === void 0) {
        return null;
      }

      return resolver.resolve(this.root, this) ?? null;
    }

    return resolver.resolve(this, this) ?? null;
  }

  dispose() {
    this.disposeResolvers();
    this.resolvers.clear();
  }

  jitRegister(keyAsValue, handler) {
    if (typeof keyAsValue !== 'function') {
      throw new Error(`Attempted to jitRegister something that is not a constructor: '${keyAsValue}'. Did you forget to register this resource?`);
    }

    if (InstrinsicTypeNames.has(keyAsValue.name)) {
      throw new Error(`Attempted to jitRegister an intrinsic type: ${keyAsValue.name}. Did you forget to add @inject(Key)`);
    }

    if (isRegistry(keyAsValue)) {
      const registrationResolver = keyAsValue.register(handler, keyAsValue);

      if (!(registrationResolver instanceof Object) || registrationResolver.resolve == null) {
        const newResolver = handler.resolvers.get(keyAsValue);

        if (newResolver != void 0) {
          return newResolver;
        }

        throw new Error(`Invalid resolver returned from the static register method`);
      }

      return registrationResolver;
    } else if (_resource.Protocol.resource.has(keyAsValue)) {
      const defs = _resource.Protocol.resource.getAll(keyAsValue);

      if (defs.length === 1) {
        // Fast path for the very common case
        defs[0].register(handler);
      } else {
        const len = defs.length;

        for (let d = 0; d < len; ++d) {
          defs[d].register(handler);
        }
      }

      const newResolver = handler.resolvers.get(keyAsValue);

      if (newResolver != void 0) {
        return newResolver;
      }

      throw new Error(`Invalid resolver returned from the static register method`);
    } else if (keyAsValue.$isInterface) {
      throw new Error(`Attempted to jitRegister an interface: ${keyAsValue.friendlyName}`);
    } else {
      const resolver = this.config.defaultResolver(keyAsValue, handler);
      handler.resolvers.set(keyAsValue, resolver);
      return resolver;
    }
  }

}
/**
 * An implementation of IRegistry that delegates registration to a
 * separately registered class. The ParameterizedRegistry facilitates the
 * passing of parameters to the final registry.
 */


exports.Container = Container;

class ParameterizedRegistry {
  constructor(key, params) {
    this.key = key;
    this.params = params;
  }

  register(container) {
    if (container.has(this.key, true)) {
      const registry = container.get(this.key);
      registry.register(container, ...this.params);
    } else {
      container.register(...this.params.filter(x => typeof x === 'object'));
    }
  }

}

exports.ParameterizedRegistry = ParameterizedRegistry;
const cache = new WeakMap();

function cacheCallbackResult(fun) {
  return function (handler, requestor, resolver) {
    if (cache.has(resolver)) {
      return cache.get(resolver);
    }

    const t = fun(handler, requestor, resolver);
    cache.set(resolver, t);
    return t;
  };
}
/**
 * you can use the resulting {@linkcode IRegistration} of any of the factory methods
 * to register with the container, e.g.
 * ```
 * class Foo {}
 * const container = DI.createContainer();
 * container.register(Registration.instance(Foo, new Foo()));
 * container.get(Foo);
 * ```
 */


const Registration = {
  /**
   * allows you to pass an instance.
   * Every time you request this {@linkcode Key} you will get this instance back.
   * ```
   * Registration.instance(Foo, new Foo()));
   * ```
   *
   * @param key
   * @param value
   */
  instance(key, value) {
    return new Resolver(key, 0
    /* instance */
    , value);
  },

  /**
   * Creates an instance from the class.
   * Every time you request this {@linkcode Key} you will get the same one back.
   * ```
   * Registration.singleton(Foo, Foo);
   * ```
   *
   * @param key
   * @param value
   */
  singleton(key, value) {
    return new Resolver(key, 1
    /* singleton */
    , value);
  },

  /**
   * Creates an instance from a class.
   * Every time you request this {@linkcode Key} you will get a new instance.
   * ```
   * Registration.instance(Foo, Foo);
   * ```
   *
   * @param key
   * @param value
   */
  transient(key, value) {
    return new Resolver(key, 2
    /* transient */
    , value);
  },

  /**
   * Creates an instance from the method passed.
   * Every time you request this {@linkcode Key} you will get a new instance.
   * ```
   * Registration.callback(Foo, () => new Foo());
   * Registration.callback(Bar, (c: IContainer) => new Bar(c.get(Foo)));
   * ```
   *
   * @param key
   * @param callback
   */
  callback(key, callback) {
    return new Resolver(key, 3
    /* callback */
    , callback);
  },

  /**
   * Creates an instance from the method passed.
   * On the first request for the {@linkcode Key} your callback is called and returns an instance.
   * subsequent requests for the {@linkcode Key}, the initial instance returned will be returned.
   * If you pass the same {@linkcode Registration} to another container the same cached value will be used.
   * Should all references to the resolver returned be removed, the cache will expire.
   * ```
   * Registration.cachedCallback(Foo, () => new Foo());
   * Registration.cachedCallback(Bar, (c: IContainer) => new Bar(c.get(Foo)));
   * ```
   *
   * @param key
   * @param callback
   */
  cachedCallback(key, callback) {
    return new Resolver(key, 3
    /* callback */
    , cacheCallbackResult(callback));
  },

  /**
   * creates an alternate {@linkcode Key} to retrieve an instance by.
   * Returns the same scope as the original {@linkcode Key}.
   * ```
   * Register.singleton(Foo, Foo)
   * Register.aliasTo(Foo, MyFoos);
   *
   * container.getAll(MyFoos) // contains an instance of Foo
   * ```
   *
   * @param originalKey
   * @param aliasKey
   */
  aliasTo(originalKey, aliasKey) {
    return new Resolver(aliasKey, 5
    /* alias */
    , originalKey);
  },

  /**
   * @internal
   * @param key
   * @param params
   */
  defer(key, ...params) {
    return new ParameterizedRegistry(key, params);
  }

};
exports.Registration = Registration;

class InstanceProvider {
  constructor(friendlyName) {
    this.friendlyName = friendlyName;
    this.instance = null;
  }

  prepare(instance) {
    this.instance = instance;
  }

  get $isResolver() {
    return true;
  }

  resolve() {
    if (this.instance == null) {
      throw new Error(`Cannot call resolve ${this.friendlyName} before calling prepare or after calling dispose.`);
    }

    return this.instance;
  }

  dispose() {
    this.instance = null;
  }

}
/** @internal */


exports.InstanceProvider = InstanceProvider;

function validateKey(key) {
  if (key === null || key === void 0) {
    throw new Error('key/value cannot be null or undefined. Are you trying to inject/register something that doesn\'t exist with DI?');
  }
}

function buildAllResponse(resolver, handler, requestor) {
  if (resolver instanceof Resolver && resolver.strategy === 4
  /* array */
  ) {
      const state = resolver.state;
      let i = state.length;
      const results = new Array(i);

      while (i--) {
        results[i] = state[i].resolve(handler, requestor);
      }

      return results;
    }

  return [resolver.resolve(handler, requestor)];
}
});

;define.alias('@aurelia/kernel/di.js','@aurelia/kernel/dist/esm/di.js');
define('@aurelia/kernel/dist/esm/eventaggregator.js',['require','exports','module','./di.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.EventAggregator = exports.IEventAggregator = void 0;

var _di = require("./di.js");

/* eslint-disable @typescript-eslint/restrict-template-expressions */

/**
 * Represents a handler for an EventAggregator event.
 */
class Handler {
  constructor(messageType, callback) {
    this.messageType = messageType;
    this.callback = callback;
  }

  handle(message) {
    if (message instanceof this.messageType) {
      this.callback.call(null, message);
    }
  }

}

const IEventAggregator = _di.DI.createInterface('IEventAggregator', x => x.singleton(EventAggregator));
/**
 * Enables loosely coupled publish/subscribe messaging.
 */


exports.IEventAggregator = IEventAggregator;

class EventAggregator {
  constructor() {
    /** @internal */
    this.eventLookup = {};
    /** @internal */

    this.messageHandlers = [];
  }

  publish(channelOrInstance, message) {
    if (!channelOrInstance) {
      throw new Error(`Invalid channel name or instance: ${channelOrInstance}.`);
    }

    if (typeof channelOrInstance === 'string') {
      let subscribers = this.eventLookup[channelOrInstance];

      if (subscribers !== void 0) {
        subscribers = subscribers.slice();
        let i = subscribers.length;

        while (i-- > 0) {
          subscribers[i](message, channelOrInstance);
        }
      }
    } else {
      const subscribers = this.messageHandlers.slice();
      let i = subscribers.length;

      while (i-- > 0) {
        subscribers[i].handle(channelOrInstance);
      }
    }
  }

  subscribe(channelOrType, callback) {
    if (!channelOrType) {
      throw new Error(`Invalid channel name or type: ${channelOrType}.`);
    }

    let handler;
    let subscribers;

    if (typeof channelOrType === 'string') {
      if (this.eventLookup[channelOrType] === void 0) {
        this.eventLookup[channelOrType] = [];
      }

      handler = callback;
      subscribers = this.eventLookup[channelOrType];
    } else {
      handler = new Handler(channelOrType, callback);
      subscribers = this.messageHandlers;
    }

    subscribers.push(handler);
    return {
      dispose() {
        const idx = subscribers.indexOf(handler);

        if (idx !== -1) {
          subscribers.splice(idx, 1);
        }
      }

    };
  }

  subscribeOnce(channelOrType, callback) {
    const sub = this.subscribe(channelOrType, function (message, event) {
      sub.dispose();
      callback(message, event);
    });
    return sub;
  }

}

exports.EventAggregator = EventAggregator;
});

;define.alias('@aurelia/kernel/eventaggregator.js','@aurelia/kernel/dist/esm/eventaggregator.js');
define('@aurelia/kernel/dist/esm/functions.js',['require','exports','module','./platform.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.isArrayIndex = isArrayIndex;
exports.isNumberOrBigInt = isNumberOrBigInt;
exports.isStringOrDate = isStringOrDate;
exports.toArray = toArray;
exports.nextId = nextId;
exports.resetId = resetId;
exports.compareNumber = compareNumber;
exports.mergeDistinct = mergeDistinct;
exports.bound = bound;
exports.mergeArrays = mergeArrays;
exports.mergeObjects = mergeObjects;
exports.firstDefined = firstDefined;
exports.toLookup = toLookup;
exports.onResolve = onResolve;
exports.resolveAll = resolveAll;
exports.isNativeFunction = exports.getPrototypeChain = exports.kebabCase = exports.pascalCase = exports.camelCase = void 0;

var _platform = require("./platform.js");

const isNumericLookup = {};
/**
 * Efficiently determine whether the provided property key is numeric
 * (and thus could be an array indexer) or not.
 *
 * Always returns true for values of type `'number'`.
 *
 * Otherwise, only returns true for strings that consist only of positive integers.
 *
 * Results are cached.
 */

function isArrayIndex(value) {
  switch (typeof value) {
    case 'number':
      return value >= 0 && (value | 0) === value;

    case 'string':
      {
        const result = isNumericLookup[value];

        if (result !== void 0) {
          return result;
        }

        const length = value.length;

        if (length === 0) {
          return isNumericLookup[value] = false;
        }

        let ch = 0;

        for (let i = 0; i < length; ++i) {
          ch = value.charCodeAt(i);

          if (i === 0 && ch === 0x30 && length > 1
          /* must not start with 0 */
          || ch < 0x30
          /* 0 */
          || ch > 0x39
          /* 9 */
          ) {
              return isNumericLookup[value] = false;
            }
        }

        return isNumericLookup[value] = true;
      }

    default:
      return false;
  }
}
/**
 * Determines if the value passed is a number or bigint for parsing purposes
 *
 * @param value - Value to evaluate
 */


function isNumberOrBigInt(value) {
  switch (typeof value) {
    case 'number':
    case 'bigint':
      return true;

    default:
      return false;
  }
}
/**
 * Determines if the value passed is a number or bigint for parsing purposes
 *
 * @param value - Value to evaluate
 */


function isStringOrDate(value) {
  switch (typeof value) {
    case 'string':
      return true;

    case 'object':
      return value instanceof Date;

    default:
      return false;
  }
}
/**
 * Base implementation of camel and kebab cases
 */


const baseCase = function () {
  let CharKind;

  (function (CharKind) {
    CharKind[CharKind["none"] = 0] = "none";
    CharKind[CharKind["digit"] = 1] = "digit";
    CharKind[CharKind["upper"] = 2] = "upper";
    CharKind[CharKind["lower"] = 3] = "lower";
  })(CharKind || (CharKind = {})); // eslint-disable-next-line @typescript-eslint/consistent-type-assertions


  const isDigit = Object.assign(Object.create(null), {
    '0': true,
    '1': true,
    '2': true,
    '3': true,
    '4': true,
    '5': true,
    '6': true,
    '7': true,
    '8': true,
    '9': true
  });

  function charToKind(char) {
    if (char === '') {
      // We get this if we do charAt() with an index out of range
      return 0
      /* none */
      ;
    }

    if (char !== char.toUpperCase()) {
      return 3
      /* lower */
      ;
    }

    if (char !== char.toLowerCase()) {
      return 2
      /* upper */
      ;
    }

    if (isDigit[char] === true) {
      return 1
      /* digit */
      ;
    }

    return 0
    /* none */
    ;
  }

  return function (input, cb) {
    const len = input.length;

    if (len === 0) {
      return input;
    }

    let sep = false;
    let output = '';
    let prevKind;
    let curChar = '';
    let curKind = 0
    /* none */
    ;
    let nextChar = input.charAt(0);
    let nextKind = charToKind(nextChar);

    for (let i = 0; i < len; ++i) {
      prevKind = curKind;
      curChar = nextChar;
      curKind = nextKind;
      nextChar = input.charAt(i + 1);
      nextKind = charToKind(nextChar);

      if (curKind === 0
      /* none */
      ) {
          if (output.length > 0) {
            // Only set sep to true if it's not at the beginning of output.
            sep = true;
          }
        } else {
        if (!sep && output.length > 0 && curKind === 2
        /* upper */
        ) {
            // Separate UAFoo into UA Foo.
            // Separate uaFOO into ua FOO.
            sep = prevKind === 3
            /* lower */
            || nextKind === 3
            /* lower */
            ;
          }

        output += cb(curChar, sep);
        sep = false;
      }
    }

    return output;
  };
}();
/**
 * Efficiently convert a string to camelCase.
 *
 * Non-alphanumeric characters are treated as separators.
 *
 * Primarily used by Aurelia to convert DOM attribute names to ViewModel property names.
 *
 * Results are cached.
 */


const camelCase = function () {
  const cache = Object.create(null);

  function callback(char, sep) {
    return sep ? char.toUpperCase() : char.toLowerCase();
  }

  return function (input) {
    let output = cache[input];

    if (output === void 0) {
      output = cache[input] = baseCase(input, callback);
    }

    return output;
  };
}();
/**
 * Efficiently convert a string to PascalCase.
 *
 * Non-alphanumeric characters are treated as separators.
 *
 * Primarily used by Aurelia to convert element names to class names for synthetic types.
 *
 * Results are cached.
 */


exports.camelCase = camelCase;

const pascalCase = function () {
  const cache = Object.create(null);
  return function (input) {
    let output = cache[input];

    if (output === void 0) {
      output = camelCase(input);

      if (output.length > 0) {
        output = output[0].toUpperCase() + output.slice(1);
      }

      cache[input] = output;
    }

    return output;
  };
}();
/**
 * Efficiently convert a string to kebab-case.
 *
 * Non-alphanumeric characters are treated as separators.
 *
 * Primarily used by Aurelia to convert ViewModel property names to DOM attribute names.
 *
 * Results are cached.
 */


exports.pascalCase = pascalCase;

const kebabCase = function () {
  const cache = Object.create(null);

  function callback(char, sep) {
    return sep ? `-${char.toLowerCase()}` : char.toLowerCase();
  }

  return function (input) {
    let output = cache[input];

    if (output === void 0) {
      output = cache[input] = baseCase(input, callback);
    }

    return output;
  };
}();
/**
 * Efficiently (up to 10x faster than `Array.from`) convert an `ArrayLike` to a real array.
 *
 * Primarily used by Aurelia to convert DOM node lists to arrays.
 */


exports.kebabCase = kebabCase;

function toArray(input) {
  // benchmark: http://jsben.ch/xjsyF
  const {
    length
  } = input;
  const arr = Array(length);

  for (let i = 0; i < length; ++i) {
    arr[i] = input[i];
  }

  return arr;
}

const ids = {};
/**
 * Retrieve the next ID in a sequence for a given string, starting with `1`.
 *
 * Used by Aurelia to assign unique ID's to controllers and resources.
 *
 * Aurelia will always prepend the context name with `au$`, so as long as you avoid
 * using that convention you should be safe from collisions.
 */

function nextId(context) {
  if (ids[context] === void 0) {
    ids[context] = 0;
  }

  return ++ids[context];
}
/**
 * Reset the ID for the given string, so that `nextId` will return `1` again for the next call.
 *
 * Used by Aurelia to reset ID's in between unit tests.
 */


function resetId(context) {
  ids[context] = 0;
}
/**
 * A compare function to pass to `Array.prototype.sort` for sorting numbers.
 * This is needed for numeric sort, since the default sorts them as strings.
 */


function compareNumber(a, b) {
  return a - b;
}
/**
 * Efficiently merge and deduplicate the (primitive) values in two arrays.
 *
 * Does not deduplicate existing values in the first array.
 *
 * Guards against null or undefined arrays.
 *
 * Returns `emptyArray` if both arrays are either `null`, `undefined` or `emptyArray`
 *
 * @param slice - If `true`, always returns a new array copy (unless neither array is/has a value)
 */


function mergeDistinct(arr1, arr2, slice) {
  if (arr1 === void 0 || arr1 === null || arr1 === _platform.emptyArray) {
    if (arr2 === void 0 || arr2 === null || arr2 === _platform.emptyArray) {
      return _platform.emptyArray;
    } else {
      return slice ? arr2.slice(0) : arr2;
    }
  } else if (arr2 === void 0 || arr2 === null || arr2 === _platform.emptyArray) {
    return slice ? arr1.slice(0) : arr1;
  }

  const lookup = {};
  const arr3 = slice ? arr1.slice(0) : arr1;
  let len1 = arr1.length;
  let len2 = arr2.length;

  while (len1-- > 0) {
    lookup[arr1[len1]] = true;
  }

  let item;

  while (len2-- > 0) {
    item = arr2[len2];

    if (lookup[item] === void 0) {
      arr3.push(item);
      lookup[item] = true;
    }
  }

  return arr3;
}
/**
 * Decorator. (lazily) bind the method to the class instance on first call.
 */
// eslint-disable-next-line @typescript-eslint/ban-types


function bound(target, key, descriptor) {
  return {
    configurable: true,
    enumerable: descriptor.enumerable,

    get() {
      const boundFn = descriptor.value.bind(this);
      Reflect.defineProperty(this, key, {
        value: boundFn,
        writable: true,
        configurable: true,
        enumerable: descriptor.enumerable
      });
      return boundFn;
    }

  };
}

function mergeArrays(...arrays) {
  const result = [];
  let k = 0;
  const arraysLen = arrays.length;
  let arrayLen = 0;
  let array;

  for (let i = 0; i < arraysLen; ++i) {
    array = arrays[i];

    if (array !== void 0) {
      arrayLen = array.length;

      for (let j = 0; j < arrayLen; ++j) {
        result[k++] = array[j];
      }
    }
  }

  return result;
}

function mergeObjects(...objects) {
  const result = {};
  const objectsLen = objects.length;
  let object;
  let key;

  for (let i = 0; i < objectsLen; ++i) {
    object = objects[i];

    if (object !== void 0) {
      for (key in object) {
        result[key] = object[key];
      }
    }
  }

  return result;
}

function firstDefined(...values) {
  const len = values.length;
  let value;

  for (let i = 0; i < len; ++i) {
    value = values[i];

    if (value !== void 0) {
      return value;
    }
  }

  throw new Error(`No default value found`);
}

const getPrototypeChain = function () {
  const functionPrototype = Function.prototype;
  const getPrototypeOf = Object.getPrototypeOf;
  const cache = new WeakMap();
  let proto = functionPrototype;
  let i = 0;
  let chain = void 0;
  return function (Type) {
    chain = cache.get(Type);

    if (chain === void 0) {
      cache.set(Type, chain = [proto = Type]);
      i = 0;

      while ((proto = getPrototypeOf(proto)) !== functionPrototype) {
        chain[++i] = proto;
      }
    }

    return chain;
  };
}();

exports.getPrototypeChain = getPrototypeChain;

function toLookup(...objs) {
  return Object.assign(Object.create(null), ...objs);
}
/**
 * Determine whether the value is a native function.
 *
 * @param fn - The function to check.
 * @returns `true` is the function is a native function, otherwise `false`
 */


const isNativeFunction = function () {
  // eslint-disable-next-line @typescript-eslint/ban-types
  const lookup = new WeakMap();
  let isNative = false;
  let sourceText = '';
  let i = 0; // eslint-disable-next-line @typescript-eslint/ban-types

  return function (fn) {
    isNative = lookup.get(fn);

    if (isNative === void 0) {
      sourceText = fn.toString();
      i = sourceText.length; // http://www.ecma-international.org/ecma-262/#prod-NativeFunction

      isNative = // 29 is the length of 'function () { [native code] }' which is the smallest length of a native function string
      i >= 29 && // 100 seems to be a safe upper bound of the max length of a native function. In Chrome and FF it's 56, in Edge it's 61.
      i <= 100 && // This whole heuristic *could* be tricked by a comment. Do we need to care about that?
      sourceText.charCodeAt(i - 1) === 0x7D && // }
      // TODO: the spec is a little vague about the precise constraints, so we do need to test this across various browsers to make sure just one whitespace is a safe assumption.
      sourceText.charCodeAt(i - 2) <= 0x20 && // whitespace
      sourceText.charCodeAt(i - 3) === 0x5D && // ]
      sourceText.charCodeAt(i - 4) === 0x65 && // e
      sourceText.charCodeAt(i - 5) === 0x64 && // d
      sourceText.charCodeAt(i - 6) === 0x6F && // o
      sourceText.charCodeAt(i - 7) === 0x63 && // c
      sourceText.charCodeAt(i - 8) === 0x20 && //
      sourceText.charCodeAt(i - 9) === 0x65 && // e
      sourceText.charCodeAt(i - 10) === 0x76 && // v
      sourceText.charCodeAt(i - 11) === 0x69 && // i
      sourceText.charCodeAt(i - 12) === 0x74 && // t
      sourceText.charCodeAt(i - 13) === 0x61 && // a
      sourceText.charCodeAt(i - 14) === 0x6E && // n
      sourceText.charCodeAt(i - 15) === 0x58 // [
      ;
      lookup.set(fn, isNative);
    }

    return isNative;
  };
}();
/**
 * Normalize a potential promise via a callback, to ensure things stay synchronous when they can.
 *
 * If the value is a promise, it is `then`ed before the callback is invoked. Otherwise the callback is invoked synchronously.
 */


exports.isNativeFunction = isNativeFunction;

function onResolve(maybePromise, resolveCallback) {
  if (maybePromise instanceof Promise) {
    return maybePromise.then(resolveCallback);
  }

  return resolveCallback(maybePromise);
}
/**
 * Normalize an array of potential promises, to ensure things stay synchronous when they can.
 *
 * If exactly one value is a promise, then that promise is returned.
 *
 * If more than one value is a promise, a new `Promise.all` is returned.
 *
 * If none of the values is a promise, nothing is returned, to indicate that things can stay synchronous.
 */


function resolveAll(...maybePromises) {
  let maybePromise = void 0;
  let firstPromise = void 0;
  let promises = void 0;

  for (let i = 0, ii = maybePromises.length; i < ii; ++i) {
    maybePromise = maybePromises[i];

    if ((maybePromise = maybePromises[i]) instanceof Promise) {
      if (firstPromise === void 0) {
        firstPromise = maybePromise;
      } else if (promises === void 0) {
        promises = [firstPromise, maybePromise];
      } else {
        promises.push(maybePromise);
      }
    }
  }

  if (promises === void 0) {
    return firstPromise;
  }

  return Promise.all(promises);
}
});

;define.alias('@aurelia/kernel/functions.js','@aurelia/kernel/dist/esm/functions.js');
define('@aurelia/kernel/dist/esm/index.js',['require','exports','module','./di.js','@aurelia/platform','@aurelia/metadata','./logger.js','./module-loader.js','./platform.js','./resource.js','./eventaggregator.js','./functions.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.resolveAll = exports.onResolve = exports.isNativeFunction = exports.getPrototypeChain = exports.firstDefined = exports.mergeObjects = exports.mergeArrays = exports.bound = exports.isStringOrDate = exports.isNumberOrBigInt = exports.mergeDistinct = exports.compareNumber = exports.resetId = exports.nextId = exports.toArray = exports.pascalCase = exports.kebabCase = exports.camelCase = exports.isArrayIndex = exports.IEventAggregator = exports.EventAggregator = exports.fromDefinitionOrDefault = exports.fromAnnotationOrTypeOrDefault = exports.fromAnnotationOrDefinitionOrTypeOrDefault = exports.Protocol = exports.emptyObject = exports.emptyArray = exports.noop = exports.ModuleItem = exports.AnalyzedModule = exports.IModuleLoader = exports.sink = exports.format = exports.LoggerConfiguration = exports.ConsoleSink = exports.DefaultLogger = exports.DefaultLogEventFactory = exports.DefaultLogEvent = exports.LogConfig = exports.ILogger = exports.ISink = exports.ILogEventFactory = exports.ILogConfig = exports.ColorOptions = exports.LogLevel = exports.applyMetadataPolyfill = exports.isObject = exports.isNullOrUndefined = exports.Metadata = exports.metadata = exports.DefaultResolver = exports.ContainerConfiguration = exports.newInstanceOf = exports.newInstanceForScope = exports.InstanceProvider = exports.transient = exports.singleton = exports.Registration = exports.ignore = exports.optional = exports.lazy = exports.IServiceLocator = exports.inject = exports.IContainer = exports.all = exports.TaskStatus = exports.TaskQueuePriority = exports.TaskAbortError = exports.Task = exports.TaskQueue = exports.Platform = exports.IPlatform = void 0;

var _di = require("./di.js");

exports.DI = _di.DI;
exports.all = _di.all;
exports.IContainer = _di.IContainer;
exports.inject = _di.inject;
exports.IServiceLocator = _di.IServiceLocator;
exports.lazy = _di.lazy;
exports.optional = _di.optional;
exports.ignore = _di.ignore;
exports.Registration = _di.Registration;
exports.singleton = _di.singleton;
exports.transient = _di.transient;
exports.InstanceProvider = _di.InstanceProvider;
exports.newInstanceForScope = _di.newInstanceForScope;
exports.newInstanceOf = _di.newInstanceOf;
exports.ContainerConfiguration = _di.ContainerConfiguration;
exports.DefaultResolver = _di.DefaultResolver;

var _platform = require("@aurelia/platform");

exports.Platform = _platform.Platform;
exports.TaskQueue = _platform.TaskQueue;
exports.Task = _platform.Task;
exports.TaskAbortError = _platform.TaskAbortError;
exports.TaskQueuePriority = _platform.TaskQueuePriority;
exports.TaskStatus = _platform.TaskStatus;

var _metadata = require("@aurelia/metadata");

exports.metadata = _metadata.metadata;
exports.Metadata = _metadata.Metadata;
exports.isNullOrUndefined = _metadata.isNullOrUndefined;
exports.isObject = _metadata.isObject;
exports.applyMetadataPolyfill = _metadata.applyMetadataPolyfill;

var _logger = require("./logger.js");

exports.LogLevel = _logger.LogLevel;
exports.ColorOptions = _logger.ColorOptions;
exports.ILogConfig = _logger.ILogConfig;
exports.ILogEventFactory = _logger.ILogEventFactory;
exports.ISink = _logger.ISink;
exports.ILogger = _logger.ILogger;
exports.LogConfig = _logger.LogConfig;
exports.DefaultLogEvent = _logger.DefaultLogEvent;
exports.DefaultLogEventFactory = _logger.DefaultLogEventFactory;
exports.DefaultLogger = _logger.DefaultLogger;
exports.ConsoleSink = _logger.ConsoleSink;
exports.LoggerConfiguration = _logger.LoggerConfiguration;
exports.format = _logger.format;
exports.sink = _logger.sink;

var _moduleLoader = require("./module-loader.js");

exports.IModuleLoader = _moduleLoader.IModuleLoader;
exports.AnalyzedModule = _moduleLoader.AnalyzedModule;
exports.ModuleItem = _moduleLoader.ModuleItem;

var _platform2 = require("./platform.js");

exports.noop = _platform2.noop;
exports.emptyArray = _platform2.emptyArray;
exports.emptyObject = _platform2.emptyObject;

var _resource = require("./resource.js");

exports.Protocol = _resource.Protocol;
exports.fromAnnotationOrDefinitionOrTypeOrDefault = _resource.fromAnnotationOrDefinitionOrTypeOrDefault;
exports.fromAnnotationOrTypeOrDefault = _resource.fromAnnotationOrTypeOrDefault;
exports.fromDefinitionOrDefault = _resource.fromDefinitionOrDefault;

var _eventaggregator = require("./eventaggregator.js");

exports.EventAggregator = _eventaggregator.EventAggregator;
exports.IEventAggregator = _eventaggregator.IEventAggregator;

var _functions = require("./functions.js");

exports.isArrayIndex = _functions.isArrayIndex;
exports.camelCase = _functions.camelCase;
exports.kebabCase = _functions.kebabCase;
exports.pascalCase = _functions.pascalCase;
exports.toArray = _functions.toArray;
exports.nextId = _functions.nextId;
exports.resetId = _functions.resetId;
exports.compareNumber = _functions.compareNumber;
exports.mergeDistinct = _functions.mergeDistinct;
exports.isNumberOrBigInt = _functions.isNumberOrBigInt;
exports.isStringOrDate = _functions.isStringOrDate;
exports.bound = _functions.bound;
exports.mergeArrays = _functions.mergeArrays;
exports.mergeObjects = _functions.mergeObjects;
exports.firstDefined = _functions.firstDefined;
exports.getPrototypeChain = _functions.getPrototypeChain;
exports.isNativeFunction = _functions.isNativeFunction;
exports.onResolve = _functions.onResolve;
exports.resolveAll = _functions.resolveAll;

const IPlatform = _di.DI.createInterface('IPlatform');

exports.IPlatform = IPlatform;
});

;define.alias('@aurelia/kernel','@aurelia/kernel/dist/esm/index.js');
define('@aurelia/kernel/dist/esm/logger.js',['require','exports','module','./di.js','./functions.js','./resource.js','@aurelia/metadata'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.sink = sink;
exports.LoggerConfiguration = exports.DefaultLogger = exports.ConsoleSink = exports.DefaultLogEventFactory = exports.DefaultLogEvent = exports.LogConfig = exports.format = exports.LoggerSink = exports.ILogScopes = exports.ILogger = exports.ILogEventFactory = exports.ISink = exports.ILogConfig = exports.ColorOptions = exports.LogLevel = void 0;

var _di = require("./di.js");

var _functions = require("./functions.js");

var _resource = require("./resource.js");

var _metadata = require("@aurelia/metadata");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

var LogLevel;
exports.LogLevel = LogLevel;

(function (LogLevel) {
  /**
   * The most detailed information about internal app state.
   *
   * Disabled by default and should never be enabled in a production environment.
   */
  LogLevel[LogLevel["trace"] = 0] = "trace";
  /**
   * Information that is useful for debugging during development and has no long-term value.
   */

  LogLevel[LogLevel["debug"] = 1] = "debug";
  /**
   * Information about the general flow of the application that has long-term value.
   */

  LogLevel[LogLevel["info"] = 2] = "info";
  /**
   * Unexpected circumstances that require attention but do not otherwise cause the current flow of execution to stop.
   */

  LogLevel[LogLevel["warn"] = 3] = "warn";
  /**
   * Unexpected circumstances that cause the flow of execution in the current activity to stop but do not cause an app-wide failure.
   */

  LogLevel[LogLevel["error"] = 4] = "error";
  /**
   * Unexpected circumstances that cause an app-wide failure or otherwise require immediate attention.
   */

  LogLevel[LogLevel["fatal"] = 5] = "fatal";
  /**
   * No messages should be written.
   */

  LogLevel[LogLevel["none"] = 6] = "none";
})(LogLevel || (exports.LogLevel = LogLevel = {}));
/**
 * Flags to enable/disable color usage in the logging output.
 */


var ColorOptions;
exports.ColorOptions = ColorOptions;

(function (ColorOptions) {
  /**
   * Do not use ASCII color codes in logging output.
   */
  ColorOptions[ColorOptions["noColors"] = 0] = "noColors";
  /**
   * Use ASCII color codes in logging output. By default, timestamps and the TRC and DBG prefix are colored grey. INF white, WRN yellow, and ERR and FTL red.
   */

  ColorOptions[ColorOptions["colors"] = 1] = "colors";
})(ColorOptions || (exports.ColorOptions = ColorOptions = {}));

const ILogConfig = _di.DI.createInterface('ILogConfig', x => x.instance(new LogConfig(0
/* noColors */
, 3
/* warn */
)));

exports.ILogConfig = ILogConfig;

const ISink = _di.DI.createInterface('ISink');

exports.ISink = ISink;

const ILogEventFactory = _di.DI.createInterface('ILogEventFactory', x => x.singleton(DefaultLogEventFactory));

exports.ILogEventFactory = ILogEventFactory;

const ILogger = _di.DI.createInterface('ILogger', x => x.singleton(DefaultLogger));

exports.ILogger = ILogger;

const ILogScopes = _di.DI.createInterface('ILogScope');

exports.ILogScopes = ILogScopes;
const LoggerSink = Object.freeze({
  key: _resource.Protocol.annotation.keyFor('logger-sink-handles'),

  define(target, definition) {
    _metadata.Metadata.define(this.key, definition.handles, target.prototype);

    return target;
  },

  getHandles(target) {
    return _metadata.Metadata.get(this.key, target);
  }

});
exports.LoggerSink = LoggerSink;

function sink(definition) {
  return function (target) {
    return LoggerSink.define(target, definition);
  };
} // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics


const format = (0, _functions.toLookup)({
  red(str) {
    return `\u001b[31m${str}\u001b[39m`;
  },

  green(str) {
    return `\u001b[32m${str}\u001b[39m`;
  },

  yellow(str) {
    return `\u001b[33m${str}\u001b[39m`;
  },

  blue(str) {
    return `\u001b[34m${str}\u001b[39m`;
  },

  magenta(str) {
    return `\u001b[35m${str}\u001b[39m`;
  },

  cyan(str) {
    return `\u001b[36m${str}\u001b[39m`;
  },

  white(str) {
    return `\u001b[37m${str}\u001b[39m`;
  },

  grey(str) {
    return `\u001b[90m${str}\u001b[39m`;
  }

});
exports.format = format;

class LogConfig {
  constructor(colorOptions, level) {
    this.colorOptions = colorOptions;
    this.level = level;
  }

}

exports.LogConfig = LogConfig;

const getLogLevelString = function () {
  const logLevelString = [(0, _functions.toLookup)({
    TRC: 'TRC',
    DBG: 'DBG',
    INF: 'INF',
    WRN: 'WRN',
    ERR: 'ERR',
    FTL: 'FTL',
    QQQ: '???'
  }), (0, _functions.toLookup)({
    TRC: format.grey('TRC'),
    DBG: format.grey('DBG'),
    INF: format.white('INF'),
    WRN: format.yellow('WRN'),
    ERR: format.red('ERR'),
    FTL: format.red('FTL'),
    QQQ: format.grey('???')
  })];
  return function (level, colorOptions) {
    if (level <= 0
    /* trace */
    ) {
        return logLevelString[colorOptions].TRC;
      }

    if (level <= 1
    /* debug */
    ) {
        return logLevelString[colorOptions].DBG;
      }

    if (level <= 2
    /* info */
    ) {
        return logLevelString[colorOptions].INF;
      }

    if (level <= 3
    /* warn */
    ) {
        return logLevelString[colorOptions].WRN;
      }

    if (level <= 4
    /* error */
    ) {
        return logLevelString[colorOptions].ERR;
      }

    if (level <= 5
    /* fatal */
    ) {
        return logLevelString[colorOptions].FTL;
      }

    return logLevelString[colorOptions].QQQ;
  };
}();

function getScopeString(scope, colorOptions) {
  if (colorOptions === 0
  /* noColors */
  ) {
      return scope.join('.');
    }

  return scope.map(format.cyan).join('.');
}

function getIsoString(timestamp, colorOptions) {
  if (colorOptions === 0
  /* noColors */
  ) {
      return new Date(timestamp).toISOString();
    }

  return format.grey(new Date(timestamp).toISOString());
}

class DefaultLogEvent {
  constructor(severity, message, optionalParams, scope, colorOptions, timestamp) {
    this.severity = severity;
    this.message = message;
    this.optionalParams = optionalParams;
    this.scope = scope;
    this.colorOptions = colorOptions;
    this.timestamp = timestamp;
  }

  toString() {
    const {
      severity,
      message,
      scope,
      colorOptions,
      timestamp
    } = this;

    if (scope.length === 0) {
      return `${getIsoString(timestamp, colorOptions)} [${getLogLevelString(severity, colorOptions)}] ${message}`;
    }

    return `${getIsoString(timestamp, colorOptions)} [${getLogLevelString(severity, colorOptions)} ${getScopeString(scope, colorOptions)}] ${message}`;
  }

}

exports.DefaultLogEvent = DefaultLogEvent;
let DefaultLogEventFactory = class DefaultLogEventFactory {
  constructor(config) {
    this.config = config;
  }

  createLogEvent(logger, level, message, optionalParams) {
    return new DefaultLogEvent(level, message, optionalParams, logger.scope, this.config.colorOptions, Date.now());
  }

};
exports.DefaultLogEventFactory = DefaultLogEventFactory;
exports.DefaultLogEventFactory = DefaultLogEventFactory = __decorate([__param(0, ILogConfig)], DefaultLogEventFactory);

class ConsoleSink {
  constructor($console) {
    this.handleEvent = function emit(event) {
      const optionalParams = event.optionalParams;

      if (optionalParams === void 0 || optionalParams.length === 0) {
        switch (event.severity) {
          case 0
          /* trace */
          :
          case 1
          /* debug */
          :
            return $console.debug(event.toString());

          case 2
          /* info */
          :
            return $console.info(event.toString());

          case 3
          /* warn */
          :
            return $console.warn(event.toString());

          case 4
          /* error */
          :
          case 5
          /* fatal */
          :
            return $console.error(event.toString());
        }
      } else {
        switch (event.severity) {
          case 0
          /* trace */
          :
          case 1
          /* debug */
          :
            return $console.debug(event.toString(), ...optionalParams);

          case 2
          /* info */
          :
            return $console.info(event.toString(), ...optionalParams);

          case 3
          /* warn */
          :
            return $console.warn(event.toString(), ...optionalParams);

          case 4
          /* error */
          :
          case 5
          /* fatal */
          :
            return $console.error(event.toString(), ...optionalParams);
        }
      }
    };
  }

}

exports.ConsoleSink = ConsoleSink;
let DefaultLogger = class DefaultLogger {
  constructor(
  /**
   * The global logger configuration.
   */
  config, factory, sinks,
  /**
   * The scopes that this logger was created for, if any.
   */
  scope = [], parent = null) {
    this.config = config;
    this.factory = factory;
    this.scope = scope;
    this.scopedLoggers = Object.create(null);
    let traceSinks;
    let debugSinks;
    let infoSinks;
    let warnSinks;
    let errorSinks;
    let fatalSinks;

    if (parent === null) {
      this.root = this;
      this.parent = this;
      traceSinks = this.traceSinks = [];
      debugSinks = this.debugSinks = [];
      infoSinks = this.infoSinks = [];
      warnSinks = this.warnSinks = [];
      errorSinks = this.errorSinks = [];
      fatalSinks = this.fatalSinks = [];

      for (const $sink of sinks) {
        const handles = LoggerSink.getHandles($sink);

        if (handles?.includes(0
        /* trace */
        ) ?? true) {
          traceSinks.push($sink);
        }

        if (handles?.includes(1
        /* debug */
        ) ?? true) {
          debugSinks.push($sink);
        }

        if (handles?.includes(2
        /* info */
        ) ?? true) {
          infoSinks.push($sink);
        }

        if (handles?.includes(3
        /* warn */
        ) ?? true) {
          warnSinks.push($sink);
        }

        if (handles?.includes(4
        /* error */
        ) ?? true) {
          errorSinks.push($sink);
        }

        if (handles?.includes(5
        /* fatal */
        ) ?? true) {
          fatalSinks.push($sink);
        }
      }
    } else {
      this.root = parent.root;
      this.parent = parent;
      traceSinks = this.traceSinks = parent.traceSinks;
      debugSinks = this.debugSinks = parent.debugSinks;
      infoSinks = this.infoSinks = parent.infoSinks;
      warnSinks = this.warnSinks = parent.warnSinks;
      errorSinks = this.errorSinks = parent.errorSinks;
      fatalSinks = this.fatalSinks = parent.fatalSinks;
    }
  }

  trace(messageOrGetMessage, ...optionalParams) {
    if (this.config.level <= 0
    /* trace */
    ) {
        this.emit(this.traceSinks, 0
        /* trace */
        , messageOrGetMessage, optionalParams);
      }
  }

  debug(messageOrGetMessage, ...optionalParams) {
    if (this.config.level <= 1
    /* debug */
    ) {
        this.emit(this.debugSinks, 1
        /* debug */
        , messageOrGetMessage, optionalParams);
      }
  }

  info(messageOrGetMessage, ...optionalParams) {
    if (this.config.level <= 2
    /* info */
    ) {
        this.emit(this.infoSinks, 2
        /* info */
        , messageOrGetMessage, optionalParams);
      }
  }

  warn(messageOrGetMessage, ...optionalParams) {
    if (this.config.level <= 3
    /* warn */
    ) {
        this.emit(this.warnSinks, 3
        /* warn */
        , messageOrGetMessage, optionalParams);
      }
  }

  error(messageOrGetMessage, ...optionalParams) {
    if (this.config.level <= 4
    /* error */
    ) {
        this.emit(this.errorSinks, 4
        /* error */
        , messageOrGetMessage, optionalParams);
      }
  }

  fatal(messageOrGetMessage, ...optionalParams) {
    if (this.config.level <= 5
    /* fatal */
    ) {
        this.emit(this.fatalSinks, 5
        /* fatal */
        , messageOrGetMessage, optionalParams);
      }
  }
  /**
   * Create a new logger with an additional permanent prefix added to the logging outputs.
   * When chained, multiple scopes are separated by a dot.
   *
   * This is preliminary API and subject to change before alpha release.
   *
   * @example
   *
   * ```ts
   * export class MyComponent {
   *   constructor(@ILogger private logger: ILogger) {
   *     this.logger.debug('before scoping');
   *     // console output: '[DBG] before scoping'
   *     this.logger = logger.scopeTo('MyComponent');
   *     this.logger.debug('after scoping');
   *     // console output: '[DBG MyComponent] after scoping'
   *   }
   *
   *   public doStuff(): void {
   *     const logger = this.logger.scopeTo('doStuff()');
   *     logger.debug('doing stuff');
   *     // console output: '[DBG MyComponent.doStuff()] doing stuff'
   *   }
   * }
   * ```
   */


  scopeTo(name) {
    const scopedLoggers = this.scopedLoggers;
    let scopedLogger = scopedLoggers[name];

    if (scopedLogger === void 0) {
      scopedLogger = scopedLoggers[name] = new DefaultLogger(this.config, this.factory, void 0, this.scope.concat(name), this);
    }

    return scopedLogger;
  }

  emit(sinks, level, msgOrGetMsg, optionalParams) {
    const message = typeof msgOrGetMsg === 'function' ? msgOrGetMsg() : msgOrGetMsg;
    const event = this.factory.createLogEvent(this, level, message, optionalParams);

    for (let i = 0, ii = sinks.length; i < ii; ++i) {
      sinks[i].handleEvent(event);
    }
  }

};
exports.DefaultLogger = DefaultLogger;

__decorate([_functions.bound], DefaultLogger.prototype, "trace", null);

__decorate([_functions.bound], DefaultLogger.prototype, "debug", null);

__decorate([_functions.bound], DefaultLogger.prototype, "info", null);

__decorate([_functions.bound], DefaultLogger.prototype, "warn", null);

__decorate([_functions.bound], DefaultLogger.prototype, "error", null);

__decorate([_functions.bound], DefaultLogger.prototype, "fatal", null);

exports.DefaultLogger = DefaultLogger = __decorate([__param(0, ILogConfig), __param(1, ILogEventFactory), __param(2, (0, _di.all)(ISink)), __param(3, (0, _di.optional)(ILogScopes)), __param(4, _di.ignore)], DefaultLogger);

/**
 * A basic `ILogger` configuration that configures a single `console` sink based on provided options.
 *
 * NOTE: You *must* register the return value of `.create` with the container / au instance, not this `LoggerConfiguration` object itself.
 *
 * @example
 * ```ts
 * container.register(LoggerConfiguration.create());
 *
 * container.register(LoggerConfiguration.create({$console: console}))
 *
 * container.register(LoggerConfiguration.create({$console: console, level: LogLevel.debug}))
 *
 * container.register(LoggerConfiguration.create({
 *  $console: {
 *     debug: noop,
 *     info: noop,
 *     warn: noop,
 *     error: msg => {
 *       throw new Error(msg);
 *     }
 *  },
 *  level: LogLevel.debug
 * }))
 *
 * ```
 */
const LoggerConfiguration = (0, _functions.toLookup)({
  /**
   * @param $console - The `console` object to use. Can be the native `window.console` / `global.console`, but can also be a wrapper or mock that implements the same interface.
   * @param level - The global `LogLevel` to configure. Defaults to `warn` or higher.
   * @param colorOptions - Whether to use colors or not. Defaults to `noColors`. Colors are especially nice in nodejs environments but don't necessarily work (well) in all environments, such as browsers.
   */
  create({
    $console,
    level = 3
    /* warn */
    ,
    colorOptions = 0
    /* noColors */
    ,
    sinks = []
  } = {}) {
    return (0, _functions.toLookup)({
      register(container) {
        container.register(_di.Registration.instance(ILogConfig, new LogConfig(colorOptions, level)));

        if ($console !== void 0 && $console !== null) {
          container.register(_di.Registration.instance(ISink, new ConsoleSink($console)));
        }

        for (const $sink of sinks) {
          container.register(_di.Registration.singleton(ISink, $sink));
        }

        return container;
      }

    });
  }

});
exports.LoggerConfiguration = LoggerConfiguration;
});

;define.alias('@aurelia/kernel/logger.js','@aurelia/kernel/dist/esm/logger.js');
define('@aurelia/kernel/dist/esm/module-loader.js',['require','exports','module','./di.js','./platform.js','./resource.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.ModuleItem = exports.AnalyzedModule = exports.ModuleLoader = exports.IModuleLoader = void 0;

var _di = require("./di.js");

var _platform = require("./platform.js");

var _resource = require("./resource.js");

const IModuleLoader = _di.DI.createInterface(x => x.singleton(ModuleLoader));

exports.IModuleLoader = IModuleLoader;

function noTransform(m) {
  return m;
}

class ModuleTransformer {
  constructor($transform) {
    this.$transform = $transform;
    this.promiseCache = new Map();
    this.objectCache = new Map();
  }

  transform(objOrPromise) {
    if (objOrPromise instanceof Promise) {
      return this.transformPromise(objOrPromise);
    } else if (typeof objOrPromise === 'object' && objOrPromise !== null) {
      return this.transformObject(objOrPromise);
    } else {
      throw new Error(`Invalid input: ${String(objOrPromise)}. Expected Promise or Object.`);
    }
  }

  transformPromise(promise) {
    if (this.promiseCache.has(promise)) {
      return this.promiseCache.get(promise);
    }

    const ret = promise.then(obj => {
      return this.transformObject(obj);
    });
    this.promiseCache.set(promise, ret);
    void ret.then(value => {
      // make it synchronous for future requests
      this.promiseCache.set(promise, value);
    });
    return ret;
  }

  transformObject(obj) {
    if (this.objectCache.has(obj)) {
      return this.objectCache.get(obj);
    }

    const ret = this.$transform(this.analyze(obj));
    this.objectCache.set(obj, ret);

    if (ret instanceof Promise) {
      void ret.then(value => {
        // make it synchronous for future requests
        this.objectCache.set(obj, value);
      });
    }

    return ret;
  }

  analyze(m) {
    let value;
    let isRegistry;
    let isConstructable;
    let definitions;
    const items = [];

    for (const key in m) {
      switch (typeof (value = m[key])) {
        case 'object':
          if (value === null) {
            continue;
          }

          isRegistry = typeof value.register === 'function';
          isConstructable = false;
          definitions = _platform.emptyArray;
          break;

        case 'function':
          isRegistry = typeof value.register === 'function';
          isConstructable = value.prototype !== void 0;
          definitions = _resource.Protocol.resource.getAll(value);
          break;

        default:
          continue;
      }

      items.push(new ModuleItem(key, value, isRegistry, isConstructable, definitions));
    }

    return new AnalyzedModule(m, items);
  }

}

class ModuleLoader {
  constructor() {
    this.transformers = new Map();
  }

  load(objOrPromise, transform = noTransform) {
    const transformers = this.transformers;
    let transformer = transformers.get(transform);

    if (transformer === void 0) {
      transformers.set(transform, transformer = new ModuleTransformer(transform));
    }

    return transformer.transform(objOrPromise);
  }

  dispose() {
    this.transformers.clear();
  }

}

exports.ModuleLoader = ModuleLoader;

class AnalyzedModule {
  constructor(raw, items) {
    this.raw = raw;
    this.items = items;
  }

}

exports.AnalyzedModule = AnalyzedModule;

class ModuleItem {
  constructor(key, value, isRegistry, isConstructable, definitions) {
    this.key = key;
    this.value = value;
    this.isRegistry = isRegistry;
    this.isConstructable = isConstructable;
    this.definitions = definitions;
  }

}

exports.ModuleItem = ModuleItem;
});

;define.alias('@aurelia/kernel/module-loader.js','@aurelia/kernel/dist/esm/module-loader.js');
define('@aurelia/kernel/dist/esm/platform.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.noop = noop;
exports.emptyObject = exports.emptyArray = void 0;

/* eslint-disable @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any */
const emptyArray = Object.freeze([]);
exports.emptyArray = emptyArray;
const emptyObject = Object.freeze({});
/* eslint-enable @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any */
// eslint-disable-next-line @typescript-eslint/no-empty-function

exports.emptyObject = emptyObject;

function noop() {}
});

;define.alias('@aurelia/kernel/platform.js','@aurelia/kernel/dist/esm/platform.js');
define('@aurelia/kernel/dist/esm/resource.js',['require','exports','module','@aurelia/metadata','./platform.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.fromAnnotationOrDefinitionOrTypeOrDefault = fromAnnotationOrDefinitionOrTypeOrDefault;
exports.fromAnnotationOrTypeOrDefault = fromAnnotationOrTypeOrDefault;
exports.fromDefinitionOrDefault = fromDefinitionOrDefault;
exports.Protocol = void 0;

var _metadata = require("@aurelia/metadata");

var _platform = require("./platform.js");

const annotation = {
  name: 'au:annotation',

  appendTo(target, key) {
    const keys = _metadata.Metadata.getOwn(annotation.name, target);

    if (keys === void 0) {
      _metadata.Metadata.define(annotation.name, [key], target);
    } else {
      keys.push(key);
    }
  },

  set(target, prop, value) {
    _metadata.Metadata.define(annotation.keyFor(prop), value, target);
  },

  get(target, prop) {
    return _metadata.Metadata.getOwn(annotation.keyFor(prop), target);
  },

  getKeys(target) {
    let keys = _metadata.Metadata.getOwn(annotation.name, target);

    if (keys === void 0) {
      _metadata.Metadata.define(annotation.name, keys = [], target);
    }

    return keys;
  },

  isKey(key) {
    return key.startsWith(annotation.name);
  },

  keyFor(name, context) {
    if (context === void 0) {
      return `${annotation.name}:${name}`;
    }

    return `${annotation.name}:${name}:${context}`;
  }

};
const resource = {
  name: 'au:resource',

  appendTo(target, key) {
    const keys = _metadata.Metadata.getOwn(resource.name, target);

    if (keys === void 0) {
      _metadata.Metadata.define(resource.name, [key], target);
    } else {
      keys.push(key);
    }
  },

  has(target) {
    return _metadata.Metadata.hasOwn(resource.name, target);
  },

  getAll(target) {
    const keys = _metadata.Metadata.getOwn(resource.name, target);

    if (keys === void 0) {
      return _platform.emptyArray;
    } else {
      return keys.map(k => _metadata.Metadata.getOwn(k, target));
    }
  },

  getKeys(target) {
    let keys = _metadata.Metadata.getOwn(resource.name, target);

    if (keys === void 0) {
      _metadata.Metadata.define(resource.name, keys = [], target);
    }

    return keys;
  },

  isKey(key) {
    return key.startsWith(resource.name);
  },

  keyFor(name, context) {
    if (context === void 0) {
      return `${resource.name}:${name}`;
    }

    return `${resource.name}:${name}:${context}`;
  }

};
const Protocol = {
  annotation,
  resource
};
exports.Protocol = Protocol;
const hasOwn = Object.prototype.hasOwnProperty;
/**
 * The order in which the values are checked:
 * 1. Annotations (usually set by decorators) have the highest priority; they override the definition as well as static properties on the type.
 * 2. Definition properties (usually set by the customElement decorator object literal) come next. They override static properties on the type.
 * 3. Static properties on the type come last. Note that this does not look up the prototype chain (bindables are an exception here, but we do that differently anyway)
 * 4. The default property that is provided last. The function is only called if the default property is needed
 */

function fromAnnotationOrDefinitionOrTypeOrDefault(name, def, Type, getDefault) {
  let value = _metadata.Metadata.getOwn(Protocol.annotation.keyFor(name), Type);

  if (value === void 0) {
    value = def[name];

    if (value === void 0) {
      value = Type[name];

      if (value === void 0 || !hasOwn.call(Type, name)) {
        // First just check the value (common case is faster), but do make sure it doesn't come from the proto chain
        return getDefault();
      }

      return value;
    }

    return value;
  }

  return value;
}
/**
 * The order in which the values are checked:
 * 1. Annotations (usually set by decorators) have the highest priority; they override static properties on the type.
 * 2. Static properties on the typ. Note that this does not look up the prototype chain (bindables are an exception here, but we do that differently anyway)
 * 3. The default property that is provided last. The function is only called if the default property is needed
 */


function fromAnnotationOrTypeOrDefault(name, Type, getDefault) {
  let value = _metadata.Metadata.getOwn(Protocol.annotation.keyFor(name), Type);

  if (value === void 0) {
    value = Type[name];

    if (value === void 0 || !hasOwn.call(Type, name)) {
      // First just check the value (common case is faster), but do make sure it doesn't come from the proto chain
      return getDefault();
    }

    return value;
  }

  return value;
}
/**
 * The order in which the values are checked:
 * 1. Definition properties.
 * 2. The default property that is provided last. The function is only called if the default property is needed
 */


function fromDefinitionOrDefault(name, def, getDefault) {
  const value = def[name];

  if (value === void 0) {
    return getDefault();
  }

  return value;
}
});

;define.alias('@aurelia/kernel/resource.js','@aurelia/kernel/dist/esm/resource.js');
define('@aurelia/metadata/dist/esm/index.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.isObject = isObject;
exports.isNullOrUndefined = isNullOrUndefined;
exports.metadata = metadata;
exports.applyMetadataPolyfill = applyMetadataPolyfill;
exports.Metadata = void 0;

/**
 * Determine whether a value is an object.
 *
 * Uses `typeof` to guarantee this works cross-realm, which is where `instanceof Object` might fail.
 *
 * Some environments where these issues are known to arise:
 * - same-origin iframes (accessing the other realm via `window.top`)
 * - `jest`.
 *
 * The exact test is:
 * ```ts
 * typeof value === 'object' && value !== null || typeof value === 'function'
 * ```
 *
 * @param value - The value to test.
 * @returns `true` if the value is an object, otherwise `false`.
 * Also performs a type assertion that defaults to `value is Object | Function` which, if the input type is a union with an object type, will infer the correct type.
 * This can be overridden with the generic type argument.
 *
 * @example
 *
 * ```ts
 * class Foo {
 *   bar = 42;
 * }
 *
 * function doStuff(input?: Foo | null) {
 *   input.bar; // Object is possibly 'null' or 'undefined'
 *
 *   // input has an object type in its union (Foo) so that type will be extracted for the 'true' condition
 *   if (isObject(input)) {
 *     input.bar; // OK (input is now typed as Foo)
 *   }
 * }
 *
 * function doOtherStuff(input: unknown) {
 *   input.bar; // Object is of type 'unknown'
 *
 *   // input is 'unknown' so there is no union type to match and it will default to 'Object | Function'
 *   if (isObject(input)) {
 *     input.bar; // Property 'bar' does not exist on type 'Object | Function'
 *   }
 *
 *   // if we know for sure that, if input is an object, it must be a specific type, we can explicitly tell the function to assert that for us
 *   if (isObject<Foo>(input)) {
 *    input.bar; // OK (input is now typed as Foo)
 *   }
 * }
 * ```
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function isObject(value) {
  return typeof value === 'object' && value !== null || typeof value === 'function';
}
/**
 * Determine whether a value is `null` or `undefined`.
 *
 * @param value - The value to test.
 * @returns `true` if the value is `null` or `undefined`, otherwise `false`.
 * Also performs a type assertion that ensures TypeScript treats the value appropriately in the `if` and `else` branches after this check.
 */


function isNullOrUndefined(value) {
  return value === null || value === void 0;
}
/* eslint-disable @typescript-eslint/no-explicit-any */

/* eslint-disable @typescript-eslint/ban-types */


const metadataInternalSlot = new WeakMap();

function $typeError(operation, args, paramName, actualValue, expectedType) {
  return new TypeError(`${operation}(${args.map(String).join(',')}) - Expected '${paramName}' to be of type ${expectedType}, but got: ${Object.prototype.toString.call(actualValue)} (${String(actualValue)})`);
}

function toPropertyKeyOrUndefined(propertyKey) {
  switch (typeof propertyKey) {
    case 'undefined':
    case 'string':
    case 'symbol':
      return propertyKey;

    default:
      return `${propertyKey}`;
  }
}

function toPropertyKey(propertyKey) {
  switch (typeof propertyKey) {
    case 'string':
    case 'symbol':
      return propertyKey;

    default:
      return `${propertyKey}`;
  }
}

function ensurePropertyKeyOrUndefined(propertyKey) {
  switch (typeof propertyKey) {
    case 'undefined':
    case 'string':
    case 'symbol':
      return propertyKey;

    default:
      throw new TypeError(`Invalid metadata propertyKey: ${propertyKey}.`);
  }
}

function GetOrCreateMetadataMap(O, P, Create) {
  // 1. Assert: P is undefined or IsPropertyKey(P) is true.
  // 2. Let targetMetadata be the value of O's [[Metadata]] internal slot.
  let targetMetadata = metadataInternalSlot.get(O); // 3. If targetMetadata is undefined, then

  if (targetMetadata === void 0) {
    // 3. a. If Create is false, return undefined.
    if (!Create) {
      return void 0;
    } // 3. b. Set targetMetadata to be a newly created Map object.


    targetMetadata = new Map(); // 3. c. Set the [[Metadata]] internal slot of O to targetMetadata.

    metadataInternalSlot.set(O, targetMetadata);
  } // 4. Let metadataMap be ? Invoke(targetMetadata, "get", P).


  let metadataMap = targetMetadata.get(P); // 5. If metadataMap is undefined, then

  if (metadataMap === void 0) {
    // 5. a. If Create is false, return undefined.
    if (!Create) {
      return void 0;
    } // 5. b. Set metadataMap to be a newly created Map object.


    metadataMap = new Map(); // 5. c. Perform ? Invoke(targetMetadata, "set", P, metadataMap).

    targetMetadata.set(P, metadataMap);
  } // 6. Return metadataMap.


  return metadataMap;
} // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
// https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata


function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
  // 1. Assert: P is undefined or IsPropertyKey(P) is true.
  // 2. Let metadataMap be ? GetOrCreateMetadataMap(O, P, false).
  const metadataMap = GetOrCreateMetadataMap(O, P,
  /* Create */
  false); // 3. If metadataMap is undefined, return false.

  if (metadataMap === void 0) {
    return false;
  } // 4. Return ? ToBoolean(? Invoke(metadataMap, "has", MetadataKey)).


  return metadataMap.has(MetadataKey);
} // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
// https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata


function OrdinaryHasMetadata(MetadataKey, O, P) {
  // 1. Assert: P is undefined or IsPropertyKey(P) is true.
  // 2. Let hasOwn be ? OrdinaryHasOwnMetadata(MetadataKey, O, P).
  // 3. If hasOwn is true, return true.
  if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) {
    return true;
  } // 4. Let parent be ? O.[[GetPrototypeOf]]().


  const parent = Object.getPrototypeOf(O); // 5. If parent is not null, Return ? parent.[[HasMetadata]](MetadataKey, P).

  if (parent !== null) {
    return OrdinaryHasMetadata(MetadataKey, parent, P);
  } // 6. Return false.


  return false;
} // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
// https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata


function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
  // 1. Assert: P is undefined or IsPropertyKey(P) is true.
  // 2. Let metadataMap be ? GetOrCreateMetadataMap(O, P, false).
  const metadataMap = GetOrCreateMetadataMap(O, P,
  /* Create */
  false); // 3. If metadataMap is undefined, return undefined.

  if (metadataMap === void 0) {
    return void 0;
  } // 4. Return ? Invoke(metadataMap, "get", MetadataKey).


  return metadataMap.get(MetadataKey);
} // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
// https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata


function OrdinaryGetMetadata(MetadataKey, O, P) {
  // 1. Assert: P is undefined or IsPropertyKey(P) is true.
  // 2. Let hasOwn be ? OrdinaryHasOwnMetadata(MetadataKey, O, P).
  // 3. If hasOwn is true, return ? OrdinaryGetOwnMetadata(MetadataKey, O, P).
  if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) {
    return OrdinaryGetOwnMetadata(MetadataKey, O, P);
  } // 4. Let parent be ? O.[[GetPrototypeOf]]().


  const parent = Object.getPrototypeOf(O); // 5. If parent is not null, return ? parent.[[GetMetadata]](MetadataKey, P).

  if (parent !== null) {
    return OrdinaryGetMetadata(MetadataKey, parent, P);
  } // 6. Return undefined.


  return void 0;
} // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
// https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata


function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
  // 1. Assert: P is undefined or IsPropertyKey(P) is true.
  // 2. Let metadataMap be ? GetOrCreateMetadataMap(O, P, true).
  const metadataMap = GetOrCreateMetadataMap(O, P,
  /* Create */
  true); // 3. Return ? Invoke(metadataMap, "set", MetadataKey, MetadataValue).

  metadataMap.set(MetadataKey, MetadataValue);
} // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
// https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys


function OrdinaryOwnMetadataKeys(O, P) {
  // 1. Assert: P is undefined or IsPropertyKey(P) is true.
  // 2. Let keys be ? ArrayCreate(0).
  const keys = []; // 3. Let metadataMap be ? GetOrCreateMetadataMap(O, P, false).

  const metadataMap = GetOrCreateMetadataMap(O, P,
  /* Create */
  false); // 4. If metadataMap is undefined, return keys.

  if (metadataMap === void 0) {
    return keys;
  } // 5. Let keysObj be ? Invoke(metadataMap, "keys").


  const keysObj = metadataMap.keys(); // 6. Let iterator be ? GetIterator(keysObj).
  // 7. Let k be 0.

  let k = 0; // 8. Repeat

  for (const key of keysObj) {
    // 8. a. Let Pk be ! ToString(k).
    // 8. b. Let next be ? IteratorStep(iterator).
    // 8. c. If next is false, then
    // 8. c. i. Let setStatus be ? Set(keys, "length", k, true).
    // 8. c. ii. Assert: setStatus is true.
    // 8. c. iii. Return keys.
    // 8. d. Let nextValue be ? IteratorValue(next).
    // 8. e. Let defineStatus be CreateDataPropertyOrThrow(keys, Pk, nextValue).
    keys[k] = key; // 8. f. If defineStatus is an abrupt completion, return ? IteratorClose(iterator, defineStatus).
    // 8. g. Increase k by 1.

    ++k;
  }

  return keys;
} // 3.1.6.1 OrdinaryMetadataKeys(O, P)
// https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys


function OrdinaryMetadataKeys(O, P) {
  // 1. Assert: P is undefined or IsPropertyKey(P) is true.
  // 2. Let ownKeys be ? OrdinaryOwnMetadataKeys(O, P).
  const ownKeys = OrdinaryOwnMetadataKeys(O, P); // 3. Let parent be ? O.[[GetPrototypeOf]]().

  const parent = Object.getPrototypeOf(O); // 4. If parent is null, then return ownKeys.

  if (parent === null) {
    return ownKeys;
  } // 5. Let parentKeys be ? O.[[OrdinaryMetadataKeys]](P).


  const parentKeys = OrdinaryMetadataKeys(parent, P); // 6. Let ownKeysLen = ? Get(ownKeys, "length").

  const ownKeysLen = ownKeys.length; // 7. If ownKeysLen is 0, return parentKeys.

  if (ownKeysLen === 0) {
    return parentKeys;
  } // 8. Let parentKeysLen = ? Get(parentKeys, "length").


  const parentKeysLen = parentKeys.length; // 9. If parentKeysLen is 0, return ownKeys.

  if (parentKeysLen === 0) {
    return ownKeys;
  } // 10. Let set be a newly created Set object.


  const set = new Set(); // 11. Let keys be ? ArrayCreate(0).

  const keys = []; // 12. Let k be 0.

  let k = 0; // 13. For each element key of ownKeys

  let key;

  for (let i = 0; i < ownKeysLen; ++i) {
    key = ownKeys[i]; // 13. a. Let hasKey be ? Invoke(set, "has", key).
    // 13. b. If hasKey is false, then

    if (!set.has(key)) {
      // 13. b. i. Let Pk be ! ToString(k).
      // 13. b. ii. Perform ? Invoke(set, "add", key).
      set.add(key); // 13. b. iii. Let defineStatus be CreateDataProperty(keys, Pk, key).
      // 13. b. iv. Assert: defineStatus is true.

      keys[k] = key; // 13. b. v. Increase k by 1.

      ++k;
    }
  } // 14. For each element key of parentKeys


  for (let i = 0; i < parentKeysLen; ++i) {
    key = parentKeys[i]; // 14. a. Let hasKey be ? Invoke(set, "has", key).
    // 14. b. If hasKey is false, then

    if (!set.has(key)) {
      // 14. b. i. Let Pk be ! ToString(k).
      // 14. b. ii. Perform ? Invoke(set, "add", key).
      set.add(key); // 14. b. iii. Let defineStatus be CreateDataProperty(keys, Pk, key).
      // 14. b. iv. Assert: defineStatus is true.

      keys[k] = key; // 14. b. v. Increase k by 1.

      ++k;
    }
  } // 15. Perform ? Set(keys, "length", k).
  // 16. return keys.


  return keys;
} // 3.1.8 DeleteMetadata(MetadataKey, P)
// https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots-deletemetadata


function OrdinaryDeleteMetadata(O, MetadataKey, P) {
  // 1. Assert: P is undefined or IsPropertyKey(P) is true.
  // 2. Let metadataMap be ? GetOrCreateMetadataMap(O, P, false).
  const metadataMap = GetOrCreateMetadataMap(O, P, false); // 3. If metadataMap is undefined, return false.

  if (metadataMap === void 0) {
    return false;
  } // 4. Return ? Invoke(metadataMap, "delete", MetadataKey).


  return metadataMap.delete(MetadataKey);
} // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
// https://rbuckton.github.io/reflect-metadata/#reflect.metadata

/**
 * A default metadata decorator factory that can be used on a class, class member, or parameter.
 *
 * @param metadataKey - The key for the metadata entry.
 * If `metadataKey` is already defined for the target and target key, the
 * metadataValue for that key will be overwritten.
 * @param metadataValue - The value for the metadata entry.
 * @returns A decorator function.
 */


function metadata(metadataKey, metadataValue) {
  function decorator(target, propertyKey) {
    // 1. Assert: F has a [[MetadataKey]] internal slot whose value is an ECMAScript language value, or undefined.
    // 2. Assert: F has a [[MetadataValue]] internal slot whose value is an ECMAScript language value, or undefined.
    // 3. If Type(target) is not Object, throw a TypeError exception.
    if (!isObject(target)) {
      throw $typeError('@metadata', [metadataKey, metadataValue, target, propertyKey], 'target', target, 'Object or Function');
    } // 4. If key is not undefined and IsPropertyKey(key) is false, throw a TypeError exception.
    // 5. Let metadataKey be the value of F's [[MetadataKey]] internal slot.
    // 6. Let metadataValue be the value of F's [[MetadataValue]] internal slot.
    // 7. Perform ? target.[[DefineMetadata]](metadataKey, metadataValue, target, key).


    OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, ensurePropertyKeyOrUndefined(propertyKey)); // 8. Return undefined.
  }

  return decorator;
}

function decorate(decorators, target, propertyKey, attributes) {
  if (propertyKey !== void 0) {
    if (!Array.isArray(decorators)) {
      throw $typeError('Metadata.decorate', [decorators, target, propertyKey, attributes], 'decorators', decorators, 'Array');
    }

    if (!isObject(target)) {
      throw $typeError('Metadata.decorate', [decorators, target, propertyKey, attributes], 'target', target, 'Object or Function');
    }

    if (!isObject(attributes) && !isNullOrUndefined(attributes)) {
      throw $typeError('Metadata.decorate', [decorators, target, propertyKey, attributes], 'attributes', attributes, 'Object, Function, null, or undefined');
    }

    if (attributes === null) {
      attributes = void 0;
    }

    propertyKey = toPropertyKey(propertyKey);
    return DecorateProperty(decorators, target, propertyKey, attributes);
  } else {
    if (!Array.isArray(decorators)) {
      throw $typeError('Metadata.decorate', [decorators, target, propertyKey, attributes], 'decorators', decorators, 'Array');
    }

    if (typeof target !== 'function') {
      throw $typeError('Metadata.decorate', [decorators, target, propertyKey, attributes], 'target', target, 'Function');
    }

    return DecorateConstructor(decorators, target);
  }
}

function DecorateConstructor(decorators, target) {
  for (let i = decorators.length - 1; i >= 0; --i) {
    const decorator = decorators[i];
    const decorated = decorator(target);

    if (!isNullOrUndefined(decorated)) {
      if (typeof decorated !== 'function') {
        throw $typeError('DecorateConstructor', [decorators, target], 'decorated', decorated, 'Function, null, or undefined');
      }

      target = decorated;
    }
  }

  return target;
}

function DecorateProperty(decorators, target, propertyKey, descriptor) {
  for (let i = decorators.length - 1; i >= 0; --i) {
    const decorator = decorators[i];
    const decorated = decorator(target, propertyKey, descriptor);

    if (!isNullOrUndefined(decorated)) {
      if (!isObject(decorated)) {
        throw $typeError('DecorateProperty', [decorators, target, propertyKey, descriptor], 'decorated', decorated, 'Object, Function, null, or undefined');
      }

      descriptor = decorated;
    }
  }

  return descriptor;
}

function $define(metadataKey, metadataValue, target, propertyKey) {
  // 1. If Type(target) is not Object, throw a TypeError exception.
  if (!isObject(target)) {
    throw $typeError('Metadata.define', [metadataKey, metadataValue, target, propertyKey], 'target', target, 'Object or Function');
  } // 2. Return ? target.[[DefineMetadata]](metadataKey, metadataValue, propertyKey).


  return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, toPropertyKeyOrUndefined(propertyKey));
}

function $has(metadataKey, target, propertyKey) {
  // 1. If Type(target) is not Object, throw a TypeError exception.
  if (!isObject(target)) {
    throw $typeError('Metadata.has', [metadataKey, target, propertyKey], 'target', target, 'Object or Function');
  } // 2. Return ? target.[[HasMetadata]](metadataKey, propertyKey).


  return OrdinaryHasMetadata(metadataKey, target, toPropertyKeyOrUndefined(propertyKey));
}

function $hasOwn(metadataKey, target, propertyKey) {
  // 1. If Type(target) is not Object, throw a TypeError exception.
  if (!isObject(target)) {
    throw $typeError('Metadata.hasOwn', [metadataKey, target, propertyKey], 'target', target, 'Object or Function');
  } // 2. Return ? target.[[HasOwn]](metadataKey, propertyKey).


  return OrdinaryHasOwnMetadata(metadataKey, target, toPropertyKeyOrUndefined(propertyKey));
}

function $get(metadataKey, target, propertyKey) {
  // 1. If Type(target) is not Object, throw a TypeError exception.
  if (!isObject(target)) {
    throw $typeError('Metadata.get', [metadataKey, target, propertyKey], 'target', target, 'Object or Function');
  } // 2. Return ? target.[[GetMetadata]](metadataKey, propertyKey).


  return OrdinaryGetMetadata(metadataKey, target, toPropertyKeyOrUndefined(propertyKey));
}

function $getOwn(metadataKey, target, propertyKey) {
  // 1. If Type(target) is not Object, throw a TypeError exception.
  if (!isObject(target)) {
    throw $typeError('Metadata.getOwn', [metadataKey, target, propertyKey], 'target', target, 'Object or Function');
  } // 2. Return ? target.[[GetOwnMetadata]](metadataKey, propertyKey).


  return OrdinaryGetOwnMetadata(metadataKey, target, toPropertyKeyOrUndefined(propertyKey));
}

function $getKeys(target, propertyKey) {
  // 1. If Type(target) is not Object, throw a TypeError exception.
  if (!isObject(target)) {
    throw $typeError('Metadata.getKeys', [target, propertyKey], 'target', target, 'Object or Function');
  } // 2. Return ? target.[[GetMetadataKeys]](propertyKey).


  return OrdinaryMetadataKeys(target, toPropertyKeyOrUndefined(propertyKey));
}

function $getOwnKeys(target, propertyKey) {
  // 1. If Type(target) is not Object, throw a TypeError exception.
  if (!isObject(target)) {
    throw $typeError('Metadata.getOwnKeys', [target, propertyKey], 'target', target, 'Object or Function');
  } // 2. Return ? target.[[GetOwnMetadataKeys]](propertyKey).


  return OrdinaryOwnMetadataKeys(target, toPropertyKeyOrUndefined(propertyKey));
}

function $delete(metadataKey, target, propertyKey) {
  // 1. If Type(target) is not Object, throw a TypeError exception.
  if (!isObject(target)) {
    throw $typeError('Metadata.delete', [metadataKey, target, propertyKey], 'target', target, 'Object or Function');
  } // 2. Return ? target.[[DeleteMetadata]](metadataKey, propertyKey).


  return OrdinaryDeleteMetadata(target, metadataKey, toPropertyKeyOrUndefined(propertyKey));
}

const Metadata = {
  define: $define,
  has: $has,
  hasOwn: $hasOwn,
  get: $get,
  getOwn: $getOwn,
  getKeys: $getKeys,
  getOwnKeys: $getOwnKeys,
  delete: $delete
};
exports.Metadata = Metadata;

function def(obj, key, value, writable, configurable) {
  if (!Reflect.defineProperty(obj, key, {
    writable,
    enumerable: false,
    configurable,
    value
  })) {
    throw new Error(`Unable to apply metadata polyfill: could not add property '${key}' to the global Reflect object`);
  }
}

const internalSlotName = '[[$au]]';

function hasInternalSlot(reflect) {
  return internalSlotName in reflect;
}

function $applyMetadataPolyfill(reflect, writable, configurable) {
  def(reflect, internalSlotName, metadataInternalSlot, writable, configurable);
  def(reflect, 'metadata', metadata, writable, configurable);
  def(reflect, 'decorate', decorate, writable, configurable);
  def(reflect, 'defineMetadata', $define, writable, configurable);
  def(reflect, 'hasMetadata', $has, writable, configurable);
  def(reflect, 'hasOwnMetadata', $hasOwn, writable, configurable);
  def(reflect, 'getMetadata', $get, writable, configurable);
  def(reflect, 'getOwnMetadata', $getOwn, writable, configurable);
  def(reflect, 'getMetadataKeys', $getKeys, writable, configurable);
  def(reflect, 'getOwnMetadataKeys', $getOwnKeys, writable, configurable);
  def(reflect, 'deleteMetadata', $delete, writable, configurable);
}

function applyMetadataPolyfill(reflect, throwIfConflict = true, forceOverwrite = false, writable = true, configurable = true) {
  if (hasInternalSlot(reflect)) {
    if (reflect[internalSlotName] === metadataInternalSlot) {
      return;
    }

    throw new Error(`Conflicting @aurelia/metadata module import detected. Please make sure you have the same version of all Aurelia packages in your dependency tree.`);
  }

  const presentProps = ['metadata', 'decorate', 'defineMetadata', 'hasMetadata', 'hasOwnMetadata', 'getMetadata', 'getOwnMetadata', 'getMetadataKeys', 'getOwnMetadataKeys', 'deleteMetadata'].filter(function (p) {
    return p in Reflect;
  });

  if (presentProps.length > 0) {
    if (throwIfConflict) {
      const implementationSummary = presentProps.map(function (p) {
        const impl = `${Reflect[p].toString().slice(0, 100)}...`;
        return `${p}:\n${impl}`;
      }).join('\n\n');
      throw new Error(`Conflicting reflect.metadata polyfill found. If you have 'reflect-metadata' or any other reflect polyfill imported, please remove it, if not (or if you must use a specific polyfill) please file an issue at https://github.com/aurelia/aurelia/issues so that we can look into compatibility options for this scenario. Implementation summary:\n\n${implementationSummary}`);
    } else if (forceOverwrite) {
      $applyMetadataPolyfill(reflect, writable, configurable);
    }
  } else {
    $applyMetadataPolyfill(reflect, writable, configurable);
  }
}
});

;define.alias('@aurelia/metadata','@aurelia/metadata/dist/esm/index.js');
define('@aurelia/platform-browser/dist/esm/index.js',['require','exports','module','@aurelia/platform'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.BrowserPlatform = void 0;

var _platform = require("@aurelia/platform");

const lookup = new Map();

function notImplemented(name) {
  return function notImplemented() {
    throw new Error(`The PLATFORM did not receive a valid reference to the global function '${name}'.`); // TODO: link to docs describing how to fix this issue
  };
}

class BrowserPlatform extends _platform.Platform {
  constructor(g, overrides = {}) {
    super(g, overrides);
    this.domReadRequested = false;
    this.domReadHandle = -1;
    this.domWriteRequested = false;
    this.domWriteHandle = -1;
    this.Node = 'Node' in overrides ? overrides.Node : g.Node;
    this.Element = 'Element' in overrides ? overrides.Element : g.Element;
    this.HTMLElement = 'HTMLElement' in overrides ? overrides.HTMLElement : g.HTMLElement;
    this.CustomEvent = 'CustomEvent' in overrides ? overrides.CustomEvent : g.CustomEvent;
    this.CSSStyleSheet = 'CSSStyleSheet' in overrides ? overrides.CSSStyleSheet : g.CSSStyleSheet;
    this.ShadowRoot = 'ShadowRoot' in overrides ? overrides.ShadowRoot : g.ShadowRoot;
    this.MutationObserver = 'MutationObserver' in overrides ? overrides.MutationObserver : g.MutationObserver;
    this.window = 'window' in overrides ? overrides.window : g.window;
    this.document = 'document' in overrides ? overrides.document : g.document;
    this.location = 'location' in overrides ? overrides.location : g.location;
    this.history = 'history' in overrides ? overrides.history : g.history;
    this.navigator = 'navigator' in overrides ? overrides.navigator : g.navigator;
    this.fetch = 'fetch' in overrides ? overrides.fetch : g.fetch?.bind(g) ?? notImplemented('fetch');
    this.requestAnimationFrame = 'requestAnimationFrame' in overrides ? overrides.requestAnimationFrame : g.requestAnimationFrame?.bind(g) ?? notImplemented('requestAnimationFrame');
    this.cancelAnimationFrame = 'cancelAnimationFrame' in overrides ? overrides.cancelAnimationFrame : g.cancelAnimationFrame?.bind(g) ?? notImplemented('cancelAnimationFrame');
    this.customElements = 'customElements' in overrides ? overrides.customElements : g.customElements;
    this.flushDomRead = this.flushDomRead.bind(this);
    this.flushDomWrite = this.flushDomWrite.bind(this);
    this.domReadQueue = new _platform.TaskQueue(this, this.requestDomRead.bind(this), this.cancelDomRead.bind(this));
    this.domWriteQueue = new _platform.TaskQueue(this, this.requestDomWrite.bind(this), this.cancelDomWrite.bind(this));
    /* eslint-enable @typescript-eslint/no-unnecessary-type-assertion */
  }

  static getOrCreate(g, overrides = {}) {
    let platform = lookup.get(g);

    if (platform === void 0) {
      lookup.set(g, platform = new BrowserPlatform(g, overrides));
    }

    return platform;
  }

  static set(g, platform) {
    lookup.set(g, platform);
  }

  requestDomRead() {
    this.domReadRequested = true; // Yes, this is intentional: the timing of the read can only be "found" by doing a write first.
    // The flushDomWrite queues the read.
    // If/when requestPostAnimationFrame is implemented in browsers, we can use that instead.

    if (this.domWriteHandle === -1) {
      this.domWriteHandle = this.requestAnimationFrame(this.flushDomWrite);
    }
  }

  cancelDomRead() {
    this.domReadRequested = false;

    if (this.domReadHandle > -1) {
      this.clearTimeout(this.domReadHandle);
      this.domReadHandle = -1;
    }

    if (this.domWriteRequested === false && this.domWriteHandle > -1) {
      this.cancelAnimationFrame(this.domWriteHandle);
      this.domWriteHandle = -1;
    }
  }

  flushDomRead() {
    this.domReadHandle = -1;

    if (this.domReadRequested === true) {
      this.domReadRequested = false;
      this.domReadQueue.flush();
    }
  }

  requestDomWrite() {
    this.domWriteRequested = true;

    if (this.domWriteHandle === -1) {
      this.domWriteHandle = this.requestAnimationFrame(this.flushDomWrite);
    }
  }

  cancelDomWrite() {
    this.domWriteRequested = false;

    if (this.domWriteHandle > -1 && ( // if dom read is requested and there is no readHandle yet, we need the rAF to proceed regardless.
    // The domWriteRequested=false will prevent the read flush from happening.
    this.domReadRequested === false || this.domReadHandle > -1)) {
      this.cancelAnimationFrame(this.domWriteHandle);
      this.domWriteHandle = -1;
    }
  }

  flushDomWrite() {
    this.domWriteHandle = -1;

    if (this.domWriteRequested === true) {
      this.domWriteRequested = false;
      this.domWriteQueue.flush();
    }

    if (this.domReadRequested === true && this.domReadHandle === -1) {
      this.domReadHandle = this.setTimeout(this.flushDomRead, 0);
    }
  }

}

exports.BrowserPlatform = BrowserPlatform;
});

;define.alias('@aurelia/platform-browser','@aurelia/platform-browser/dist/esm/index.js');
define('@aurelia/platform/dist/esm/index.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.TaskQueuePriority = exports.Task = exports.TaskStatus = exports.TaskAbortError = exports.TaskQueue = exports.Platform = void 0;
const lookup = new Map();

function notImplemented(name) {
  return function notImplemented() {
    throw new Error(`The PLATFORM did not receive a valid reference to the global function '${name}'.`); // TODO: link to docs describing how to fix this issue
  };
}

class Platform {
  constructor(g, overrides = {}) {
    this.macroTaskRequested = false;
    this.macroTaskHandle = -1;
    this.globalThis = g;
    this.decodeURI = 'decodeURI' in overrides ? overrides.decodeURI : g.decodeURI;
    this.decodeURIComponent = 'decodeURIComponent' in overrides ? overrides.decodeURIComponent : g.decodeURIComponent;
    this.encodeURI = 'encodeURI' in overrides ? overrides.encodeURI : g.encodeURI;
    this.encodeURIComponent = 'encodeURIComponent' in overrides ? overrides.encodeURIComponent : g.encodeURIComponent;
    this.Date = 'Date' in overrides ? overrides.Date : g.Date;
    this.Reflect = 'Reflect' in overrides ? overrides.Reflect : g.Reflect;
    this.clearInterval = 'clearInterval' in overrides ? overrides.clearInterval : g.clearInterval?.bind(g) ?? notImplemented('clearInterval');
    this.clearTimeout = 'clearTimeout' in overrides ? overrides.clearTimeout : g.clearTimeout?.bind(g) ?? notImplemented('clearTimeout');
    this.queueMicrotask = 'queueMicrotask' in overrides ? overrides.queueMicrotask : g.queueMicrotask?.bind(g) ?? notImplemented('queueMicrotask');
    this.setInterval = 'setInterval' in overrides ? overrides.setInterval : g.setInterval?.bind(g) ?? notImplemented('setInterval');
    this.setTimeout = 'setTimeout' in overrides ? overrides.setTimeout : g.setTimeout?.bind(g) ?? notImplemented('setTimeout');
    this.console = 'console' in overrides ? overrides.console : g.console;
    this.performanceNow = 'performanceNow' in overrides ? overrides.performanceNow : g.performance?.now?.bind(g.performance) ?? notImplemented('performance.now');
    this.flushMacroTask = this.flushMacroTask.bind(this);
    this.macroTaskQueue = new TaskQueue(this, this.requestMacroTask.bind(this), this.cancelMacroTask.bind(this));
  }

  static getOrCreate(g, overrides = {}) {
    let platform = lookup.get(g);

    if (platform === void 0) {
      lookup.set(g, platform = new Platform(g, overrides));
    }

    return platform;
  }

  static set(g, platform) {
    lookup.set(g, platform);
  }

  requestMacroTask() {
    this.macroTaskRequested = true;

    if (this.macroTaskHandle === -1) {
      this.macroTaskHandle = this.setTimeout(this.flushMacroTask, 0);
    }
  }

  cancelMacroTask() {
    this.macroTaskRequested = false;

    if (this.macroTaskHandle > -1) {
      this.clearTimeout(this.macroTaskHandle);
      this.macroTaskHandle = -1;
    }
  }

  flushMacroTask() {
    this.macroTaskHandle = -1;

    if (this.macroTaskRequested === true) {
      this.macroTaskRequested = false;
      this.macroTaskQueue.flush();
    }
  }

}

exports.Platform = Platform;

function isPersistent(task) {
  return task.persistent;
}

class TaskQueue {
  constructor(platform, $request, $cancel) {
    this.platform = platform;
    this.$request = $request;
    this.$cancel = $cancel;
    this.processing = [];
    this.suspenderTask = void 0;
    this.pendingAsyncCount = 0;
    this.pending = [];
    this.delayed = [];
    this.flushRequested = false;
    this.yieldPromise = void 0;
    this.taskPool = [];
    this.taskPoolSize = 0;
    this.lastRequest = 0;
    this.lastFlush = 0;

    this.requestFlush = () => {
      if (this.tracer.enabled) {
        this.tracer.enter(this, 'requestFlush');
      }

      if (!this.flushRequested) {
        this.flushRequested = true;
        this.lastRequest = this.platform.performanceNow();
        this.$request();
      }

      if (this.tracer.enabled) {
        this.tracer.leave(this, 'requestFlush');
      }
    };

    this.tracer = new Tracer(platform.console);
  }

  get isEmpty() {
    return this.processing.length === 0 && this.pending.length === 0 && this.delayed.length === 0;
  }
  /**
   * Persistent tasks will re-queue themselves indefinitely until they are explicitly canceled,
   * so we consider them 'infinite work' whereas non-persistent (one-off) tasks are 'finite work'.
   *
   * This `hasNoMoreFiniteWork` getters returns true if either all remaining tasks are persistent, or if there are no more tasks.
   *
   * If that is the case, we can resolve the promise that was created when `yield()` is called.
   */


  get hasNoMoreFiniteWork() {
    return this.pendingAsyncCount === 0 && this.processing.every(isPersistent) && this.pending.every(isPersistent) && this.delayed.every(isPersistent);
  }

  flush(time = this.platform.performanceNow()) {
    if (this.tracer.enabled) {
      this.tracer.enter(this, 'flush');
    }

    this.flushRequested = false;
    this.lastFlush = time; // Only process normally if we are *not* currently waiting for an async task to finish

    if (this.suspenderTask === void 0) {
      if (this.pending.length > 0) {
        this.processing.push(...this.pending);
        this.pending.length = 0;
      }

      if (this.delayed.length > 0) {
        let i = -1;

        while (++i < this.delayed.length && this.delayed[i].queueTime <= time) {
          /* do nothing */
        }

        this.processing.push(...this.delayed.splice(0, i));
      }

      let cur;

      while (this.processing.length > 0) {
        (cur = this.processing.shift()).run(); // If it's still running, it can only be an async task

        if (cur.status === 1
        /* running */
        ) {
            if (cur.suspend === true) {
              this.suspenderTask = cur;
              this.requestFlush();

              if (this.tracer.enabled) {
                this.tracer.leave(this, 'flush early async');
              }

              return;
            } else {
              ++this.pendingAsyncCount;
            }
          }
      }

      if (this.pending.length > 0) {
        this.processing.push(...this.pending);
        this.pending.length = 0;
      }

      if (this.delayed.length > 0) {
        let i = -1;

        while (++i < this.delayed.length && this.delayed[i].queueTime <= time) {
          /* do nothing */
        }

        this.processing.push(...this.delayed.splice(0, i));
      }

      if (this.processing.length > 0 || this.delayed.length > 0 || this.pendingAsyncCount > 0) {
        this.requestFlush();
      }

      if (this.yieldPromise !== void 0 && this.hasNoMoreFiniteWork) {
        const p = this.yieldPromise;
        this.yieldPromise = void 0;
        p.resolve();
      }
    } else {
      // If we are still waiting for an async task to finish, just schedule the next flush and do nothing else.
      // Should the task finish before the next flush is invoked,
      // the callback to `completeAsyncTask` will have reset `this.suspenderTask` back to undefined so processing can return back to normal next flush.
      this.requestFlush();
    }

    if (this.tracer.enabled) {
      this.tracer.leave(this, 'flush full');
    }
  }
  /**
   * Cancel the next flush cycle (and/or the macrotask that schedules the next flush cycle, in case this is a microtask queue), if it was requested.
   *
   * This operation is idempotent and will do nothing if no flush is scheduled.
   */


  cancel() {
    if (this.tracer.enabled) {
      this.tracer.enter(this, 'cancel');
    }

    if (this.flushRequested) {
      this.$cancel();
      this.flushRequested = false;
    }

    if (this.tracer.enabled) {
      this.tracer.leave(this, 'cancel');
    }
  }
  /**
   * Returns a promise that, when awaited, resolves when:
   * - all *non*-persistent (including async) tasks have finished;
   * - the last-added persistent task has run exactly once;
   *
   * This operation is idempotent: the same promise will be returned until it resolves.
   *
   * If `yield()` is called multiple times in a row when there are one or more persistent tasks in the queue, each call will await exactly one cycle of those tasks.
   */


  async yield() {
    if (this.tracer.enabled) {
      this.tracer.enter(this, 'yield');
    }

    if (this.isEmpty) {
      if (this.tracer.enabled) {
        this.tracer.leave(this, 'yield empty');
      }
    } else {
      if (this.yieldPromise === void 0) {
        if (this.tracer.enabled) {
          this.tracer.trace(this, 'yield - creating promise');
        }

        this.yieldPromise = createExposedPromise();
      }

      await this.yieldPromise;

      if (this.tracer.enabled) {
        this.tracer.leave(this, 'yield task');
      }
    }
  }

  queueTask(callback, opts) {
    if (this.tracer.enabled) {
      this.tracer.enter(this, 'queueTask');
    }

    const {
      delay,
      preempt,
      persistent,
      reusable,
      suspend
    } = { ...defaultQueueTaskOptions,
      ...opts
    };

    if (preempt) {
      if (delay > 0) {
        throw new Error(`Invalid arguments: preempt cannot be combined with a greater-than-zero delay`);
      }

      if (persistent) {
        throw new Error(`Invalid arguments: preempt cannot be combined with persistent`);
      }
    }

    if (this.processing.length === 0) {
      this.requestFlush();
    }

    const time = this.platform.performanceNow();
    let task;

    if (reusable) {
      const taskPool = this.taskPool;
      const index = this.taskPoolSize - 1;

      if (index >= 0) {
        task = taskPool[index];
        taskPool[index] = void 0;
        this.taskPoolSize = index;
        task.reuse(time, delay, preempt, persistent, suspend, callback);
      } else {
        task = new Task(this.tracer, this, time, time + delay, preempt, persistent, suspend, reusable, callback);
      }
    } else {
      task = new Task(this.tracer, this, time, time + delay, preempt, persistent, suspend, reusable, callback);
    }

    if (preempt) {
      this.processing[this.processing.length] = task;
    } else if (delay === 0) {
      this.pending[this.pending.length] = task;
    } else {
      this.delayed[this.delayed.length] = task;
    }

    if (this.tracer.enabled) {
      this.tracer.leave(this, 'queueTask');
    }

    return task;
  }
  /**
   * Remove the task from this queue.
   */


  remove(task) {
    if (this.tracer.enabled) {
      this.tracer.enter(this, 'remove');
    }

    let idx = this.processing.indexOf(task);

    if (idx > -1) {
      this.processing.splice(idx, 1);

      if (this.tracer.enabled) {
        this.tracer.leave(this, 'remove processing');
      }

      return;
    }

    idx = this.pending.indexOf(task);

    if (idx > -1) {
      this.pending.splice(idx, 1);

      if (this.tracer.enabled) {
        this.tracer.leave(this, 'remove pending');
      }

      return;
    }

    idx = this.delayed.indexOf(task);

    if (idx > -1) {
      this.delayed.splice(idx, 1);

      if (this.tracer.enabled) {
        this.tracer.leave(this, 'remove delayed');
      }

      return;
    }

    if (this.tracer.enabled) {
      this.tracer.leave(this, 'remove error');
    }

    throw new Error(`Task #${task.id} could not be found`);
  }
  /**
   * Return a reusable task to the shared task pool.
   * The next queued callback will reuse this task object instead of creating a new one, to save overhead of creating additional objects.
   */


  returnToPool(task) {
    if (this.tracer.enabled) {
      this.tracer.trace(this, 'returnToPool');
    }

    this.taskPool[this.taskPoolSize++] = task;
  }
  /**
   * Reset the persistent task back to its pending state, preparing it for being invoked again on the next flush.
   */


  resetPersistentTask(task) {
    if (this.tracer.enabled) {
      this.tracer.enter(this, 'resetPersistentTask');
    }

    task.reset(this.platform.performanceNow());

    if (task.createdTime === task.queueTime) {
      this.pending[this.pending.length] = task;
    } else {
      this.delayed[this.delayed.length] = task;
    }

    if (this.tracer.enabled) {
      this.tracer.leave(this, 'resetPersistentTask');
    }
  }
  /**
   * Notify the queue that this async task has had its promise resolved, so that the queue can proceed with consecutive tasks on the next flush.
   */


  completeAsyncTask(task) {
    if (this.tracer.enabled) {
      this.tracer.enter(this, 'completeAsyncTask');
    }

    if (task.suspend === true) {
      if (this.suspenderTask !== task) {
        if (this.tracer.enabled) {
          this.tracer.leave(this, 'completeAsyncTask error');
        }

        throw new Error(`Async task completion mismatch: suspenderTask=${this.suspenderTask?.id}, task=${task.id}`);
      }

      this.suspenderTask = void 0;
    } else {
      --this.pendingAsyncCount;
    }

    if (this.yieldPromise !== void 0 && this.hasNoMoreFiniteWork) {
      const p = this.yieldPromise;
      this.yieldPromise = void 0;
      p.resolve();
    }

    if (this.isEmpty) {
      this.cancel();
    }

    if (this.tracer.enabled) {
      this.tracer.leave(this, 'completeAsyncTask');
    }
  }

}

exports.TaskQueue = TaskQueue;

class TaskAbortError extends Error {
  constructor(task) {
    super('Task was canceled.');
    this.task = task;
  }

}

exports.TaskAbortError = TaskAbortError;
let id = 0;
var TaskStatus;
exports.TaskStatus = TaskStatus;

(function (TaskStatus) {
  TaskStatus[TaskStatus["pending"] = 0] = "pending";
  TaskStatus[TaskStatus["running"] = 1] = "running";
  TaskStatus[TaskStatus["completed"] = 2] = "completed";
  TaskStatus[TaskStatus["canceled"] = 3] = "canceled";
})(TaskStatus || (exports.TaskStatus = TaskStatus = {}));

class Task {
  constructor(tracer, taskQueue, createdTime, queueTime, preempt, persistent, suspend, reusable, callback) {
    this.tracer = tracer;
    this.taskQueue = taskQueue;
    this.createdTime = createdTime;
    this.queueTime = queueTime;
    this.preempt = preempt;
    this.persistent = persistent;
    this.suspend = suspend;
    this.reusable = reusable;
    this.callback = callback;
    this.id = ++id;
    this.resolve = void 0;
    this.reject = void 0;
    this._result = void 0;
    this._status = 0
    /* pending */
    ;
  }

  get result() {
    const result = this._result;

    if (result === void 0) {
      switch (this._status) {
        case 0
        /* pending */
        :
          {
            const promise = this._result = createExposedPromise();
            this.resolve = promise.resolve;
            this.reject = promise.reject;
            return promise;
          }

        case 1
        /* running */
        :
          throw new Error('Trying to await task from within task will cause a deadlock.');

        case 2
        /* completed */
        :
          return this._result = Promise.resolve();

        case 3
        /* canceled */
        :
          return this._result = Promise.reject(new TaskAbortError(this));
      }
    }

    return result;
  }

  get status() {
    return this._status;
  }

  run(time = this.taskQueue.platform.performanceNow()) {
    if (this.tracer.enabled) {
      this.tracer.enter(this, 'run');
    }

    if (this._status !== 0
    /* pending */
    ) {
        if (this.tracer.enabled) {
          this.tracer.leave(this, 'run error');
        }

        throw new Error(`Cannot run task in ${this._status} state`);
      } // this.persistent could be changed while the task is running (this can only be done by the task itself if canceled, and is a valid way of stopping a loop)
    // so we deliberately reference this.persistent instead of the local variable, but we keep it around to know whether the task *was* persistent before running it,
    // so we can set the correct cancelation state.


    const {
      persistent,
      reusable,
      taskQueue,
      callback,
      resolve,
      reject,
      createdTime
    } = this;
    this._status = 1
    /* running */
    ;

    try {
      const ret = callback(time - createdTime);

      if (ret instanceof Promise) {
        ret.then($ret => {
          if (this.persistent) {
            taskQueue['resetPersistentTask'](this);
          } else {
            if (persistent) {
              // Persistent tasks never reach completed status. They're either pending, running, or canceled.
              this._status = 3
              /* canceled */
              ;
            } else {
              this._status = 2
              /* completed */
              ;
            }

            this.dispose();
          }

          taskQueue['completeAsyncTask'](this);

          if (this.tracer.enabled) {
            this.tracer.leave(this, 'run async then');
          }

          if (resolve !== void 0) {
            resolve($ret);
          }

          if (!this.persistent && reusable) {
            taskQueue['returnToPool'](this);
          }
        }).catch(err => {
          if (!this.persistent) {
            this.dispose();
          }

          taskQueue['completeAsyncTask'](this);

          if (this.tracer.enabled) {
            this.tracer.leave(this, 'run async catch');
          }

          if (reject !== void 0) {
            reject(err);
          } else {
            throw err;
          }
        });
      } else {
        if (this.persistent) {
          taskQueue['resetPersistentTask'](this);
        } else {
          if (persistent) {
            // Persistent tasks never reach completed status. They're either pending, running, or canceled.
            this._status = 3
            /* canceled */
            ;
          } else {
            this._status = 2
            /* completed */
            ;
          }

          this.dispose();
        }

        if (this.tracer.enabled) {
          this.tracer.leave(this, 'run sync success');
        }

        if (resolve !== void 0) {
          resolve(ret);
        }

        if (!this.persistent && reusable) {
          taskQueue['returnToPool'](this);
        }
      }
    } catch (err) {
      if (!this.persistent) {
        this.dispose();
      }

      if (this.tracer.enabled) {
        this.tracer.leave(this, 'run sync error');
      }

      if (reject !== void 0) {
        reject(err);
      } else {
        throw err;
      }
    }
  }

  cancel() {
    if (this.tracer.enabled) {
      this.tracer.enter(this, 'cancel');
    }

    if (this._status === 0
    /* pending */
    ) {
        const taskQueue = this.taskQueue;
        const reusable = this.reusable;
        const reject = this.reject;
        taskQueue.remove(this);

        if (taskQueue.isEmpty) {
          taskQueue.cancel();
        }

        this._status = 3
        /* canceled */
        ;
        this.dispose();

        if (reusable) {
          taskQueue['returnToPool'](this);
        }

        if (reject !== void 0) {
          reject(new TaskAbortError(this));
        }

        if (this.tracer.enabled) {
          this.tracer.leave(this, 'cancel true =pending');
        }

        return true;
      } else if (this._status === 1
    /* running */
    && this.persistent) {
      this.persistent = false;

      if (this.tracer.enabled) {
        this.tracer.leave(this, 'cancel true =running+persistent');
      }

      return true;
    }

    if (this.tracer.enabled) {
      this.tracer.leave(this, 'cancel false');
    }

    return false;
  }

  reset(time) {
    if (this.tracer.enabled) {
      this.tracer.enter(this, 'reset');
    }

    const delay = this.queueTime - this.createdTime;
    this.createdTime = time;
    this.queueTime = time + delay;
    this._status = 0
    /* pending */
    ;
    this.resolve = void 0;
    this.reject = void 0;
    this._result = void 0;

    if (this.tracer.enabled) {
      this.tracer.leave(this, 'reset');
    }
  }

  reuse(time, delay, preempt, persistent, suspend, callback) {
    if (this.tracer.enabled) {
      this.tracer.enter(this, 'reuse');
    }

    this.createdTime = time;
    this.queueTime = time + delay;
    this.preempt = preempt;
    this.persistent = persistent;
    this.suspend = suspend;
    this.callback = callback;
    this._status = 0
    /* pending */
    ;

    if (this.tracer.enabled) {
      this.tracer.leave(this, 'reuse');
    }
  }

  dispose() {
    if (this.tracer.enabled) {
      this.tracer.trace(this, 'dispose');
    }

    this.callback = void 0;
    this.resolve = void 0;
    this.reject = void 0;
    this._result = void 0;
  }

}

exports.Task = Task;

function taskStatus(status) {
  switch (status) {
    case 0
    /* pending */
    :
      return 'pending';

    case 1
    /* running */
    :
      return 'running';

    case 3
    /* canceled */
    :
      return 'canceled';

    case 2
    /* completed */
    :
      return 'completed';
  }
}

class Tracer {
  constructor(console) {
    this.console = console;
    this.enabled = false;
    this.depth = 0;
  }

  enter(obj, method) {
    this.log(`${'  '.repeat(this.depth++)}> `, obj, method);
  }

  leave(obj, method) {
    this.log(`${'  '.repeat(--this.depth)}< `, obj, method);
  }

  trace(obj, method) {
    this.log(`${'  '.repeat(this.depth)}- `, obj, method);
  }

  log(prefix, obj, method) {
    if (obj instanceof TaskQueue) {
      const processing = obj['processing'].length;
      const pending = obj['pending'].length;
      const delayed = obj['delayed'].length;
      const flushReq = obj['flushRequested'];
      const susTask = !!obj['suspenderTask'];
      const info = `processing=${processing} pending=${pending} delayed=${delayed} flushReq=${flushReq} susTask=${susTask}`;
      this.console.log(`${prefix}[Q.${method}] ${info}`);
    } else {
      const id = obj['id'];
      const created = Math.round(obj['createdTime'] * 10) / 10;
      const queue = Math.round(obj['queueTime'] * 10) / 10;
      const preempt = obj['preempt'];
      const reusable = obj['reusable'];
      const persistent = obj['persistent'];
      const suspend = obj['suspend'];
      const status = taskStatus(obj['_status']);
      const info = `id=${id} created=${created} queue=${queue} preempt=${preempt} persistent=${persistent} reusable=${reusable} status=${status} suspend=${suspend}`;
      this.console.log(`${prefix}[T.${method}] ${info}`);
    }
  }

}

var TaskQueuePriority;
exports.TaskQueuePriority = TaskQueuePriority;

(function (TaskQueuePriority) {
  TaskQueuePriority[TaskQueuePriority["render"] = 0] = "render";
  TaskQueuePriority[TaskQueuePriority["macroTask"] = 1] = "macroTask";
  TaskQueuePriority[TaskQueuePriority["postRender"] = 2] = "postRender";
})(TaskQueuePriority || (exports.TaskQueuePriority = TaskQueuePriority = {}));

const defaultQueueTaskOptions = {
  delay: 0,
  preempt: false,
  persistent: false,
  reusable: true,
  suspend: false
};
let $resolve;
let $reject;

function executor(resolve, reject) {
  $resolve = resolve;
  $reject = reject;
}
/**
 * Efficiently create a promise where the `resolve` and `reject` functions are stored as properties on the prommise itself.
 */


function createExposedPromise() {
  const p = new Promise(executor);
  p.resolve = $resolve;
  p.reject = $reject;
  return p;
}
});

;define.alias('@aurelia/platform','@aurelia/platform/dist/esm/index.js');
define('@aurelia/route-recognizer/dist/esm/index.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.RouteRecognizer = exports.RecognizedRoute = exports.Endpoint = exports.ConfigurableRoute = void 0;

class ConfigurableRoute {
  constructor(path, caseSensitive, handler) {
    this.path = path;
    this.caseSensitive = caseSensitive;
    this.handler = handler;
  }

}

exports.ConfigurableRoute = ConfigurableRoute;

class Endpoint {
  constructor(route, paramNames) {
    this.route = route;
    this.paramNames = paramNames;
  }

}

exports.Endpoint = Endpoint;

class RecognizedRoute {
  constructor(endpoint, params) {
    this.endpoint = endpoint;
    this.params = params;
  }

}

exports.RecognizedRoute = RecognizedRoute;

class Candidate {
  constructor(chars, states, skippedStates, result) {
    this.chars = chars;
    this.states = states;
    this.skippedStates = skippedStates;
    this.result = result;
    this.head = states[states.length - 1]; // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain

    this.endpoint = this.head?.endpoint;
  }

  advance(ch) {
    const {
      chars,
      states,
      skippedStates,
      result
    } = this;
    let stateToAdd = null;
    let matchCount = 0;
    const state = states[states.length - 1];

    function $process(nextState, skippedState) {
      if (nextState.isMatch(ch)) {
        if (++matchCount === 1) {
          stateToAdd = nextState;
        } else {
          result.add(new Candidate(chars.concat(ch), states.concat(nextState), skippedState === null ? skippedStates : skippedStates.concat(skippedState), result));
        }
      }

      if (state.segment === null && nextState.isOptional && nextState.nextStates !== null) {
        if (nextState.nextStates.length > 1) {
          throw new Error(`${nextState.nextStates.length} nextStates`);
        }

        const separator = nextState.nextStates[0];

        if (!separator.isSeparator) {
          throw new Error(`Not a separator`);
        }

        if (separator.nextStates !== null) {
          for (const $nextState of separator.nextStates) {
            $process($nextState, nextState);
          }
        }
      }
    }

    if (state.isDynamic) {
      $process(state, null);
    }

    if (state.nextStates !== null) {
      for (const nextState of state.nextStates) {
        $process(nextState, null);
      }
    }

    if (stateToAdd !== null) {
      states.push(this.head = stateToAdd);
      chars.push(ch);

      if (stateToAdd.endpoint !== null) {
        this.endpoint = stateToAdd.endpoint;
      }
    }

    if (matchCount === 0) {
      result.remove(this);
    }
  }

  finalize() {
    function collectSkippedStates(skippedStates, state) {
      const nextStates = state.nextStates;

      if (nextStates !== null) {
        if (nextStates.length === 1 && nextStates[0].segment === null) {
          collectSkippedStates(skippedStates, nextStates[0]);
        } else {
          for (const nextState of nextStates) {
            if (nextState.isOptional && nextState.endpoint !== null) {
              skippedStates.push(nextState);

              if (nextState.nextStates !== null) {
                for (const $nextState of nextState.nextStates) {
                  collectSkippedStates(skippedStates, $nextState);
                }
              }

              break;
            }
          }
        }
      }
    }

    collectSkippedStates(this.skippedStates, this.head);
  }

  getParams() {
    const {
      states,
      chars,
      endpoint
    } = this;
    const params = {}; // First initialize all properties with undefined so they all exist (even if they're not filled, e.g. non-matched optional params)

    for (const name of endpoint.paramNames) {
      params[name] = void 0;
    }

    for (let i = 0, ii = states.length; i < ii; ++i) {
      const state = states[i];

      if (state.isDynamic) {
        const name = state.segment.name;

        if (params[name] === void 0) {
          params[name] = chars[i];
        } else {
          params[name] += chars[i];
        }
      }
    }

    return params;
  }
  /**
   * Compares this candidate to another candidate to determine the correct sorting order.
   *
   * This algorithm is different from `sortSolutions` in v1's route-recognizer in that it compares
   * the candidates segment-by-segment, rather than merely comparing the cumulative of segment types
   *
   * This resolves v1's ambiguity in situations like `/foo/:id/bar` vs. `/foo/bar/:id`, which had the
   * same sorting value because they both consist of two static segments and one dynamic segment.
   *
   * With this algorithm, `/foo/bar/:id` would always be sorted first because the second segment is different,
   * and static wins over dynamic.
   *
   * ### NOTE
   * This algorithm violates some of the invariants of v1's algorithm,
   * but those invariants were arguably not very sound to begin with. Example:
   *
   * `/foo/*path/bar/baz` vs. `/foo/bar/*path1/*path2`
   * - in v1, the first would win because that match has fewer stars
   * - in v2, the second will win because there is a bigger static match at the start of the pattern
   *
   * The algorithm should be more logical and easier to reason about in v2, but it's important to be aware of
   * subtle difference like this which might surprise some users who happened to rely on this behavior from v1,
   * intentionally or unintentionally.
   *
   * @param b - The candidate to compare this to.
   * Parameter name is `b` because the method should be used like so: `states.sort((a, b) => a.compareTo(b))`.
   * This will bring the candidate with the highest score to the first position of the array.
   */


  compareTo(b) {
    const statesA = this.states;
    const statesB = b.states;

    for (let iA = 0, iB = 0, ii = Math.max(statesA.length, statesB.length); iA < ii; ++iA) {
      let stateA = statesA[iA];

      if (stateA === void 0) {
        return 1;
      }

      let stateB = statesB[iB];

      if (stateB === void 0) {
        return -1;
      }

      let segmentA = stateA.segment;
      let segmentB = stateB.segment;

      if (segmentA === null) {
        if (segmentB === null) {
          ++iB;
          continue;
        }

        if ((stateA = statesA[++iA]) === void 0) {
          return 1;
        }

        segmentA = stateA.segment;
      } else if (segmentB === null) {
        if ((stateB = statesB[++iB]) === void 0) {
          return -1;
        }

        segmentB = stateB.segment;
      }

      if (segmentA.kind < segmentB.kind) {
        return 1;
      }

      if (segmentA.kind > segmentB.kind) {
        return -1;
      }

      ++iB;
    }

    const skippedStatesA = this.skippedStates;
    const skippedStatesB = b.skippedStates;
    const skippedStatesALen = skippedStatesA.length;
    const skippedStatesBLen = skippedStatesB.length;

    if (skippedStatesALen < skippedStatesBLen) {
      return 1;
    }

    if (skippedStatesALen > skippedStatesBLen) {
      return -1;
    }

    for (let i = 0; i < skippedStatesALen; ++i) {
      const skippedStateA = skippedStatesA[i];
      const skippedStateB = skippedStatesB[i];

      if (skippedStateA.length < skippedStateB.length) {
        return 1;
      }

      if (skippedStateA.length > skippedStateB.length) {
        return -1;
      }
    } // This should only be possible with a single pattern with multiple consecutive star segments.
    // TODO: probably want to warn or even throw here, but leave it be for now.


    return 0;
  }

}

function hasEndpoint(candidate) {
  return candidate.head.endpoint !== null;
}

function compareChains(a, b) {
  return a.compareTo(b);
}

class RecognizeResult {
  constructor(rootState) {
    this.candidates = [];
    this.candidates = [new Candidate([''], [rootState], [], this)];
  }

  get isEmpty() {
    return this.candidates.length === 0;
  }

  getSolution() {
    const candidates = this.candidates.filter(hasEndpoint);

    if (candidates.length === 0) {
      return null;
    }

    for (const candidate of candidates) {
      candidate.finalize();
    }

    candidates.sort(compareChains);
    return candidates[0];
  }

  add(candidate) {
    this.candidates.push(candidate);
  }

  remove(candidate) {
    this.candidates.splice(this.candidates.indexOf(candidate), 1);
  }

  advance(ch) {
    const candidates = this.candidates.slice();

    for (const candidate of candidates) {
      candidate.advance(ch);
    }
  }

}

class RouteRecognizer {
  constructor() {
    this.rootState = new State(null, null, '');
    this.cache = new Map();
  }

  add(routeOrRoutes) {
    if (routeOrRoutes instanceof Array) {
      for (const route of routeOrRoutes) {
        this.$add(route);
      }
    } else {
      this.$add(routeOrRoutes);
    } // Clear the cache whenever there are state changes, because the recognizeResults could be arbitrarily different as a result


    this.cache.clear();
  }

  $add(route) {
    const path = route.path;
    const $route = new ConfigurableRoute(route.path, route.caseSensitive === true, route.handler); // Normalize leading, trailing and double slashes by ignoring empty segments

    const parts = path === '' ? [''] : path.split('/').filter(isNotEmpty);
    const paramNames = [];
    let state = this.rootState;

    for (const part of parts) {
      // Each segment always begins with a slash, so we represent this with a non-segment state
      state = state.append(null, '/');

      switch (part.charAt(0)) {
        case ':':
          {
            // route parameter
            const isOptional = part.endsWith('?');
            const name = isOptional ? part.slice(1, -1) : part.slice(1);
            paramNames.push(name);
            state = new DynamicSegment(name, isOptional).appendTo(state);
            break;
          }

        case '*':
          {
            // dynamic route
            const name = part.slice(1);
            paramNames.push(name);
            state = new StarSegment(name).appendTo(state);
            break;
          }

        default:
          {
            // standard path route
            state = new StaticSegment(part, $route.caseSensitive).appendTo(state);
            break;
          }
      }
    }

    const endpoint = new Endpoint($route, paramNames);
    state.setEndpoint(endpoint);
  }

  recognize(path) {
    let result = this.cache.get(path);

    if (result === void 0) {
      this.cache.set(path, result = this.$recognize(path));
    }

    return result;
  }

  $recognize(path) {
    path = decodeURI(path);

    if (!path.startsWith('/')) {
      path = `/${path}`;
    }

    if (path.length > 1 && path.endsWith('/')) {
      path = path.slice(0, -1);
    }

    const result = new RecognizeResult(this.rootState);

    for (let i = 0, ii = path.length; i < ii; ++i) {
      const ch = path.charAt(i);
      result.advance(ch);

      if (result.isEmpty) {
        return null;
      }
    }

    const candidate = result.getSolution();

    if (candidate === null) {
      return null;
    }

    const {
      endpoint
    } = candidate;
    const params = candidate.getParams();
    return new RecognizedRoute(endpoint, params);
  }

}

exports.RouteRecognizer = RouteRecognizer;

class State {
  constructor(prevState, segment, value) {
    this.prevState = prevState;
    this.segment = segment;
    this.value = value;
    this.nextStates = null;
    this.endpoint = null;

    switch (segment?.kind) {
      case 2
      /* dynamic */
      :
        this.length = prevState.length + 1;
        this.isSeparator = false;
        this.isDynamic = true;
        this.isOptional = segment.optional;
        break;

      case 1
      /* star */
      :
        this.length = prevState.length + 1;
        this.isSeparator = false;
        this.isDynamic = true;
        this.isOptional = false;
        break;

      case 3
      /* static */
      :
        this.length = prevState.length + 1;
        this.isSeparator = false;
        this.isDynamic = false;
        this.isOptional = false;
        break;

      case undefined:
        this.length = prevState === null ? 0 : prevState.length;
        this.isSeparator = true;
        this.isDynamic = false;
        this.isOptional = false;
        break;
    }
  }

  append(segment, value) {
    let state;
    let nextStates = this.nextStates;

    if (nextStates === null) {
      state = void 0;
      nextStates = this.nextStates = [];
    } else if (segment === null) {
      state = nextStates.find(s => s.value === value);
    } else {
      state = nextStates.find(s => s.segment?.equals(segment));
    }

    if (state === void 0) {
      nextStates.push(state = new State(this, segment, value));
    }

    return state;
  }

  setEndpoint(endpoint) {
    if (this.endpoint !== null) {
      throw new Error(`Cannot add ambiguous route. The pattern '${endpoint.route.path}' clashes with '${this.endpoint.route.path}'`);
    }

    this.endpoint = endpoint;

    if (this.isOptional) {
      this.prevState.setEndpoint(endpoint);

      if (this.prevState.isSeparator && this.prevState.prevState !== null) {
        this.prevState.prevState.setEndpoint(endpoint);
      }
    }
  }

  isMatch(ch) {
    const segment = this.segment;

    switch (segment?.kind) {
      case 2
      /* dynamic */
      :
        return !this.value.includes(ch);

      case 1
      /* star */
      :
        return true;

      case 3
      /* static */
      :
      case undefined:
        // segment separators (slashes) are non-segments. We could say return ch === '/' as well, technically.
        return this.value.includes(ch);
    }
  }

}

function isNotEmpty(segment) {
  return segment.length > 0;
}

var SegmentKind;

(function (SegmentKind) {
  SegmentKind[SegmentKind["star"] = 1] = "star";
  SegmentKind[SegmentKind["dynamic"] = 2] = "dynamic";
  SegmentKind[SegmentKind["static"] = 3] = "static";
})(SegmentKind || (SegmentKind = {}));

class StaticSegment {
  constructor(value, caseSensitive) {
    this.value = value;
    this.caseSensitive = caseSensitive;
  }

  get kind() {
    return 3
    /* static */
    ;
  }

  appendTo(state) {
    const {
      value,
      value: {
        length
      }
    } = this;

    if (this.caseSensitive) {
      for (let i = 0; i < length; ++i) {
        state = state.append(
        /* segment */
        this,
        /* value   */
        value.charAt(i));
      }
    } else {
      for (let i = 0; i < length; ++i) {
        const ch = value.charAt(i);
        state = state.append(
        /* segment */
        this,
        /* value   */
        ch.toUpperCase() + ch.toLowerCase());
      }
    }

    return state;
  }

  equals(b) {
    return b.kind === 3
    /* static */
    && b.caseSensitive === this.caseSensitive && b.value === this.value;
  }

}

class DynamicSegment {
  constructor(name, optional) {
    this.name = name;
    this.optional = optional;
  }

  get kind() {
    return 2
    /* dynamic */
    ;
  }

  appendTo(state) {
    state = state.append(
    /* segment */
    this,
    /* value   */
    '/');
    return state;
  }

  equals(b) {
    return b.kind === 2
    /* dynamic */
    && b.optional === this.optional && b.name === this.name;
  }

}

class StarSegment {
  constructor(name) {
    this.name = name;
  }

  get kind() {
    return 1
    /* star */
    ;
  }

  appendTo(state) {
    state = state.append(
    /* segment */
    this,
    /* value   */
    '');
    return state;
  }

  equals(b) {
    return b.kind === 1
    /* star */
    && b.name === this.name;
  }

}
});

;define.alias('@aurelia/route-recognizer','@aurelia/route-recognizer/dist/esm/index.js');
define('@aurelia/router/dist/esm/awaitable-map.js',['require','exports','module','./open-promise.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.AwaitableMap = void 0;

var _openPromise = require("./open-promise.js");

// export class OpenPromise<T> {
//   public isPending: boolean = true;
//   public promise!: Promise<T>;
//   public resolve!: (value: T | PromiseLike<T>) => void;
//   public reject!: () => void;
// }
class AwaitableMap {
  constructor() {
    this.map = new Map();
  }

  set(key, value) {
    const openPromise = this.map.get(key);

    if (openPromise instanceof _openPromise.OpenPromise) {
      openPromise.resolve(value); // openPromise.isPending = false;
    }

    this.map.set(key, value);
  }

  delete(key) {
    const current = this.map.get(key);

    if (current instanceof _openPromise.OpenPromise) {
      current.reject(); // current.isPending = false;
    }

    this.map.delete(key);
  }

  await(key) {
    if (!this.map.has(key)) {
      const openPromise = new _openPromise.OpenPromise(); // openPromise.promise = new Promise((res, rej) => {
      //   openPromise.resolve = res;
      //   openPromise.reject = rej;
      // });

      this.map.set(key, openPromise);
      return openPromise.promise;
    }

    const current = this.map.get(key);

    if (current instanceof _openPromise.OpenPromise) {
      return current.promise;
    }

    return current;
  }

  has(key) {
    return this.map.has(key) && !(this.map.get(key) instanceof _openPromise.OpenPromise);
  }

  clone() {
    const clone = new AwaitableMap();
    clone.map = new Map(this.map);
    return clone;
  }

}

exports.AwaitableMap = AwaitableMap;
});

;define.alias('@aurelia/router/awaitable-map.js','@aurelia/router/dist/esm/awaitable-map.js');
define('@aurelia/router/dist/esm/browser-viewer-store.js',['require','exports','module','@aurelia/runtime-html','./task-queue.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.BrowserViewerStore = void 0;

var _runtimeHtml = require("@aurelia/runtime-html");

var _taskQueue = require("./task-queue.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

/**
 * @internal - Shouldn't be used directly
 */
let BrowserViewerStore = class BrowserViewerStore {
  constructor(platform, window, history, location) {
    this.platform = platform;
    this.window = window;
    this.history = history;
    this.location = location;
    this.allowedExecutionCostWithinTick = 2; // Limit no of executed actions within the same RAF (due to browser limitation)

    this.isActive = false;
    this.options = {
      useUrlFragmentHash: true,
      callback: () => {
        return;
      }
    };
    this.forwardedState = {
      eventTask: null,
      suppressPopstate: false
    };

    this.handlePopstate = async event => {
      const {
        eventTask,
        suppressPopstate
      } = this.forwardedState;
      this.forwardedState = {
        eventTask: null,
        suppressPopstate: false
      };
      return this.pendingCalls.enqueue(async task => {
        const store = this;
        const ev = event;
        const evTask = eventTask;
        const suppressPopstateEvent = suppressPopstate;
        await store.popstate(ev, evTask, suppressPopstateEvent);
        task.resolve();
      }, 1).wait();
    };

    this.pendingCalls = new _taskQueue.TaskQueue();
  }

  start(options) {
    if (this.isActive) {
      throw new Error('Browser navigation has already been started');
    }

    this.isActive = true;
    this.options.callback = options.callback;

    if (options.useUrlFragmentHash != void 0) {
      this.options.useUrlFragmentHash = options.useUrlFragmentHash;
    }

    this.pendingCalls.start({
      platform: this.platform,
      allowedExecutionCostWithinTick: this.allowedExecutionCostWithinTick
    });
    this.window.addEventListener('popstate', this.handlePopstate);
  }

  stop() {
    if (!this.isActive) {
      throw new Error('Browser navigation has not been started');
    }

    this.window.removeEventListener('popstate', this.handlePopstate);
    this.pendingCalls.stop();
    this.options = {
      useUrlFragmentHash: true,
      callback: () => {
        return;
      }
    };
    this.isActive = false;
  }

  get length() {
    return this.history.length;
  }

  get state() {
    return this.history.state;
  }

  get viewerState() {
    const {
      pathname,
      search,
      hash
    } = this.location;
    return {
      path: pathname,
      query: search,
      hash,
      instruction: this.options.useUrlFragmentHash ? hash.slice(1) : pathname
    };
  }

  async go(delta, suppressPopstateEvent = false) {
    const doneTask = this.pendingCalls.createQueueTask(task => task.resolve(), 1);
    this.pendingCalls.enqueue([task => {
      const store = this;
      const eventTask = doneTask;
      const suppressPopstate = suppressPopstateEvent;
      store.forwardState({
        eventTask,
        suppressPopstate
      });
      task.resolve();
    }, task => {
      const history = this.history;
      const steps = delta;
      history.go(steps);
      task.resolve();
    }], [0, 1]);
    return doneTask.wait();
  }

  async pushNavigatorState(state) {
    const {
      title,
      path
    } = state.currentEntry;
    const fragment = this.options.useUrlFragmentHash ? '#/' : '';
    return this.pendingCalls.enqueue(task => {
      const history = this.history;
      const data = state;
      const titleOrEmpty = title || '';
      const url = `${fragment}${path}`;
      history.pushState(data, titleOrEmpty, url);
      task.resolve();
    }, 1).wait();
  }

  async replaceNavigatorState(state) {
    const {
      title,
      path
    } = state.currentEntry;
    const fragment = this.options.useUrlFragmentHash ? '#/' : '';
    return this.pendingCalls.enqueue(task => {
      const history = this.history;
      const data = state;
      const titleOrEmpty = title || '';
      const url = `${fragment}${path}`;
      history.replaceState(data, titleOrEmpty, url);
      task.resolve();
    }, 1).wait();
  }

  async popNavigatorState() {
    const doneTask = this.pendingCalls.createQueueTask(task => task.resolve(), 1);
    this.pendingCalls.enqueue(async task => {
      const store = this;
      const eventTask = doneTask;
      await store.popState(eventTask);
      task.resolve();
    }, 1);
    return doneTask.wait();
  }

  async popState(doneTask) {
    await this.go(-1, true);
    const state = this.history.state; // TODO: Fix browser forward bug after pop on first entry

    if (state && state.currentEntry && !state.currentEntry.firstEntry) {
      await this.go(-1, true);
      await this.pushNavigatorState(state);
    }

    await doneTask.execute();
  }

  forwardState(state) {
    this.forwardedState = state;
  }

  async popstate(ev, eventTask, suppressPopstate = false) {
    if (!suppressPopstate) {
      this.options.callback({ ...this.viewerState,
        ...{
          event: ev,
          state: this.history.state
        }
      });
    }

    if (eventTask !== null) {
      await eventTask.execute();
    }
  }

  setTitle(title) {
    this.window.document.title = title;
  }

};
exports.BrowserViewerStore = BrowserViewerStore;
exports.BrowserViewerStore = BrowserViewerStore = __decorate([__param(0, _runtimeHtml.IPlatform), __param(1, _runtimeHtml.IWindow), __param(2, _runtimeHtml.IHistory), __param(3, _runtimeHtml.ILocation)], BrowserViewerStore);
});

;define.alias('@aurelia/router/browser-viewer-store.js','@aurelia/router/dist/esm/browser-viewer-store.js');
define('@aurelia/router/dist/esm/collection.js',['require','exports','module','./utils.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.Collection = void 0;

var _utils = require("./utils.js");

/**
 * @internal - Helper class
 */
class Collection extends Array {
  constructor() {
    super(...arguments);
    this.currentIndex = -1;
  }

  next() {
    if (this.length > this.currentIndex + 1) {
      return this[++this.currentIndex];
    } else {
      this.currentIndex = -1;
      return null;
    }
  }

  removeCurrent() {
    this.splice(this.currentIndex--, 1);
  }

  remove(instruction) {
    (0, _utils.arrayRemove)(this, value => value === instruction);
  }

}

exports.Collection = Collection;
});

;define.alias('@aurelia/router/collection.js','@aurelia/router/dist/esm/collection.js');
define('@aurelia/router/dist/esm/configuration.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime-html','./resources/nav.js','./resources/viewport.js','./resources/viewport-scope.js','./resources/goto.js','./resources/load.js','./resources/href.js','./router.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.RouterConfiguration = exports.DefaultResources = exports.HrefCustomAttributeRegistration = exports.LoadCustomAttributeRegistration = exports.GotoCustomAttributeRegistration = exports.NavCustomElementRegistration = exports.ViewportScopeCustomElementRegistration = exports.ViewportCustomElementRegistration = exports.DefaultComponents = exports.RouterRegistration = void 0;

var _kernel = require("@aurelia/kernel");

var _runtimeHtml = require("@aurelia/runtime-html");

var _nav = require("./resources/nav.js");

exports.NavCustomElement = _nav.NavCustomElement;

var _viewport = require("./resources/viewport.js");

exports.ViewportCustomElement = _viewport.ViewportCustomElement;

var _viewportScope = require("./resources/viewport-scope.js");

exports.ViewportScopeCustomElement = _viewportScope.ViewportScopeCustomElement;

var _goto = require("./resources/goto.js");

exports.GotoCustomAttribute = _goto.GotoCustomAttribute;

var _load = require("./resources/load.js");

exports.LoadCustomAttribute = _load.LoadCustomAttribute;

var _href = require("./resources/href.js");

exports.HrefCustomAttribute = _href.HrefCustomAttribute;

var _router = require("./router.js");

const RouterRegistration = _router.IRouter;
/**
 * Default runtime/environment-agnostic implementations for the following interfaces:
 * - `IRouter`
 */

exports.RouterRegistration = RouterRegistration;
const DefaultComponents = [RouterRegistration];
exports.DefaultComponents = DefaultComponents;
const ViewportCustomElementRegistration = _viewport.ViewportCustomElement;
exports.ViewportCustomElementRegistration = ViewportCustomElementRegistration;
const ViewportScopeCustomElementRegistration = _viewportScope.ViewportScopeCustomElement;
exports.ViewportScopeCustomElementRegistration = ViewportScopeCustomElementRegistration;
const NavCustomElementRegistration = _nav.NavCustomElement;
exports.NavCustomElementRegistration = NavCustomElementRegistration;
const GotoCustomAttributeRegistration = _goto.GotoCustomAttribute;
exports.GotoCustomAttributeRegistration = GotoCustomAttributeRegistration;
const LoadCustomAttributeRegistration = _load.LoadCustomAttribute;
exports.LoadCustomAttributeRegistration = LoadCustomAttributeRegistration;
const HrefCustomAttributeRegistration = _href.HrefCustomAttribute;
/**
 * Default router resources:
 * - Custom Elements: `au-viewport`, `au-nav`
 * - Custom Attributes: `goto`, `load`, `href`
 */

exports.HrefCustomAttributeRegistration = HrefCustomAttributeRegistration;
const DefaultResources = [_viewport.ViewportCustomElement, _viewportScope.ViewportScopeCustomElement, _nav.NavCustomElement, _goto.GotoCustomAttribute, _load.LoadCustomAttribute, _href.HrefCustomAttribute];
exports.DefaultResources = DefaultResources;
let configurationOptions = {};

let configurationCall = router => {
  router.start(configurationOptions);
};
/**
 * A DI configuration object containing router resource registrations.
 */


const routerConfiguration = {
  /**
   * Apply this configuration to the provided container.
   */
  register(container) {
    return container.register(...DefaultComponents, ...DefaultResources, _runtimeHtml.AppTask.with(_router.IRouter).beforeActivate().call(configurationCall), _runtimeHtml.AppTask.with(_router.IRouter).afterActivate().call(router => router.loadUrl()), _runtimeHtml.AppTask.with(_router.IRouter).afterDeactivate().call(router => router.stop()));
  },

  /**
   * Create a new container with this configuration applied to it.
   */
  createContainer() {
    return this.register(_kernel.DI.createContainer());
  }

};
const RouterConfiguration = {
  /**
   * Make it possible to specify options to Router activation.
   * Parameter is either a config object that's passed to Router's start
   * or a config function that's called instead of Router's start.
   */
  customize(config) {
    if (config === undefined) {
      configurationOptions = {};

      configurationCall = router => {
        router.start(configurationOptions);
      };
    } else if (config instanceof Function) {
      configurationCall = config;
    } else {
      configurationOptions = config;
    }

    return { ...routerConfiguration
    };
  },

  ...routerConfiguration
};
exports.RouterConfiguration = RouterConfiguration;
});

;define.alias('@aurelia/router/configuration.js','@aurelia/router/dist/esm/configuration.js');
define('@aurelia/router/dist/esm/found-route.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.FoundRoute = void 0;

/**
 * @internal - Used when founding route/instructions
 */
class FoundRoute {
  constructor(match = null, matching = '', instructions = [], remaining = '', // public remaining: string | null = null,
  params = {}) {
    this.match = match;
    this.matching = matching;
    this.instructions = instructions;
    this.remaining = remaining;
    this.params = params;
  }

  get foundConfiguration() {
    return this.match !== null;
  }

  get foundInstructions() {
    return this.instructions.length > 0;
  }

  get hasRemaining() {
    return this.remaining !== null && this.remaining.length > 0;
  }

}

exports.FoundRoute = FoundRoute;
});

;define.alias('@aurelia/router/found-route.js','@aurelia/router/dist/esm/found-route.js');
define('@aurelia/router/dist/esm/hook-manager.js',['require','exports','module','./hook.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.HookManager = exports.HookTypes = void 0;

var _hook = require("./hook.js");

/**
 * Public API
 */
var HookTypes;
exports.HookTypes = HookTypes;

(function (HookTypes) {
  HookTypes["BeforeNavigation"] = "beforeNavigation";
  HookTypes["TransformFromUrl"] = "transformFromUrl";
  HookTypes["TransformToUrl"] = "transformToUrl";
  HookTypes["SetTitle"] = "setTitle";
})(HookTypes || (exports.HookTypes = HookTypes = {}));
/**
 * @internal - Shouldn't be used directly
 */


class HookManager {
  constructor() {
    this.hooks = {
      beforeNavigation: [],
      transformFromUrl: [],
      transformToUrl: [],
      setTitle: []
    };
    this.lastIdentity = 0;
  }

  addHook(hookFunction, options) {
    const hook = new _hook.Hook(hookFunction, options || {}, ++this.lastIdentity);
    this.hooks[hook.type].push(hook);
    return this.lastIdentity;
  }

  removeHook(id) {
    for (const type in this.hooks) {
      if (Object.prototype.hasOwnProperty.call(this.hooks, type)) {
        const index = this.hooks[type].findIndex(hook => hook.id === id);

        if (index >= 0) {
          this.hooks[type].splice(index, 1);
        }
      }
    }
  }

  async invokeBeforeNavigation(viewportInstructions, navigationInstruction) {
    return this.invoke("beforeNavigation"
    /* BeforeNavigation */
    , navigationInstruction, viewportInstructions);
  }

  async invokeTransformFromUrl(url, navigationInstruction) {
    return this.invoke("transformFromUrl"
    /* TransformFromUrl */
    , navigationInstruction, url);
  }

  async invokeTransformToUrl(state, navigationInstruction) {
    return this.invoke("transformToUrl"
    /* TransformToUrl */
    , navigationInstruction, state);
  }

  async invokeSetTitle(title, navigationInstruction) {
    return this.invoke("setTitle"
    /* SetTitle */
    , navigationInstruction, title);
  }

  async invoke(type, navigationInstruction, arg) {
    for (const hook of this.hooks[type]) {
      if (!hook.wantsMatch || hook.matches(arg)) {
        const outcome = await hook.invoke(navigationInstruction, arg);

        if (typeof outcome === 'boolean') {
          if (!outcome) {
            return false;
          }
        } else {
          arg = outcome;
        }
      }
    }

    return arg;
  }

}

exports.HookManager = HookManager;
});

;define.alias('@aurelia/router/hook-manager.js','@aurelia/router/dist/esm/hook-manager.js');
define('@aurelia/router/dist/esm/hook.js',['require','exports','module','./type-resolvers.js','./viewport-instruction.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.Hook = void 0;

var _typeResolvers = require("./type-resolvers.js");

var _viewportInstruction = require("./viewport-instruction.js");

/**
 * @internal - Shouldn't be used directly
 */
class Hook {
  constructor(hook, options, id) {
    this.hook = hook;
    this.id = id;
    this.type = "beforeNavigation"
    /* BeforeNavigation */
    ;
    this.includeTargets = [];
    this.excludeTargets = [];

    if (options.type !== void 0) {
      this.type = options.type;
    }

    for (const target of options.include || []) {
      this.includeTargets.push(new Target(target));
    }

    for (const target of options.exclude || []) {
      this.excludeTargets.push(new Target(target));
    }
  }

  get wantsMatch() {
    return this.includeTargets.length > 0 || this.excludeTargets.length > 0;
  }

  matches(viewportInstructions) {
    if (this.includeTargets.length && !this.includeTargets.some(target => target.matches(viewportInstructions))) {
      return false;
    }

    if (this.excludeTargets.length && this.excludeTargets.some(target => target.matches(viewportInstructions))) {
      return false;
    }

    return true;
  }

  invoke(navigationInstruction, arg) {
    // TODO: Fix the type here
    return this.hook(arg, navigationInstruction);
  }

}

exports.Hook = Hook;

class Target {
  constructor(target) {
    this.componentType = null;
    this.componentName = null;
    this.viewport = null;
    this.viewportName = null;

    if (typeof target === 'string') {
      this.componentName = target;
    } else if (_typeResolvers.ComponentAppellationResolver.isType(target)) {
      this.componentType = target;
      this.componentName = _typeResolvers.ComponentAppellationResolver.getName(target);
    } else {
      const cvTarget = target;

      if (cvTarget.component) {
        this.componentType = _typeResolvers.ComponentAppellationResolver.isType(cvTarget.component) ? _typeResolvers.ComponentAppellationResolver.getType(cvTarget.component) : null;
        this.componentName = _typeResolvers.ComponentAppellationResolver.getName(cvTarget.component);
      }

      if (cvTarget.viewport) {
        this.viewport = _typeResolvers.ViewportHandleResolver.isInstance(cvTarget.viewport) ? cvTarget.viewport : null;
        this.viewportName = _typeResolvers.ViewportHandleResolver.getName(cvTarget.viewport);
      }
    }
  }

  matches(viewportInstructions) {
    const instructions = viewportInstructions.slice();

    if (!instructions.length) {
      // instructions.push(new ViewportInstruction(''));
      instructions.push(_viewportInstruction.ViewportInstruction.create(null, ''));
    }

    for (const instruction of instructions) {
      if (this.componentName !== null && this.componentName === instruction.componentName || this.componentType !== null && this.componentType === instruction.componentType || this.viewportName !== null && this.viewportName === instruction.viewportName || this.viewport !== null && this.viewport === instruction.viewport) {
        return true;
      }
    }

    return false;
  }

}
});

;define.alias('@aurelia/router/hook.js','@aurelia/router/dist/esm/hook.js');
define('@aurelia/router/dist/esm/index.js',['require','exports','module','./link-handler.js','./instruction-resolver.js','./interfaces.js','./lifecycle-logger.js','./hook-manager.js','./nav.js','./nav-route.js','./navigation.js','./navigator.js','./runner.js','./queue.js','./route-recognizer.js','./router.js','./router-options.js','./viewport.js','./viewport-content.js','./viewport-instruction.js','./configuration.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.HrefCustomAttributeRegistration = exports.HrefCustomAttribute = exports.LoadCustomAttributeRegistration = exports.LoadCustomAttribute = exports.GotoCustomAttributeRegistration = exports.GotoCustomAttribute = exports.NavCustomElementRegistration = exports.NavCustomElement = exports.ViewportCustomElementRegistration = exports.ViewportCustomElement = exports.DefaultResources = exports.DefaultComponents = exports.RouterRegistration = exports.RouterConfiguration = exports.ViewportInstruction = exports.ViewportContent = exports.ContentStatus = exports.Viewport = exports.RouterOptions = exports.Router = exports.IRouter = exports.Endpoint = exports.RecognizedRoute = exports.ConfigurableRoute = exports.RouteRecognizer = exports.Queue = exports.Runner = exports.Navigator = exports.Navigation = exports.NavRoute = exports.Nav = exports.HookTypes = exports.HookManager = exports.LifecycleClass = exports.lifecycleLogger = exports.ReentryBehavior = exports.InstructionResolver = exports.LinkHandler = void 0;

var _linkHandler = require("./link-handler.js");

exports.LinkHandler = _linkHandler.LinkHandler;

var _instructionResolver = require("./instruction-resolver.js");

exports.InstructionResolver = _instructionResolver.InstructionResolver;

var _interfaces = require("./interfaces.js");

exports.ReentryBehavior = _interfaces.ReentryBehavior;

var _lifecycleLogger = require("./lifecycle-logger.js");

exports.lifecycleLogger = _lifecycleLogger.lifecycleLogger;
exports.LifecycleClass = _lifecycleLogger.LifecycleClass;

var _hookManager = require("./hook-manager.js");

exports.HookManager = _hookManager.HookManager;
exports.HookTypes = _hookManager.HookTypes;

var _nav = require("./nav.js");

exports.Nav = _nav.Nav;

var _navRoute = require("./nav-route.js");

exports.NavRoute = _navRoute.NavRoute;

var _navigation = require("./navigation.js");

exports.Navigation = _navigation.Navigation;

var _navigator = require("./navigator.js");

exports.Navigator = _navigator.Navigator;

var _runner = require("./runner.js");

exports.Runner = _runner.Runner;

var _queue = require("./queue.js");

exports.Queue = _queue.Queue;

var _routeRecognizer = require("./route-recognizer.js");

exports.RouteRecognizer = _routeRecognizer.RouteRecognizer;
exports.ConfigurableRoute = _routeRecognizer.ConfigurableRoute;
exports.RecognizedRoute = _routeRecognizer.RecognizedRoute;
exports.Endpoint = _routeRecognizer.Endpoint;

var _router = require("./router.js");

exports.IRouter = _router.IRouter;
exports.Router = _router.Router;

var _routerOptions = require("./router-options.js");

exports.RouterOptions = _routerOptions.RouterOptions;

var _viewport = require("./viewport.js");

exports.Viewport = _viewport.Viewport;

var _viewportContent = require("./viewport-content.js");

exports.ContentStatus = _viewportContent.ContentStatus;
exports.ViewportContent = _viewportContent.ViewportContent;

var _viewportInstruction = require("./viewport-instruction.js");

exports.ViewportInstruction = _viewportInstruction.ViewportInstruction;

var _configuration = require("./configuration.js");

exports.RouterConfiguration = _configuration.RouterConfiguration;
exports.RouterRegistration = _configuration.RouterRegistration;
exports.DefaultComponents = _configuration.DefaultComponents;
exports.DefaultResources = _configuration.DefaultResources;
exports.ViewportCustomElement = _configuration.ViewportCustomElement;
exports.ViewportCustomElementRegistration = _configuration.ViewportCustomElementRegistration;
exports.NavCustomElement = _configuration.NavCustomElement;
exports.NavCustomElementRegistration = _configuration.NavCustomElementRegistration;
exports.GotoCustomAttribute = _configuration.GotoCustomAttribute;
exports.GotoCustomAttributeRegistration = _configuration.GotoCustomAttributeRegistration;
exports.LoadCustomAttribute = _configuration.LoadCustomAttribute;
exports.LoadCustomAttributeRegistration = _configuration.LoadCustomAttributeRegistration;
exports.HrefCustomAttribute = _configuration.HrefCustomAttribute;
exports.HrefCustomAttributeRegistration = _configuration.HrefCustomAttributeRegistration;
});

;define.alias('@aurelia/router','@aurelia/router/dist/esm/index.js');
define('@aurelia/router/dist/esm/instruction-resolver.js',['require','exports','module','./viewport-instruction.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.InstructionResolver = void 0;

var _viewportInstruction = require("./viewport-instruction.js");

class InstructionResolver {
  constructor() {
    this.separators = {
      viewport: '@',
      sibling: '+',
      scope: '/',
      scopeStart: '(',
      scopeEnd: ')',
      noScope: '!',
      parameters: '(',
      parametersEnd: ')',
      parameterSeparator: ',',
      parameterKeySeparator: '=',
      parameter: '&',
      add: '+',
      clear: '-',
      action: '.'
    };
  }

  start(options) {
    options = options || {};
    this.separators = { ...this.separators,
      ...options.separators
    };
  }

  get clearViewportInstruction() {
    return this.separators.clear;
  }

  get addViewportInstruction() {
    return this.separators.add;
  }

  isClearViewportInstruction(instruction) {
    return instruction instanceof _viewportInstruction.ViewportInstruction ? instruction.componentName === this.clearViewportInstruction && !!instruction.viewportName : instruction.startsWith(this.clearViewportInstruction) && instruction !== this.clearViewportInstruction;
  }

  isAddViewportInstruction(instruction) {
    return instruction instanceof _viewportInstruction.ViewportInstruction ? instruction.componentName === this.addViewportInstruction : instruction === this.addViewportInstruction || instruction.startsWith(`${this.separators.add}${this.separators.viewport}`);
  }

  isClearViewportScopeInstruction(instruction) {
    return instruction instanceof _viewportInstruction.ViewportInstruction ? instruction.componentName === this.clearViewportInstruction && !!instruction.viewportScope : instruction.startsWith(this.clearViewportInstruction) && instruction !== this.clearViewportInstruction;
  }

  isClearAllViewportsInstruction(instruction) {
    return instruction instanceof _viewportInstruction.ViewportInstruction ? instruction.componentName === this.clearViewportInstruction && !instruction.viewportName : instruction === this.clearViewportInstruction;
  }

  isAddAllViewportsInstruction(instruction) {
    return instruction instanceof _viewportInstruction.ViewportInstruction ? instruction.componentName === this.addViewportInstruction && !instruction.viewportName : instruction === this.addViewportInstruction;
  }

  createViewportInstruction(component, viewport, parameters, ownsScope = true, nextScopeInstructions = null) {
    if (component instanceof Promise) {
      return component.then(resolvedComponent => {
        return this.createViewportInstruction(resolvedComponent, viewport, parameters, ownsScope, nextScopeInstructions);
      });
    } // const instruction: ViewportInstruction = new ViewportInstruction(component, viewport, parameters, ownsScope, nextScopeInstructions);
    // instruction.setInstructionResolver(this);
    // return instruction;


    return _viewportInstruction.ViewportInstruction.create(this, component, viewport, parameters, ownsScope, nextScopeInstructions);
  }

  parseViewportInstructions(instructions) {
    const match = /^[./]+/.exec(instructions);
    let context = '';

    if (Array.isArray(match) && match.length > 0) {
      context = match[0];
      instructions = instructions.slice(context.length);
    }

    const parsedInstructions = this.parseViewportInstructionsWorker(instructions, true).instructions;

    for (const instruction of parsedInstructions) {
      instruction.context = context;
    }

    return parsedInstructions;
  }

  parseViewportInstruction(instruction) {
    const instructions = this.parseViewportInstructions(instruction);

    if (instructions.length) {
      return instructions[0];
    }

    return this.createViewportInstruction('');
  }

  stringifyViewportInstructions(instructions, excludeViewport = false, viewportContext = false) {
    return typeof instructions === 'string' ? instructions : instructions.map(instruction => this.stringifyViewportInstruction(instruction, excludeViewport, viewportContext)).filter(instruction => instruction && instruction.length).join(this.separators.sibling);
  }

  stringifyViewportInstruction(instruction, excludeViewport = false, viewportContext = false) {
    if (typeof instruction === 'string') {
      return this.stringifyAViewportInstruction(instruction, excludeViewport);
    } else {
      let excludeCurrentViewport = excludeViewport;
      let excludeCurrentComponent = false;

      if (viewportContext) {
        if (instruction.viewport && instruction.viewport.options.noLink) {
          return '';
        }

        if (!instruction.needsViewportDescribed && instruction.viewport && !instruction.viewport.options.forceDescription) {
          excludeCurrentViewport = true;
        }

        if (instruction.viewport && instruction.viewport.options.fallback === instruction.componentName) {
          excludeCurrentComponent = true;
        }

        if (!instruction.needsViewportDescribed && instruction.viewportScope) {
          excludeCurrentViewport = true;
        }
      }

      let route = instruction.route ?? null;
      const nextInstructions = instruction.nextScopeInstructions;
      let stringified = instruction.context; // It's a configured route

      if (route !== null) {
        // Already added as part of a configuration, skip to next scope
        if (route === '') {
          return Array.isArray(nextInstructions) ? this.stringifyViewportInstructions(nextInstructions, excludeViewport, viewportContext) : '';
        }

        route = route.matching;
        stringified += route.endsWith(this.separators.scope) ? route.slice(0, -this.separators.scope.length) : route;
      } else {
        stringified += this.stringifyAViewportInstruction(instruction, excludeCurrentViewport, excludeCurrentComponent);
      }

      if (Array.isArray(nextInstructions) && nextInstructions.length) {
        const nextStringified = this.stringifyViewportInstructions(nextInstructions, excludeViewport, viewportContext);

        if (nextStringified.length > 0) {
          stringified += nextInstructions.length === 1 // TODO: This should really also check that the instructions have value
          ? `${this.separators.scope}${nextStringified}` : `${this.separators.scope}${this.separators.scopeStart}${nextStringified}${this.separators.scopeEnd}`;
        }
      }

      return stringified;
    }
  }

  stringifyScopedViewportInstructions(instructions) {
    if (!Array.isArray(instructions)) {
      return this.stringifyScopedViewportInstructions([instructions]);
    }

    return instructions.map(instruction => this.stringifyViewportInstruction(instruction)).join(this.separators.scope);
  }

  encodeViewportInstructions(instructions) {
    return encodeURIComponent(this.stringifyViewportInstructions(instructions)).replace(/\(/g, '%28').replace(/\)/g, '%29');
  }

  decodeViewportInstructions(instructions) {
    return this.parseViewportInstructions(decodeURIComponent(instructions));
  }

  buildScopedLink(scopeContext, href) {
    if (scopeContext) {
      href = `/${scopeContext}${this.separators.scope}${href}`;
    }

    return href;
  }

  shouldClearViewports(path) {
    const clearViewports = path === this.separators.clear || path.startsWith(this.separators.clear + this.separators.add);
    const newPath = path.startsWith(this.separators.clear) ? path.slice(2) : path;
    return {
      clearViewports,
      newPath
    };
  }

  mergeViewportInstructions(instructions) {
    const merged = [];

    for (let instruction of instructions) {
      if (typeof instruction === 'string') {
        instruction = this.parseViewportInstruction(instruction);
      }

      const index = merged.findIndex(merge => merge.sameViewport(instruction));

      if (index >= 0) {
        merged.splice(index, 1, instruction);
      } else {
        merged.push(instruction);
      }
    }

    return merged;
  }

  flattenViewportInstructions(instructions) {
    const flat = [];

    for (const instruction of instructions) {
      flat.push(instruction);

      if (instruction.nextScopeInstructions) {
        flat.push(...this.flattenViewportInstructions(instruction.nextScopeInstructions));
      }
    }

    return flat;
  }

  cloneViewportInstructions(instructions, keepInstances = false, context = false) {
    const clones = [];

    for (const instruction of instructions) {
      const clone = this.createViewportInstruction(instruction.componentName, instruction.viewportName, instruction.typedParameters !== null ? instruction.typedParameters : void 0);

      if (keepInstances) {
        clone.setComponent(instruction.componentInstance ?? instruction.componentType ?? instruction.componentName);
        clone.setViewport(instruction.viewport ?? instruction.viewportName);
      }

      clone.needsViewportDescribed = instruction.needsViewportDescribed;
      clone.route = instruction.route;

      if (context) {
        clone.context = instruction.context;
      }

      clone.viewportScope = keepInstances ? instruction.viewportScope : null;
      clone.scope = keepInstances ? instruction.scope : null;

      if (instruction.nextScopeInstructions) {
        clone.nextScopeInstructions = this.cloneViewportInstructions(instruction.nextScopeInstructions, keepInstances, context);
      }

      clones.push(clone);
    }

    return clones;
  } // TODO: Deal with separators in data and complex types


  parseComponentParameters(parameters, uriComponent = false) {
    if (parameters === undefined || parameters === null || parameters.length === 0) {
      return [];
    }

    if (typeof parameters === 'string') {
      const list = [];
      const params = parameters.split(this.separators.parameterSeparator);

      for (const param of params) {
        let key;
        let value;
        [key, value] = param.split(this.separators.parameterKeySeparator);

        if (value === void 0) {
          value = uriComponent ? decodeURIComponent(key) : key;
          key = void 0;
        } else if (uriComponent) {
          key = decodeURIComponent(key);
          value = decodeURIComponent(value);
        }

        list.push({
          key,
          value
        });
      }

      return list;
    }

    if (Array.isArray(parameters)) {
      return parameters.map(param => ({
        key: void 0,
        value: param
      }));
    }

    const keys = Object.keys(parameters);
    keys.sort();
    return keys.map(key => ({
      key,
      value: parameters[key]
    }));
  } // TODO: Deal with separators in data and complex types


  stringifyComponentParameters(parameters, uriComponent = false) {
    if (!Array.isArray(parameters) || parameters.length === 0) {
      return '';
    }

    const seps = this.separators;
    return parameters.map(param => {
      const key = param.key !== void 0 && uriComponent ? encodeURIComponent(param.key) : param.key;
      const value = uriComponent ? encodeURIComponent(param.value) : param.value;
      return key !== void 0 && key !== value ? key + seps.parameterKeySeparator + value : value;
    }).join(seps.parameterSeparator);
  }

  matchScope(instructions, scope) {
    const matching = [];
    matching.push(...instructions.filter(instruction => instruction.scope === scope));
    matching.push(...instructions.filter(instr => instr.scope !== scope).map(instr => Array.isArray(instr.nextScopeInstructions) ? this.matchScope(instr.nextScopeInstructions, scope) : []).flat());
    return matching;
  }

  matchChildren(instructions, active) {
    for (const instruction of instructions) {
      const matching = active.filter(instr => instr.sameComponent(instruction));

      if (matching.length === 0) {
        return false;
      }

      if (Array.isArray(instruction.nextScopeInstructions) && instruction.nextScopeInstructions.length > 0 && this.matchChildren(instruction.nextScopeInstructions, matching.map(instr => Array.isArray(instr.nextScopeInstructions) ? instr.nextScopeInstructions : []).flat()) === false) {
        return false;
      }
    }

    return true;
  }

  parseViewportInstructionsWorker(instructions, grouped = false) {
    if (!instructions) {
      return {
        instructions: [],
        remaining: ''
      };
    }

    if (instructions.startsWith(this.separators.scopeStart)) {
      instructions = `${this.separators.scope}${instructions}`;
    }

    const viewportInstructions = [];
    let guard = 1000;

    while (instructions.length && guard) {
      guard--;

      if (instructions.startsWith(this.separators.scope)) {
        instructions = instructions.slice(this.separators.scope.length);
        const scopeStart = instructions.startsWith(this.separators.scopeStart);

        if (scopeStart) {
          instructions = instructions.slice(this.separators.scopeStart.length);
        }

        const {
          instructions: found,
          remaining
        } = this.parseViewportInstructionsWorker(instructions, scopeStart);

        if (viewportInstructions.length) {
          viewportInstructions[viewportInstructions.length - 1].nextScopeInstructions = found;
        } else {
          viewportInstructions.push(...found);
        }

        instructions = remaining;
      } else if (instructions.startsWith(this.separators.scopeEnd)) {
        if (grouped) {
          instructions = instructions.slice(this.separators.scopeEnd.length);
        }

        return {
          instructions: viewportInstructions,
          remaining: instructions
        };
      } else if (instructions.startsWith(this.separators.sibling) && !this.isAddViewportInstruction(instructions)) {
        if (!grouped) {
          return {
            instructions: viewportInstructions,
            remaining: instructions
          };
        }

        instructions = instructions.slice(this.separators.sibling.length);
      } else {
        const {
          instruction: viewportInstruction,
          remaining
        } = this.parseAViewportInstruction(instructions);
        viewportInstructions.push(viewportInstruction);
        instructions = remaining;
      }
    }

    return {
      instructions: viewportInstructions,
      remaining: instructions
    };
  }

  findNextToken(instruction, tokens) {
    const matches = {}; // Tokens can have length > 1

    for (const token of tokens) {
      const tokenPos = instruction.indexOf(token);

      if (tokenPos > -1) {
        matches[token] = instruction.indexOf(token);
      }
    }

    const pos = Math.min(...Object.values(matches));

    for (const token in matches) {
      if (matches[token] === pos) {
        return {
          token,
          pos
        };
      }
    }

    return {
      token: '',
      pos: -1
    };
  }

  parseAViewportInstruction(instruction) {
    const seps = this.separators;
    const tokens = [seps.parameters, seps.viewport, seps.noScope, seps.scopeEnd, seps.scope, seps.sibling];
    let component = void 0;
    let parametersString = void 0;
    let viewport = void 0;
    let scope = true;
    let token;
    let pos;
    const specials = [seps.add, seps.clear];

    for (const special of specials) {
      if (instruction === special) {
        component = instruction;
        instruction = '';
        tokens.shift(); // parameters

        tokens.shift(); // viewport

        token = seps.viewport;
        break;
      }
    }

    if (component === void 0) {
      for (const special of specials) {
        if (instruction.startsWith(`${special}${seps.viewport}`)) {
          component = special;
          instruction = instruction.slice(`${special}${seps.viewport}`.length);
          tokens.shift(); // parameters

          tokens.shift(); // viewport

          token = seps.viewport;
          break;
        }
      }
    }

    if (component === void 0) {
      ({
        token,
        pos
      } = this.findNextToken(instruction, tokens));
      component = pos !== -1 ? instruction.slice(0, pos) : instruction;
      instruction = pos !== -1 ? instruction.slice(pos + token.length) : '';
      tokens.shift(); // parameters

      if (token === seps.parameters) {
        ({
          token,
          pos
        } = this.findNextToken(instruction, [seps.parametersEnd]));
        parametersString = instruction.slice(0, pos);
        instruction = instruction.slice(pos + token.length);
        ({
          token
        } = this.findNextToken(instruction, tokens));
        instruction = instruction.slice(token.length);
      }

      tokens.shift(); // viewport
    }

    if (token === seps.viewport) {
      ({
        token,
        pos
      } = this.findNextToken(instruction, tokens));
      viewport = pos !== -1 ? instruction.slice(0, pos) : instruction;
      instruction = pos !== -1 ? instruction.slice(pos + token.length) : '';
    }

    tokens.shift(); // noScope

    if (token === seps.noScope) {
      scope = false;
    } // Restore token that belongs to next instruction


    if (token === seps.scopeEnd || token === seps.scope || token === seps.sibling) {
      instruction = `${token}${instruction}`;
    }

    const viewportInstruction = this.createViewportInstruction(component, viewport, parametersString, scope);
    return {
      instruction: viewportInstruction,
      remaining: instruction
    };
  }

  stringifyAViewportInstruction(instruction, excludeViewport = false, excludeComponent = false) {
    if (typeof instruction === 'string') {
      return this.stringifyViewportInstruction(this.parseViewportInstruction(instruction), excludeViewport, excludeComponent);
    } else {
      let instructionString = !excludeComponent ? instruction.componentName : '';
      const specification = instruction.componentType ? instruction.componentType.parameters : null;
      const parameters = this.stringifyComponentParameters(instruction.toSortedParameters(specification));

      if (parameters.length > 0) {
        instructionString += !excludeComponent ? `${this.separators.parameters}${parameters}${this.separators.parametersEnd}` : parameters;
      }

      if (instruction.viewportName !== null && !excludeViewport) {
        instructionString += this.separators.viewport + instruction.viewportName;
      }

      if (!instruction.ownsScope) {
        instructionString += this.separators.noScope;
      }

      return instructionString || '';
    }
  }

}

exports.InstructionResolver = InstructionResolver;
});

;define.alias('@aurelia/router/instruction-resolver.js','@aurelia/router/dist/esm/instruction-resolver.js');
define('@aurelia/router/dist/esm/interfaces.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.ReentryBehavior = void 0;
var ReentryBehavior;
exports.ReentryBehavior = ReentryBehavior;

(function (ReentryBehavior) {
  ReentryBehavior["default"] = "default";
  ReentryBehavior["disallow"] = "disallow";
  ReentryBehavior["load"] = "load";
  ReentryBehavior["refresh"] = "refresh";
})(ReentryBehavior || (exports.ReentryBehavior = ReentryBehavior = {}));
});

;define.alias('@aurelia/router/interfaces.js','@aurelia/router/dist/esm/interfaces.js');
define('@aurelia/router/dist/esm/lifecycle-logger.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.lifecycleLogger = lifecycleLogger;
exports.LifecycleClass = void 0;

/**
 * @internal - Will be removed
 */
function lifecycleLogger(name) {
  const lifecycles = ['canUnload', 'unload', 'canLoad', 'load', 'created', 'binding', 'bound', 'beforeAttach', 'attaching', 'detaching', 'unbinding'];
  return function (target) {
    for (const lifecycle of lifecycles) {
      const existing = target.prototype[lifecycle];

      if (existing !== void 0) {
        target.prototype[lifecycle] = function (...args) {
          console.log(`${name} ${lifecycle}`, args);
          return existing.apply(target, args);
        };
      } else {
        target.prototype[lifecycle] = function (...args) {
          console.log(`${name} ${lifecycle}`, args);

          if (lifecycle.startsWith('can')) {
            return true;
          }
        };
      }
    }
  };
}

class LifecycleClass {
  canLoad() {
    console.log(`name canLoad`);
    return true;
  }

  load(params) {
    console.log(`name load`);
  }

  created() {
    console.log(`name created`);
  }

  binding() {
    console.log(`name binding`);
  }

  bound() {
    console.log(`name bound`);
  }

  beforeAttach() {
    console.log(`name beforeAttach`);
  }

  attaching() {
    console.log(`name attaching`);
  }

  canUnload() {
    console.log(`name canUnload`);
    return true;
  }

  unload() {
    console.log(`name unload`);
  }

  detaching() {
    console.log(`name detaching`);
  }

  unbinding() {
    console.log(`name unbinding`);
  }

}

exports.LifecycleClass = LifecycleClass;
});

;define.alias('@aurelia/router/lifecycle-logger.js','@aurelia/router/dist/esm/lifecycle-logger.js');
define('@aurelia/router/dist/esm/link-handler.js',['require','exports','module','@aurelia/runtime-html'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.LinkHandler = void 0;

var _runtimeHtml = require("@aurelia/runtime-html");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

/**
 * Class responsible for handling interactions that should trigger navigation.
 *
 * @ internal - Shouldn't be used directly.
 * TODO: remove the space between @ and i again at some point (this stripInternal currently screws up the types in the __tests__ package for some reason)
 */
let LinkHandler = class LinkHandler {
  constructor(p) {
    this.options = {
      useHref: true,
      callback: () => {
        return;
      }
    };
    this.isActive = false;

    this.handler = e => {
      const info = LinkHandler.getEventInfo(e, this.window, this.options);

      if (info.shouldHandleEvent) {
        e.preventDefault();
        this.options.callback(info);
      }
    };

    this.window = p.window;
    this.document = p.document;
  }
  /**
   * Gets the href and a "should handle" recommendation, given an Event.
   *
   * @param event - The Event to inspect for target anchor and href.
   */


  static getEventInfo(event, win, options) {
    const info = {
      shouldHandleEvent: false,
      instruction: null,
      anchor: null
    };
    const target = info.anchor = event.currentTarget; // Switch to this for delegation:
    // const target = info.anchor = LinkHandler.closestAnchor(event.target as Element);

    if (!target || !LinkHandler.targetIsThisWindow(target, win)) {
      return info;
    }

    if (target.hasAttribute('external')) {
      return info;
    }

    if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {
      return info;
    }

    const gotoAttr = _runtimeHtml.CustomAttribute.for(target, 'goto');

    const goto = gotoAttr !== void 0 ? gotoAttr.viewModel.value : null;

    const loadAttr = _runtimeHtml.CustomAttribute.for(target, 'load');

    const load = loadAttr !== void 0 ? loadAttr.viewModel.value : null;
    const href = options.useHref && target.hasAttribute('href') ? target.getAttribute('href') : null;

    if ((goto === null || goto.length === 0) && (load === null || load.length === 0) && (href === null || href.length === 0)) {
      return info;
    }

    info.anchor = target;
    info.instruction = load ?? goto ?? href;
    const leftButtonClicked = event.button === 0;
    info.shouldHandleEvent = leftButtonClicked;
    return info;
  }
  /**
   * Finds the closest ancestor that's an anchor element.
   *
   * @param el - The element to search upward from.
   * @returns The link element that is the closest ancestor.
   */
  // private static closestAnchor(el: Element): Element | null {
  //   while (el !== null && el !== void 0) {
  //     if (el.tagName === 'A') {
  //       return el;
  //     }
  //     el = el.parentNode as Element;
  //   }
  //   return null;
  // }

  /**
   * Gets a value indicating whether or not an anchor targets the current window.
   *
   * @param target - The anchor element whose target should be inspected.
   * @returns True if the target of the link element is this window; false otherwise.
   */


  static targetIsThisWindow(target, win) {
    const targetWindow = target.getAttribute('target');
    return !targetWindow || targetWindow === win.name || targetWindow === '_self';
  }
  /**
   * Start the instance.
   *
   */


  start(options) {
    if (this.isActive) {
      throw new Error('Link handler has already been started');
    }

    this.isActive = true;
    this.options = { ...options
    };
  }
  /**
   * Stop the instance. Event handlers and other resources should be cleaned up here.
   */


  stop() {
    if (!this.isActive) {
      throw new Error('Link handler has not been started');
    }

    this.isActive = false;
  }

};
exports.LinkHandler = LinkHandler;
exports.LinkHandler = LinkHandler = __decorate([__param(0, _runtimeHtml.IPlatform)], LinkHandler);
});

;define.alias('@aurelia/router/link-handler.js','@aurelia/router/dist/esm/link-handler.js');
define('@aurelia/router/dist/esm/nav-route.js',['require','exports','module','./type-resolvers.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.NavRoute = void 0;

var _typeResolvers = require("./type-resolvers.js");

/**
 * @internal - Used by au-nav
 */
class NavRoute {
  constructor(nav, route) {
    this.nav = nav;
    this.instructions = [];
    this.link = null;
    this.linkVisible = null;
    this.linkActive = null;
    this.compareParameters = false;
    this.children = null;
    this.visible = true;
    this.active = '';
    this.title = route.title;
    this.meta = route.meta;

    if (route.route) {
      this.instructions = this.parseRoute(route.route);
      this.link = this.computeLink(this.instructions);
    }

    this.linkActive = route.consideredActive !== null && route.consideredActive !== void 0 ? route.consideredActive : this.link;

    if (this.linkActive !== null && (!(this.linkActive instanceof Function) || _typeResolvers.ComponentAppellationResolver.isType(this.linkActive))) {
      this.linkActive = _typeResolvers.NavigationInstructionResolver.toViewportInstructions(this.nav.router, this.linkActive);
    }

    this.execute = route.execute;
    this.compareParameters = !!route.compareParameters;
    this.linkVisible = route.condition === undefined ? true : route.condition;
    this.update();
  }

  get hasChildren() {
    return this.children && this.children.length ? 'nav-has-children' : '';
  }

  update() {
    this.visible = this.computeVisible();

    if (this.link && this.link.length || this.execute) {
      this.active = this.computeActive();
    } else {
      this.active = this.active === 'nav-active' ? 'nav-active' : this.activeChild() ? 'nav-active-child' : '';
    }
  }

  executeAction(event) {
    if (this.execute) {
      this.execute(this);
    }

    event.stopPropagation();
  }

  toggleActive() {
    this.active = this.active.startsWith('nav-active') ? '' : 'nav-active';
  }

  parseRoute(routes) {
    return _typeResolvers.NavigationInstructionResolver.toViewportInstructions(this.nav.router, routes);
  }

  computeVisible() {
    if (this.linkVisible instanceof Function) {
      return this.linkVisible(this);
    }

    return !!this.linkVisible;
  }

  computeActive() {
    if (!Array.isArray(this.linkActive)) {
      return this.linkActive(this) ? 'nav-active' : '';
    }

    const components = this.linkActive;
    const activeComponents = this.nav.router.instructionResolver.flattenViewportInstructions(this.nav.router.activeComponents);

    for (const component of components) {
      if (activeComponents.every(active => !active.sameComponent(component, this.compareParameters && component.typedParameters !== null))) {
        return '';
      }
    }

    return 'nav-active';
  }

  computeLink(instructions) {
    return this.nav.router.instructionResolver.stringifyViewportInstructions(instructions);
  }

  activeChild() {
    if (this.children) {
      for (const child of this.children) {
        if (child.active.startsWith('nav-active') || child.activeChild()) {
          return true;
        }
      }
    }

    return false;
  }

}

exports.NavRoute = NavRoute;
});

;define.alias('@aurelia/router/nav-route.js','@aurelia/router/dist/esm/nav-route.js');
define('@aurelia/router/dist/esm/nav.js',['require','exports','module','./nav-route.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.Nav = void 0;

var _navRoute = require("./nav-route.js");

/**
 * Public API - Used by au-nav and Router add/setNav
 */
class Nav {
  constructor(router, name, routes = [], classes = {}) {
    this.router = router;
    this.name = name;
    this.routes = routes;
    this.classes = classes;
    this.update();
  }

  addRoutes(routes) {
    for (const route of routes) {
      this.addRoute(this.routes, route);
    }

    this.update();
  }

  update() {
    this.updateRoutes(this.routes);
    this.routes = this.routes.slice();
  }

  addRoute(routes, route) {
    const newRoute = new _navRoute.NavRoute(this, route);
    routes.push(newRoute);

    if (route.children) {
      newRoute.children = [];

      for (const child of route.children) {
        this.addRoute(newRoute.children, child);
      }
    }
  }

  updateRoutes(routes) {
    for (const route of routes) {
      route.update();

      if (route.children && route.children.length) {
        this.updateRoutes(route.children);
      }
    }
  }

}

exports.Nav = Nav;
});

;define.alias('@aurelia/router/nav.js','@aurelia/router/dist/esm/nav.js');
define('@aurelia/router/dist/esm/navigation-coordinator.js',['require','exports','module','./state-coordinator.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.NavigationCoordinator = exports.NavigationCoordinatorOptions = void 0;

var _stateCoordinator = require("./state-coordinator.js");

class NavigationCoordinatorOptions {
  constructor(input) {
    // console.log('NavigationCoordinatorOptions constructor', input);
    this.syncStates = input.syncStates ?? [];
  }

}

exports.NavigationCoordinatorOptions = NavigationCoordinatorOptions;

class NavigationCoordinator extends _stateCoordinator.StateCoordinator {
  constructor() {
    super(...arguments);
    this.running = false;
  }

  static create(router, navigation, options) {
    const coordinator = new NavigationCoordinator();
    coordinator.router = router;
    coordinator.navigation = navigation; // TODO: Set flow options from router

    options.syncStates.forEach(state => coordinator.addSyncState(state)); // console.log('NavigationCoordinator created', coordinator);

    return coordinator;
  } // public get isRestrictedNavigation(): boolean {
  //   return this.syncStates.has('guardedLoad') ||
  //     this.syncStates.has('unloaded') ||
  //     this.syncStates.has('loaded') ||
  //     this.syncStates.has('guarded') ||
  //     this.syncStates.has('routed');
  // }


  run() {
    if (!this.running) {
      // console.log('NavigationCoordinator RUN' /*, { ...this } */);
      this.running = true;

      for (const entity of this.entities) {
        if (!entity.running) {
          entity.running = true;
          entity.entity.transition(this);
        }
      }
    }
  }

  addEntity(entity) {
    const ent = super.addEntity(entity);

    if (this.running) {
      ent.entity.transition(this);
    }

    return ent;
  }

  finalize() {
    this.entities.forEach(entity => entity.entity.finalizeContentChange());
  }

  cancel() {
    // TODO: Take care of disabling viewports when cancelling and stateful!
    this.entities.forEach(entity => {
      const abort = entity.entity.abortContentChange();

      if (abort instanceof Promise) {
        abort.catch(error => {
          throw error;
        });
      }
    });
    this.router.navigator.cancel(this.navigation).then(() => {
      this.router.processingNavigation = null;
      this.navigation.resolve();
    }).catch(error => {
      throw error;
    });
  } // A new navigation should cancel replaced instructions
  // eslint-disable-next-line @typescript-eslint/no-empty-function


  cancelReplaced(navigation) {}

}

exports.NavigationCoordinator = NavigationCoordinator;
});

;define.alias('@aurelia/router/navigation-coordinator.js','@aurelia/router/dist/esm/navigation-coordinator.js');
define('@aurelia/router/dist/esm/navigation.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.Navigation = void 0;

class Navigation {
  constructor(entry = {
    instruction: '',
    fullStateInstruction: ''
  }) {
    this.navigation = entry.navigation ?? {
      first: false,
      new: false,
      refresh: false,
      forward: false,
      back: false,
      replace: false
    };
    this.repeating = entry.repeating; // INavigatorEntry

    this.fromBrowser = entry.fromBrowser;
    this.origin = entry.origin;
    this.replacing = entry.replacing;
    this.refreshing = entry.refreshing;
    this.untracked = entry.untracked;
    this.historyMovement = entry.historyMovement;
    this.resolve = entry.resolve;
    this.reject = entry.reject; // IStoredNavigatorEntry

    this.instruction = entry.instruction;
    this.fullStateInstruction = entry.fullStateInstruction;
    this.scope = entry.scope;
    this.index = entry.index;
    this.firstEntry = entry.firstEntry;
    this.route = entry.route;
    this.path = entry.path;
    this.title = entry.title;
    this.query = entry.query;
    this.parameters = entry.parameters;
    this.data = entry.data;
  }

  get useFullStateInstruction() {
    return (this.navigation.back ?? false) || (this.navigation.forward ?? false);
  }

  toStored() {
    return {
      navigation: this.navigation,
      repeating: this.repeating,
      // IStoredNavigatorEntry
      instruction: this.instruction,
      fullStateInstruction: this.fullStateInstruction,
      scope: this.scope,
      index: this.index,
      firstEntry: this.firstEntry,
      route: this.route,
      path: this.path,
      title: this.title,
      query: this.query,
      parameters: this.parameters,
      data: this.data
    };
  }

}

exports.Navigation = Navigation;
});

;define.alias('@aurelia/router/navigation.js','@aurelia/router/dist/esm/navigation.js');
define('@aurelia/router/dist/esm/navigator.js',['require','exports','module','./queue.js','./navigation.js','./runner.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.Navigator = void 0;

var _queue = require("./queue.js");

var _navigation = require("./navigation.js");

var _runner = require("./runner.js");

/**
 * @internal - Shouldn't be used directly
 */
class Navigator {
  constructor() {
    this.entries = [];
    this.options = {
      statefulHistoryLength: 0
    };
    this.isActive = false;

    this.processNavigations = qEntry => {
      const entry = qEntry;
      const navigationFlags = {
        first: false,
        new: false,
        refresh: false,
        forward: false,
        back: false,
        replace: false
      };

      if (this.currentEntry === this.uninitializedEntry) {
        // Refresh or first entry
        this.loadState();

        if (this.currentEntry !== this.uninitializedEntry) {
          navigationFlags.refresh = true;
        } else {
          navigationFlags.first = true;
          navigationFlags.new = true; // TODO: Should this really be created here? Shouldn't it be in the viewer?

          this.currentEntry = new _navigation.Navigation({
            index: 0,
            instruction: '',
            fullStateInstruction: ''
          });
          this.entries = [];
        }
      }

      if (entry.index !== void 0 && !entry.replacing && !entry.refreshing) {
        // History navigation
        entry.historyMovement = entry.index - (this.currentEntry.index !== void 0 ? this.currentEntry.index : 0);
        entry.instruction = this.entries[entry.index] !== void 0 && this.entries[entry.index] !== null ? this.entries[entry.index].fullStateInstruction : entry.fullStateInstruction;
        entry.replacing = true;

        if (entry.historyMovement > 0) {
          navigationFlags.forward = true;
        } else if (entry.historyMovement < 0) {
          navigationFlags.back = true;
        }
      } else if (entry.refreshing || navigationFlags.refresh) {
        // Refreshing
        entry.index = this.currentEntry.index;
      } else if (entry.replacing) {
        // Replacing
        navigationFlags.replace = true;
        navigationFlags.new = true;
        entry.index = this.currentEntry.index;
      } else {
        // New entry
        navigationFlags.new = true;
        entry.index = this.currentEntry.index !== void 0 ? this.currentEntry.index + 1 : this.entries.length;
      }

      this.invokeCallback(entry, navigationFlags, this.currentEntry);
    };

    this.uninitializedEntry = new _navigation.Navigation({
      instruction: 'NAVIGATOR UNINITIALIZED',
      fullStateInstruction: ''
    });
    this.currentEntry = this.uninitializedEntry;
    this.pendingNavigations = new _queue.Queue(this.processNavigations);
  }

  get queued() {
    return this.pendingNavigations.length;
  }

  start(router, options) {
    if (this.isActive) {
      throw new Error('Navigator has already been started');
    }

    this.isActive = true;
    this.router = router;
    this.options = { ...options
    };
  }

  stop() {
    if (!this.isActive) {
      throw new Error('Navigator has not been started');
    }

    this.pendingNavigations.clear();
    this.isActive = false;
  }

  async navigate(entry) {
    return this.pendingNavigations.enqueue(entry);
  }

  async refresh() {
    const entry = this.currentEntry;

    if (entry === this.uninitializedEntry) {
      return Promise.reject();
    }

    entry.replacing = true;
    entry.refreshing = true;
    return this.navigate(entry);
  }

  async go(movement) {
    const newIndex = (this.currentEntry.index !== undefined ? this.currentEntry.index : 0) + movement;

    if (newIndex >= this.entries.length) {
      return Promise.reject();
    }

    const entry = this.entries[newIndex];
    return this.navigate(entry);
  }

  async setEntryTitle(title) {
    this.currentEntry.title = title;
    return this.saveState();
  }

  get titles() {
    if (this.currentEntry === this.uninitializedEntry) {
      return [];
    }

    const index = this.currentEntry.index !== void 0 ? this.currentEntry.index : 0;
    return this.entries.slice(0, index + 1).filter(value => !!value.title).map(value => value.title ? value.title : '');
  } // Get the stored navigator state (json okay)


  getState() {
    const state = this.options.store ? { ...this.options.store.state
    } : {};
    const entries = state.entries ?? [];
    const currentEntry = state.currentEntry ?? null;
    return {
      state,
      entries,
      currentEntry
    };
  } // Load a stored state into Navigation entries


  loadState() {
    const state = this.getState();
    this.entries = state.entries.map(entry => new _navigation.Navigation(entry));
    this.currentEntry = state.currentEntry !== null ? new _navigation.Navigation(state.currentEntry) : this.uninitializedEntry;
  } // Save storeable versions of Navigation entries


  async saveState(push = false) {
    if (this.currentEntry === this.uninitializedEntry) {
      return Promise.resolve();
    }

    const storedEntry = this.currentEntry.toStored();
    this.entries[storedEntry.index !== void 0 ? storedEntry.index : 0] = new _navigation.Navigation(storedEntry); // If preserving history, serialize entries that aren't preserved

    if (this.options.statefulHistoryLength > 0) {
      const index = this.entries.length - this.options.statefulHistoryLength;

      for (let i = 0; i < index; i++) {
        const entry = this.entries[i];

        if (typeof entry.instruction !== 'string' || typeof entry.fullStateInstruction !== 'string') {
          await this.serializeEntry(entry, this.entries.slice(index));
        }
      }
    }

    if (!this.options.store) {
      return Promise.resolve();
    }

    const state = {
      entries: (this.entries ?? []).map(entry => this.toStoreableEntry(entry)),
      currentEntry: this.toStoreableEntry(storedEntry)
    }; // for (const entry of this.entries) {
    //   state.entries.push(this.toStoreableEntry(entry));
    // }

    if (state.currentEntry.title !== void 0) {
      this.options.store.setTitle(state.currentEntry.title);
    }

    if (push) {
      return this.options.store.pushNavigatorState(state);
    } else {
      return this.options.store.replaceNavigatorState(state);
    }
  }

  toStoredEntry(entry) {
    const {
      previous,
      fromBrowser,
      origin,
      replacing,
      refreshing,
      untracked,
      historyMovement,
      navigation,
      scope,
      resolve,
      reject,
      ...storableEntry
    } = entry;
    return storableEntry;
  }

  async finalize(instruction) {
    this.currentEntry = instruction;
    let index = this.currentEntry.index !== undefined ? this.currentEntry.index : 0;

    if (this.currentEntry.untracked) {
      if (instruction.fromBrowser && this.options.store) {
        await this.options.store.popNavigatorState();
      }

      index--;
      this.currentEntry.index = index;
      this.entries[index] = this.currentEntry;
      await this.saveState();
    } else if (this.currentEntry.replacing) {
      this.entries[index] = this.currentEntry;
      await this.saveState();
    } else {
      // New entry (add and discard later entries)
      if (this.options.serializeCallback !== void 0 && this.options.statefulHistoryLength > 0) {
        // Need to clear the instructions we discard!
        const indexPreserve = this.entries.length - this.options.statefulHistoryLength;

        for (const entry of this.entries.slice(index)) {
          if (typeof entry.instruction !== 'string' || typeof entry.fullStateInstruction !== 'string') {
            await this.options.serializeCallback(entry, this.entries.slice(indexPreserve, index));
          }
        }
      }

      this.entries = this.entries.slice(0, index);
      this.entries.push(this.currentEntry);
      await this.saveState(true);
    }

    if (this.currentEntry.resolve) {
      this.currentEntry.resolve();
    }
  }

  async cancel(instruction) {
    if (instruction.fromBrowser && this.options.store) {
      if (instruction.navigation && instruction.navigation.new) {
        await this.options.store.popNavigatorState();
      } else {
        await this.options.store.go(-(instruction.historyMovement || 0), true);
      }
    }

    if (this.currentEntry.resolve) {
      this.currentEntry.resolve();
    }
  }

  invokeCallback(entry, navigationFlags, previousEntry) {
    const instruction = new _navigation.Navigation({ ...entry
    });
    instruction.navigation = navigationFlags;
    instruction.previous = previousEntry;

    if (this.options.callback) {
      this.options.callback(instruction);
    }
  }

  toStoreableEntry(entry) {
    const storeable = entry instanceof _navigation.Navigation ? entry.toStored() : entry;
    storeable.instruction = this.router.instructionResolver.stringifyViewportInstructions(storeable.instruction);
    storeable.fullStateInstruction = this.router.instructionResolver.stringifyViewportInstructions(storeable.fullStateInstruction);

    if (typeof storeable.scope !== 'string') {
      storeable.scope = null;
    }

    return storeable;
  }

  async serializeEntry(entry, preservedEntries) {
    const instructionResolver = this.router.instructionResolver;
    let excludeComponents = []; // Components in preserved entries should not be serialized/freed

    for (const preservedEntry of preservedEntries) {
      if (typeof preservedEntry.instruction !== 'string') {
        excludeComponents.push(...instructionResolver.flattenViewportInstructions(preservedEntry.instruction).filter(instruction => instruction.viewport !== null).map(instruction => instruction.componentInstance));
      }

      if (typeof preservedEntry.fullStateInstruction !== 'string') {
        excludeComponents.push(...instructionResolver.flattenViewportInstructions(preservedEntry.fullStateInstruction).filter(instruction => instruction.viewport !== null).map(instruction => instruction.componentInstance));
      }
    } // Make unique


    excludeComponents = excludeComponents.filter((component, i, arr) => component !== null && arr.indexOf(component) === i);
    let instructions = []; // The instructions, one or two, with possible components to free

    if (typeof entry.fullStateInstruction !== 'string') {
      instructions.push(...entry.fullStateInstruction);
      entry.fullStateInstruction = instructionResolver.stringifyViewportInstructions(entry.fullStateInstruction);
    }

    if (typeof entry.instruction !== 'string') {
      instructions.push(...entry.instruction);
      entry.instruction = instructionResolver.stringifyViewportInstructions(entry.instruction);
    } // Process only those with instances and make unique


    instructions = instructions.filter((instruction, i, arr) => instruction !== null && instruction.componentInstance !== null && arr.indexOf(instruction) === i); // Already freed components (updated when component is freed)

    const alreadyDone = [];

    for (const instruction of instructions) {
      await this.freeInstructionComponents(instruction, excludeComponents, alreadyDone);
    }
  }

  freeInstructionComponents(instruction, excludeComponents, alreadyDone) {
    const component = instruction.componentInstance;
    const viewport = instruction.viewport;

    if (component === null || viewport === null || alreadyDone.some(done => done === component)) {
      return;
    }

    if (!excludeComponents.some(exclude => exclude === component)) {
      return _runner.Runner.run(() => viewport.freeContent(component), () => {
        alreadyDone.push(component);
      });
    }

    if (instruction.nextScopeInstructions !== null) {
      for (const nextInstruction of instruction.nextScopeInstructions) {
        return _runner.Runner.run(() => this.freeInstructionComponents(nextInstruction, excludeComponents, alreadyDone));
      }
    }
  }

}

exports.Navigator = Navigator;
});

;define.alias('@aurelia/router/navigator.js','@aurelia/router/dist/esm/navigator.js');
define('@aurelia/router/dist/esm/open-promise.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.OpenPromise = void 0;

class OpenPromise {
  constructor() {
    this.isPending = true;
    this.promise = new Promise((res, rej) => {
      this.res = res;
      this.rej = rej;
    });
  }

  resolve(value) {
    this.res(value);
    this.isPending = false;
  }

  reject(value) {
    this.rej(value);
    this.isPending = false;
  }

}

exports.OpenPromise = OpenPromise;
});

;define.alias('@aurelia/router/open-promise.js','@aurelia/router/dist/esm/open-promise.js');
define('@aurelia/router/dist/esm/parser.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.parseQuery = parseQuery;

/**
 * @internal - Shouldn't be used directly
 */
function parseQuery(query) {
  if (!query || !query.length) {
    return {};
  }

  const parameters = {}; // TODO: Deal with complex parameters such as lists and objects

  const params = query.replace('+', ' ').split('&');

  for (const param of params) {
    const [key, value] = param.split('=');
    parameters[decodeURIComponent(key)] = decodeURIComponent(value !== void 0 ? value : key);
  }

  return parameters;
}
});

;define.alias('@aurelia/router/parser.js','@aurelia/router/dist/esm/parser.js');
define('@aurelia/router/dist/esm/queue.js',['require','exports','module','@aurelia/kernel'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.Queue = void 0;

var _kernel = require("@aurelia/kernel");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * A first-in-first-out queue that only processes the next queued item
 * when the current one has been resolved or rejected. Sends queued items
 * one at a time to a specified callback function. The callback function
 * should resolve or reject the queued item when processing is done.
 * Enqueued items can be awaited. Enqueued items can specify an (arbitrary)
 * execution cost and the queue can be set up (started) to only process
 * a specific amount of execution cost per RAF/tick.
 *
 * @internal - Shouldn't be used directly.
 */
class Queue {
  constructor(callback) {
    this.callback = callback;
    this.pending = [];
    this.processing = null;
    this.allowedExecutionCostWithinTick = null;
    this.currentExecutionCostInCurrentTick = 0;
    this.platform = null;
    this.task = null;
  }

  get isActive() {
    return this.task !== null;
  }

  get length() {
    return this.pending.length;
  }

  start(options) {
    if (this.isActive) {
      throw new Error('Queue has already been started');
    }

    this.platform = options.platform;
    this.allowedExecutionCostWithinTick = options.allowedExecutionCostWithinTick;
    this.task = this.platform.domWriteQueue.queueTask(this.dequeue, {
      persistent: true
    });
  }

  stop() {
    if (!this.isActive) {
      throw new Error('Queue has not been started');
    }

    this.task.cancel();
    this.task = null;
    this.allowedExecutionCostWithinTick = null;
    this.clear();
  }

  enqueue(itemOrItems, costOrCosts) {
    const list = Array.isArray(itemOrItems);
    const items = list ? itemOrItems : [itemOrItems];
    const costs = items.map((value, index) => !Array.isArray(costOrCosts) ? costOrCosts : costOrCosts[index]).map(value => value !== undefined ? value : 1);
    const promises = [];

    for (const item of items) {
      const qItem = { ...item
      };
      qItem.cost = costs.shift();
      promises.push(new Promise((resolve, reject) => {
        qItem.resolve = () => {
          resolve();
          this.processing = null;
          this.dequeue();
        };

        qItem.reject = reason => {
          reject(reason);
          this.processing = null;
          this.dequeue();
        };
      }));
      this.pending.push(qItem);
    }

    this.dequeue();
    return list ? promises : promises[0];
  }

  dequeue(delta) {
    if (this.processing !== null) {
      return;
    }

    if (delta !== undefined) {
      this.currentExecutionCostInCurrentTick = 0;
    }

    if (!this.pending.length) {
      return;
    }

    if (this.allowedExecutionCostWithinTick !== null && delta === undefined && this.currentExecutionCostInCurrentTick + (this.pending[0].cost || 0) > this.allowedExecutionCostWithinTick) {
      return;
    }

    this.processing = this.pending.shift() || null;

    if (this.processing) {
      this.currentExecutionCostInCurrentTick += this.processing.cost || 0;
      this.callback(this.processing);
    }
  }

  clear() {
    this.pending.splice(0, this.pending.length);
  }

}

exports.Queue = Queue;

__decorate([_kernel.bound], Queue.prototype, "dequeue", null);
});

;define.alias('@aurelia/router/queue.js','@aurelia/router/dist/esm/queue.js');
define('@aurelia/router/dist/esm/resources/goto.js',['require','exports','module','@aurelia/runtime-html','../router.js','../type-resolvers.js','../utils.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.GotoCustomAttribute = void 0;

var _runtimeHtml = require("@aurelia/runtime-html");

var _router = require("../router.js");

var _typeResolvers = require("../type-resolvers.js");

var _utils = require("../utils.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

let GotoCustomAttribute = class GotoCustomAttribute {
  constructor(element, router) {
    this.element = element;
    this.router = router;
    this.hasHref = null;
    this.activeClass = 'goto-active';
    (0, _utils.deprecationWarning)('"goto" custom attribute', '"load" custom attribute');
  }

  binding() {
    this.element.addEventListener('click', this.router.linkHandler.handler);
    this.updateValue();
    const observerLocator = this.router.container.get(_runtimeHtml.IObserverLocator);
    this.observer = observerLocator.getObserver(this.router, 'activeComponents');
    this.observer.subscribe(this);
  }

  unbinding() {
    this.element.removeEventListener('click', this.router.linkHandler.handler);
    this.observer.unsubscribe(this);
  }

  valueChanged(newValue) {
    this.updateValue();
  }

  updateValue() {
    if (this.hasHref === null) {
      this.hasHref = this.element.hasAttribute('href');
    }

    if (!this.hasHref) {
      // TODO: Figure out a better value here for non-strings (using InstructionResolver?)
      const value = typeof this.value === 'string' ? this.value : JSON.stringify(this.value);
      this.element.setAttribute('href', value);
    }
  }

  handleChange() {
    const controller = _runtimeHtml.CustomAttribute.for(this.element, 'goto').parent;

    const created = _typeResolvers.NavigationInstructionResolver.createViewportInstructions(this.router, this.value, {
      context: controller
    });

    const instructions = _typeResolvers.NavigationInstructionResolver.toViewportInstructions(this.router, created.instructions);

    for (const instruction of instructions) {
      if (instruction.scope === null) {
        instruction.scope = created.scope;
      }
    } // TODO: Use router configuration for class name and update target


    if (this.router.checkActive(instructions)) {
      this.element.classList.add(this.activeClass);
    } else {
      this.element.classList.remove(this.activeClass);
    }
  }

};
exports.GotoCustomAttribute = GotoCustomAttribute;

__decorate([(0, _runtimeHtml.bindable)({
  mode: _runtimeHtml.BindingMode.toView
})], GotoCustomAttribute.prototype, "value", void 0);

exports.GotoCustomAttribute = GotoCustomAttribute = __decorate([(0, _runtimeHtml.customAttribute)('goto'), __param(0, _runtimeHtml.INode), __param(1, _router.IRouter)], GotoCustomAttribute);
});

;define.alias('@aurelia/router/resources/goto.js','@aurelia/router/dist/esm/resources/goto.js');
define('@aurelia/router/dist/esm/resources/href.js',['require','exports','module','@aurelia/runtime-html','../router.js','../configuration.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.HrefCustomAttribute = void 0;

var _runtimeHtml = require("@aurelia/runtime-html");

var _router = require("../router.js");

var _configuration = require("../configuration.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

let HrefCustomAttribute = class HrefCustomAttribute {
  constructor(element, router) {
    this.element = element;
    this.router = router;
  }

  binding() {
    if (this.router.options.useHref && !this.hasGoto()) {
      this.element.addEventListener('click', this.router.linkHandler.handler);
    }

    this.updateValue();
  }

  unbinding() {
    this.element.removeEventListener('click', this.router.linkHandler.handler);
  }

  valueChanged() {
    this.updateValue();
  }

  updateValue() {
    this.element.setAttribute('href', this.value);
  }

  hasGoto() {
    const parent = this.$controller.parent;
    const siblings = parent.children;
    return siblings !== null && siblings.some(c => c.vmKind === 1
    /* customAttribute */
    && c.viewModel instanceof _configuration.GotoCustomAttribute);
  }

};
exports.HrefCustomAttribute = HrefCustomAttribute;

__decorate([(0, _runtimeHtml.bindable)({
  mode: _runtimeHtml.BindingMode.toView
})], HrefCustomAttribute.prototype, "value", void 0);

exports.HrefCustomAttribute = HrefCustomAttribute = __decorate([(0, _runtimeHtml.customAttribute)({
  name: 'href',
  noMultiBindings: true
}), __param(0, _runtimeHtml.INode), __param(1, _router.IRouter)], HrefCustomAttribute);
});

;define.alias('@aurelia/router/resources/href.js','@aurelia/router/dist/esm/resources/href.js');
define('@aurelia/router/dist/esm/resources/load.js',['require','exports','module','@aurelia/runtime-html','../router.js','../type-resolvers.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.LoadCustomAttribute = void 0;

var _runtimeHtml = require("@aurelia/runtime-html");

var _router = require("../router.js");

var _typeResolvers = require("../type-resolvers.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

let LoadCustomAttribute = class LoadCustomAttribute {
  constructor(element, router) {
    this.element = element;
    this.router = router;
    this.hasHref = null;
    this.activeClass = 'load-active';
  }

  binding() {
    this.element.addEventListener('click', this.router.linkHandler.handler);
    this.updateValue();
    const observerLocator = this.router.container.get(_runtimeHtml.IObserverLocator);
    this.observer = observerLocator.getObserver(this.router, 'activeComponents');
    this.observer.subscribe(this);
  }

  unbinding() {
    this.element.removeEventListener('click', this.router.linkHandler.handler);
    this.observer.unsubscribe(this);
  }

  valueChanged(newValue) {
    this.updateValue();
  }

  updateValue() {
    if (this.hasHref === null) {
      this.hasHref = this.element.hasAttribute('href');
    }

    if (!this.hasHref) {
      // TODO: Figure out a better value here for non-strings (using InstructionResolver?)
      const value = typeof this.value === 'string' ? this.value : JSON.stringify(this.value);
      this.element.setAttribute('href', value);
    }
  }

  handleChange() {
    const controller = _runtimeHtml.CustomAttribute.for(this.element, 'load').parent;

    const created = _typeResolvers.NavigationInstructionResolver.createViewportInstructions(this.router, this.value, {
      context: controller
    });

    const instructions = _typeResolvers.NavigationInstructionResolver.toViewportInstructions(this.router, created.instructions);

    for (const instruction of instructions) {
      if (instruction.scope === null) {
        instruction.scope = created.scope;
      }
    } // TODO: Use router configuration for class name and update target


    if (this.router.checkActive(instructions)) {
      this.element.classList.add(this.activeClass);
    } else {
      this.element.classList.remove(this.activeClass);
    }
  }

};
exports.LoadCustomAttribute = LoadCustomAttribute;

__decorate([(0, _runtimeHtml.bindable)({
  mode: _runtimeHtml.BindingMode.toView
})], LoadCustomAttribute.prototype, "value", void 0);

exports.LoadCustomAttribute = LoadCustomAttribute = __decorate([(0, _runtimeHtml.customAttribute)('load'), __param(0, _runtimeHtml.INode), __param(1, _router.IRouter)], LoadCustomAttribute);
});

;define.alias('@aurelia/router/resources/load.js','@aurelia/router/dist/esm/resources/load.js');
define('@aurelia/router/dist/esm/resources/nav.js',['require','exports','module','@aurelia/runtime-html','../router.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.NavCustomElement = void 0;

var _runtimeHtml = require("@aurelia/runtime-html");

var _router = require("../router.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

let NavCustomElement = class NavCustomElement {
  constructor(router) {
    this.router = router;
    this.name = null;
    this.routes = null;
    this.level = 0;
    this.classes = {};
  }

  get navRoutes() {
    const nav = this.router.navs[this.name];
    return nav !== void 0 && nav !== null ? nav.routes : [];
  }

  get navClasses() {
    const nav = this.router.navs[this.name];
    const navClasses = nav !== void 0 && nav !== null ? nav.classes : {};
    return { ...{
        nav: '',
        ul: '',
        li: '',
        a: '',
        ulActive: '',
        liActive: 'nav-active',
        aActive: ''
      },
      ...navClasses
    };
  }

  active(route) {
    return 'Active';
  }

};
exports.NavCustomElement = NavCustomElement;

__decorate([_runtimeHtml.bindable], NavCustomElement.prototype, "name", void 0);

__decorate([_runtimeHtml.bindable], NavCustomElement.prototype, "routes", void 0);

__decorate([_runtimeHtml.bindable], NavCustomElement.prototype, "level", void 0);

__decorate([_runtimeHtml.bindable], NavCustomElement.prototype, "classes", void 0);

exports.NavCustomElement = NavCustomElement = __decorate([(0, _runtimeHtml.customElement)({
  name: 'au-nav',
  template: `<template>
  <nav if.bind="name" class="\${name} \${navClasses.nav}">
    <au-nav routes.bind="navRoutes" classes.bind="navClasses" containerless></au-nav>
  </nav>
  <ul if.bind="routes" class="nav-level-\${level} \${classes.ul}">
    <li repeat.for="route of routes" if.bind="route.visible" class="\${route.active ? classes.liActive : ''} \${route.hasChildren} \${classes.li}">
      <a if.bind="route.link && route.link.length" load="\${route.link}" class="\${route.active ? classes.aActive : ''} \${classes.a}" innerhtml.bind="route.title"></a>
      <a if.bind="route.execute" click.trigger="route.executeAction($event)" href="" class="\${route.active ? classes.aActive : ''} \${classes.a}" innerhtml.bind="route.title"></a>
      <span if.bind="(!route.link || !route.link.length) && !route.execute && !route.children" class="\${route.active ? classes.aActive : ''} \${classes.span} nav-separator" innerhtml.bind="route.title"></span>
      <a if.bind="(!route.link || !route.link.length) && !route.execute && route.children" click.delegate="route.toggleActive()" href="" class="\${route.active ? classes.aActive : ''} \${classes.a}" innerhtml.bind="route.title"></a>
      <au-nav if.bind="route.children" routes.bind="route.children" level.bind="level + 1" classes.bind="classes" containerless></au-nav>
    </li>
  </ul>
</template>`
}), __param(0, _router.IRouter)], NavCustomElement);
});

;define.alias('@aurelia/router/resources/nav.js','@aurelia/router/dist/esm/resources/nav.js');
define('@aurelia/router/dist/esm/resources/viewport-scope.js',['require','exports','module','@aurelia/runtime-html','@aurelia/kernel','../router.js','./viewport.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.ViewportScopeCustomElement = exports.ParentViewportScope = void 0;

var _runtimeHtml = require("@aurelia/runtime-html");

var _kernel = require("@aurelia/kernel");

var _router = require("../router.js");

var _viewport = require("./viewport.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

var ViewportScopeCustomElement_1;

const ParentViewportScope = _runtimeHtml.CustomElement.createInjectable();

exports.ParentViewportScope = ParentViewportScope;
let ViewportScopeCustomElement = ViewportScopeCustomElement_1 = class ViewportScopeCustomElement {
  constructor(router, element, container, parent, parentController) {
    this.router = router;
    this.element = element;
    this.container = container;
    this.parent = parent;
    this.parentController = parentController;
    this.name = 'default';
    this.catches = '';
    this.collection = false;
    this.source = null;
    this.viewportScope = null;
    this.isBound = false;
  } // Maybe this really should be here. Check with Fred
  // public create(
  //   controller: IDryCustomElementController<this>,
  //   parentContainer: IContainer,
  //   definition: CustomElementDefinition,
  //   parts: PartialCustomElementDefinitionParts | undefined,
  // ): PartialCustomElementDefinition {
  //   // TODO(fkleuver): describe this somewhere in the docs instead
  //   // Under the condition that there is no `replace` attribute on this custom element's declaration,
  //   // and this custom element is containerless, its content will be placed in a part named 'default'
  //   // See packages/jit-html/src/template-binder.ts line 411 (`replace = 'default';`) for the logic that governs this.
  //   // We could tidy this up into a formal api in the future. For now, there are two ways to do this:
  //   // 1. inject the `@IInstruction` (IHydrateElementInstruction) and grab .parts['default'] from there, manually creating a view factory from that, etc.
  //   // 2. what we're doing right here: grab the 'default' part from the create hook and return it as the definition, telling the render context to use that part to compile this element instead
  //   // This effectively causes this element to render its declared content as if it was its own template.
  //   // We do need to set `containerless` to true on the part definition so that the correct projector is used since parts default to non-containerless.
  //   // Otherwise, the controller will try to do `appendChild` on a comment node when it has to do `insertBefore`.
  //   // Also, in this particular scenario (specific to viewport-scope) we need to clone the part so as to prevent the resulting compiled definition
  //   // from ever being cached. That's the only reason why we're spreading the part into a new object for `getOrCreate`. If we didn't clone the object, this specific element wouldn't work correctly.
  //   const part = parts!['default'];
  //   return CustomElementDefinition.getOrCreate({ ...part, containerless: true });
  // }


  hydrated(controller) {
    this.controller = controller; // Don't update the container here (probably because it wants to be a part of the structure)
    // this.container = controller.context.get(IContainer);
    // console.log('ViewportScope creating', this.getAttribute('name', this.name), this.container, this.parent, controller, this);
    // this.connect();
  }

  bound(initiator, parent, flags) {
    this.isBound = true;
    this.$controller.scope = this.parentController.scope;
    this.connect();

    if (this.viewportScope !== null) {
      this.viewportScope.binding();
    }
  }

  unbinding(initiator, parent, flags) {
    if (this.viewportScope !== null) {
      this.viewportScope.unbinding();
    }

    return Promise.resolve();
  }

  afterUnbind(initiator, parent, flags) {
    this.disconnect();
    return Promise.resolve();
  }

  afterUnbound() {
    this.isBound = false;
  }

  connect() {
    if (this.router.rootScope === null) {
      return;
    }

    const name = this.getAttribute('name', this.name);
    const options = {};
    let value = this.getAttribute('catches', this.catches);

    if (value !== void 0) {
      options.catches = value;
    }

    value = this.getAttribute('collection', this.collection, true);

    if (value !== void 0) {
      options.collection = value;
    } // TODO: Needs to be bound? How to solve?


    options.source = this.source || null;
    this.controller.routingContainer = this.container;
    this.viewportScope = this.router.connectViewportScope(this.viewportScope, this, name, options);
  }

  disconnect() {
    if (this.viewportScope) {
      this.router.disconnectViewportScope(this.viewportScope, this);
    }

    this.viewportScope = null;
  }

  getAttribute(key, value, checkExists = false) {
    const result = {};

    if (this.isBound) {
      return value;
    } else {
      if (this.element.hasAttribute(key)) {
        if (checkExists) {
          return true;
        } else {
          value = this.element.getAttribute(key);

          if (value.length > 0) {
            return value;
          }
        }
      }
    }

    return void 0;
  }

  isCustomElementController(value) {
    return (0, _runtimeHtml.isCustomElementController)(value);
  }

  isCustomElementViewModel(value) {
    return (0, _runtimeHtml.isCustomElementViewModel)(value);
  }

  getClosestCustomElement() {
    let parent = this.controller.parent;
    let customElement = null;

    while (parent !== null && customElement === null) {
      if (parent.viewModel instanceof _viewport.ViewportCustomElement || parent.viewModel instanceof ViewportScopeCustomElement_1) {
        customElement = parent.viewModel;
      }

      parent = parent.parent;
    }

    return customElement;
  }

};
exports.ViewportScopeCustomElement = ViewportScopeCustomElement;

__decorate([_runtimeHtml.bindable], ViewportScopeCustomElement.prototype, "name", void 0);

__decorate([_runtimeHtml.bindable], ViewportScopeCustomElement.prototype, "catches", void 0);

__decorate([_runtimeHtml.bindable], ViewportScopeCustomElement.prototype, "collection", void 0);

__decorate([_runtimeHtml.bindable], ViewportScopeCustomElement.prototype, "source", void 0);

exports.ViewportScopeCustomElement = ViewportScopeCustomElement = ViewportScopeCustomElement_1 = __decorate([(0, _runtimeHtml.customElement)({
  name: 'au-viewport-scope',
  template: '<template></template>',
  containerless: false,
  injectable: ParentViewportScope
}), __param(0, _router.IRouter), __param(1, _runtimeHtml.INode), __param(2, _kernel.IContainer), __param(3, ParentViewportScope), __param(4, _runtimeHtml.IController)], ViewportScopeCustomElement);
});

;define.alias('@aurelia/router/resources/viewport-scope.js','@aurelia/router/dist/esm/resources/viewport-scope.js');
define('@aurelia/router/dist/esm/resources/viewport.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime-html','../router.js','./viewport-scope.js','../runner.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.ViewportCustomElement = exports.ParentViewport = void 0;

var _kernel = require("@aurelia/kernel");

var _runtimeHtml = require("@aurelia/runtime-html");

var _router = require("../router.js");

var _viewportScope = require("./viewport-scope.js");

var _runner = require("../runner.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

var ViewportCustomElement_1;

const ParentViewport = _runtimeHtml.CustomElement.createInjectable();

exports.ParentViewport = ParentViewport;
let ViewportCustomElement = ViewportCustomElement_1 = class ViewportCustomElement {
  constructor(router, element, container, parentViewport) {
    this.router = router;
    this.element = element;
    this.container = container;
    this.parentViewport = parentViewport;
    this.name = 'default';
    this.usedBy = '';
    this.default = '';
    this.fallback = '';
    this.noScope = false;
    this.noLink = false;
    this.noTitle = false;
    this.noHistory = false;
    this.stateful = false;
    this.viewport = null;
    this.isBound = false;
  }

  hydrated(controller) {
    // console.log('hydrated', this.name, this.router.isActive);
    this.controller = controller;
    this.container = controller.context.get(_kernel.IContainer); // The first viewport(s) might be compiled before the router is active

    return _runner.Runner.run(() => this.waitForRouterStart(), () => {
      if (this.router.isRestrictedNavigation) {
        this.connect();
      }
    });
  }

  binding(initiator, parent, flags) {
    this.isBound = true;
    return _runner.Runner.run(() => this.waitForRouterStart(), () => {
      if (!this.router.isRestrictedNavigation) {
        this.connect();
      }
    });
  }

  attaching(initiator, parent, flags) {
    if (this.viewport !== null && (this.viewport.nextContent ?? null) === null) {
      // console.log('attaching', this.viewport?.toString());
      this.viewport.enabled = true;
      return this.viewport.activate(initiator, this.$controller, flags, true); // TODO: Restore scroll state
    }
  }

  unbinding(initiator, parent, flags) {
    if (this.viewport !== null && (this.viewport.nextContent ?? null) === null) {
      // console.log('unbinding', this.viewport?.toString());
      // TODO: Save to cache, something like
      // this.viewport.cacheContent();
      // From viewport-content:
      // public unloadComponent(cache: ViewportContent[], stateful: boolean = false): void {
      //   // TODO: We might want to do something here eventually, who knows?
      //   if (this.contentStatus !== ContentStatus.loaded) {
      //     return;
      //   }
      //   // Don't unload components when stateful
      //   if (!stateful) {
      //     this.contentStatus = ContentStatus.created;
      //   } else {
      //     cache.push(this);
      //   }
      // }
      // TODO: Save scroll state before detach
      return _runner.Runner.run(() => this.viewport.deactivate(initiator, parent, flags), () => {
        this.isBound = false;
        this.viewport.enabled = false;
      }); // this.isBound = false;
      // this.viewport.enabled = false;
      // return this.viewport.deactivate(initiator, parent, flags);
      // // this.viewport.enabled = false;
    }
  } // public detaching(initiator: IHydratedController, parent: ISyntheticView | ICustomElementController<ICustomElementViewModel> | null, flags: LifecycleFlags): void | Promise<void> {
  //   if (this.viewport !== null && (this.viewport.nextContent ?? null) === null) {
  //     console.log('detaching', this.viewport?.toString());
  //   }
  // }


  dispose() {
    if (this.viewport !== null) {
      return _runner.Runner.run(() => (this.viewport?.nextContent ?? null) === null ? this.viewport?.dispose() : void 0, () => this.disconnect());
    }
  }

  connect() {
    if (this.router.rootScope === null || this.viewport !== null && this.router.isRestrictedNavigation) {
      return;
    } // let controllerContainer = (this.controller.context as any).container;
    // let output = '';
    // do {
    //   console.log(output, ':', controllerContainer === this.container, this.controller, controllerContainer, this.container);
    //   if (controllerContainer === this.container) {
    //     break;
    //   }
    //   controllerContainer = controllerContainer.parent;
    //   output += '.parent';
    // } while (controllerContainer);


    const name = this.getAttribute('name', this.name);
    let value = this.getAttribute('no-scope', this.noScope);
    const options = {
      scope: value === void 0 || !value ? true : false
    };
    value = this.getAttribute('used-by', this.usedBy);

    if (value !== void 0) {
      options.usedBy = value;
    }

    value = this.getAttribute('default', this.default);

    if (value !== void 0) {
      options.default = value;
    }

    value = this.getAttribute('fallback', this.fallback);

    if (value !== void 0) {
      options.fallback = value;
    }

    value = this.getAttribute('no-link', this.noLink, true);

    if (value !== void 0) {
      options.noLink = value;
    }

    value = this.getAttribute('no-title', this.noTitle, true);

    if (value !== void 0) {
      options.noTitle = value;
    }

    value = this.getAttribute('no-history', this.noHistory, true);

    if (value !== void 0) {
      options.noHistory = value;
    }

    value = this.getAttribute('stateful', this.stateful, true);

    if (value !== void 0) {
      options.stateful = value;
    }

    this.controller.routingContainer = this.container;
    this.viewport = this.router.connectViewport(this.viewport, this, name, options);
  }

  disconnect() {
    if (this.viewport) {
      this.router.disconnectViewport(this.viewport, this);
    }

    this.viewport = null;
  }

  getAttribute(key, value, checkExists = false) {
    const result = {};

    if (this.isBound && !checkExists) {
      return value;
    } else {
      if (this.element.hasAttribute(key)) {
        if (checkExists) {
          return true;
        } else {
          value = this.element.getAttribute(key);

          if (value.length > 0) {
            return value;
          }
        }
      }
    }

    return value;
  }

  getClosestCustomElement() {
    let parent = this.controller.parent;
    let customElement = null;

    while (parent !== null && customElement === null) {
      if (parent.viewModel instanceof ViewportCustomElement_1 || parent.viewModel instanceof _viewportScope.ViewportScopeCustomElement) {
        customElement = parent.viewModel;
      }

      parent = parent.parent;
    }

    return customElement;
  } // TODO: Switch this to use (probably) an event instead


  waitForRouterStart() {
    if (this.router.isActive) {
      return;
    }

    return new Promise(resolve => {
      this.router.starters.push(resolve);
    });
  }

};
exports.ViewportCustomElement = ViewportCustomElement;

__decorate([_runtimeHtml.bindable], ViewportCustomElement.prototype, "name", void 0);

__decorate([_runtimeHtml.bindable], ViewportCustomElement.prototype, "usedBy", void 0);

__decorate([_runtimeHtml.bindable], ViewportCustomElement.prototype, "default", void 0);

__decorate([_runtimeHtml.bindable], ViewportCustomElement.prototype, "fallback", void 0);

__decorate([_runtimeHtml.bindable], ViewportCustomElement.prototype, "noScope", void 0);

__decorate([_runtimeHtml.bindable], ViewportCustomElement.prototype, "noLink", void 0);

__decorate([_runtimeHtml.bindable], ViewportCustomElement.prototype, "noTitle", void 0);

__decorate([_runtimeHtml.bindable], ViewportCustomElement.prototype, "noHistory", void 0);

__decorate([_runtimeHtml.bindable], ViewportCustomElement.prototype, "stateful", void 0);

exports.ViewportCustomElement = ViewportCustomElement = ViewportCustomElement_1 = __decorate([(0, _runtimeHtml.customElement)({
  name: 'au-viewport',
  injectable: ParentViewport
}), __param(0, _router.IRouter), __param(1, _runtimeHtml.INode), __param(2, _kernel.IContainer), __param(3, ParentViewport)], ViewportCustomElement);
});

;define.alias('@aurelia/router/resources/viewport.js','@aurelia/router/dist/esm/resources/viewport.js');
define('@aurelia/router/dist/esm/route-recognizer.js',['require','exports','module','@aurelia/route-recognizer'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.Endpoint = exports.RecognizedRoute = exports.ConfigurableRoute = exports.RouteRecognizer = void 0;

var _routeRecognizer = require("@aurelia/route-recognizer");

const RouteRecognizer = _routeRecognizer.RouteRecognizer;
exports.RouteRecognizer = RouteRecognizer;
const ConfigurableRoute = _routeRecognizer.ConfigurableRoute;
exports.ConfigurableRoute = ConfigurableRoute;
const RecognizedRoute = _routeRecognizer.RecognizedRoute;
exports.RecognizedRoute = RecognizedRoute;
const Endpoint = _routeRecognizer.Endpoint;
exports.Endpoint = Endpoint;
});

;define.alias('@aurelia/router/route-recognizer.js','@aurelia/router/dist/esm/route-recognizer.js');
define('@aurelia/router/dist/esm/router-options.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.RouterOptions = void 0;

class RouterOptions {
  constructor() {
    this.separators = {
      viewport: '@',
      sibling: '+',
      scope: '/',
      scopeStart: '(',
      scopeEnd: ')',
      noScope: '!',
      parameters: '(',
      parametersEnd: ')',
      parameterSeparator: ',',
      parameterKeySeparator: '=',
      parameter: '&',
      add: '+',
      clear: '-',
      action: '.'
    };
    this.useUrlFragmentHash = true;
    this.useHref = true;
    this.statefulHistoryLength = 0;
    this.useDirectRoutes = true;
    this.useConfiguredRoutes = true;
    this.additiveInstructionDefault = true;
    this.title = {
      // eslint-disable-next-line no-useless-escape
      appTitle: "${componentTitles}\${appTitleSeparator}Aurelia",
      appTitleSeparator: ' | ',
      componentTitleOrder: 'top-down',
      componentTitleSeparator: ' > ',
      useComponentNames: true,
      componentPrefix: 'app-'
    };
    this.navigationSyncStates = ['guardedUnload', 'swapped', 'completed'];
    this.swapStrategy = 'add-first-sequential';
    this.routingHookIntegration = 'integrated';
  }

}

exports.RouterOptions = RouterOptions;
});

;define.alias('@aurelia/router/router-options.js','@aurelia/router/dist/esm/router-options.js');
define('@aurelia/router/dist/esm/router.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime-html','./instruction-resolver.js','./link-handler.js','./nav.js','./navigator.js','./type-resolvers.js','./utils.js','./viewport.js','./viewport-instruction.js','./found-route.js','./hook-manager.js','./scope.js','./viewport-scope.js','./browser-viewer-store.js','./navigation.js','./navigation-coordinator.js','./router-options.js','./open-promise.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.Router = exports.IRouter = void 0;

var _kernel = require("@aurelia/kernel");

var _runtimeHtml = require("@aurelia/runtime-html");

var _instructionResolver = require("./instruction-resolver.js");

var _linkHandler = require("./link-handler.js");

var _nav = require("./nav.js");

var _navigator = require("./navigator.js");

var _typeResolvers = require("./type-resolvers.js");

var _utils = require("./utils.js");

var _viewport = require("./viewport.js");

var _viewportInstruction = require("./viewport-instruction.js");

var _foundRoute = require("./found-route.js");

var _hookManager = require("./hook-manager.js");

var _scope = require("./scope.js");

var _viewportScope = require("./viewport-scope.js");

var _browserViewerStore = require("./browser-viewer-store.js");

var _navigation = require("./navigation.js");

var _navigationCoordinator = require("./navigation-coordinator.js");

var _routerOptions = require("./router-options.js");

var _openPromise = require("./open-promise.js");

/* eslint-disable no-template-curly-in-string */

/* eslint-disable prefer-template */

/* eslint-disable max-lines-per-function */
// export type SwapStrategy = 'add-first-sequential' | 'add-first-parallel' | 'remove-first-sequential' | 'remove-first-parallel';
// export type RoutingHookIntegration = 'integrated' | 'separate';
// /**
//  * Public API
//  */
// export interface IRouterActivateOptions extends Omit<Partial<IRouterOptions>, 'title'> {
//   title?: string | IRouterTitle;
// }
// /**
//  * Public API
//  */
// export interface IRouterOptions extends INavigatorOptions {
//   separators?: IRouteSeparators;
//   useUrlFragmentHash: boolean;
//   useHref: boolean;
//   statefulHistoryLength: number;
//   useDirectRoutes: boolean;
//   useConfiguredRoutes: boolean;
//   additiveInstructionDefault: boolean;
//   title: ITitleConfiguration;
//   hooks?: IHookDefinition[];
//   reportCallback?(instruction: Navigation): void;
//   navigationSyncStates: NavigationState[];
//   swapStrategy: SwapStrategy;
//   routingHookIntegration: RoutingHookIntegration;
// }
// /**
//  * Public API
//  */
// export interface IRouterTitle extends Partial<ITitleConfiguration> { }
// /**
//  * Public API
//  */
// export interface ITitleConfiguration {
//   appTitle: string;
//   appTitleSeparator: string;
//   componentTitleOrder: 'top-down' | 'bottom-up';
//   componentTitleSeparator: string;
//   useComponentNames: boolean;
//   componentPrefix: string;
//   transformTitle?: (title: string, instruction: string | ViewportInstruction | FoundRoute) => string;
// }

/**
 * Public API
 */
const IRouter = _kernel.DI.createInterface('IRouter', x => x.singleton(Router));

exports.IRouter = IRouter;

class ClosestViewportCustomElement {}
/**
 * @internal
 */


class ClosestScope {}

class Router {
  constructor(
  /**
   * @internal - Shouldn't be used directly.
   */
  container,
  /**
   * @internal - Shouldn't be used directly.
   */
  navigator, navigation,
  /**
   * @internal - Shouldn't be used directly.
   */
  linkHandler,
  /**
   * @internal - Shouldn't be used directly. Probably.
   */
  instructionResolver,
  /**
   * @internal - Shouldn't be used directly. Probably.
   */
  hookManager, options) {
    this.container = container;
    this.navigator = navigator;
    this.navigation = navigation;
    this.linkHandler = linkHandler;
    this.instructionResolver = instructionResolver;
    this.hookManager = hookManager;
    this.options = options;
    this.rootScope = null;
    /**
     * @internal
     */
    // public hookManager: HookManager;

    /**
     * @internal
     */

    this.navs = {};
    /**
     * Public API
     */

    this.activeComponents = [];
    /**
     * @internal
     */

    this.appendedInstructions = []; // /**
    //  * @internal
    //  */
    // public options: IRouterOptions = {
    //   useUrlFragmentHash: true,
    //   useHref: true,
    //   statefulHistoryLength: 0,
    //   useDirectRoutes: true,
    //   useConfiguredRoutes: true,
    //   additiveInstructionDefault: true,
    //   title: {
    //     appTitle: "${componentTitles}\${appTitleSeparator}Aurelia",
    //     appTitleSeparator: ' | ',
    //     componentTitleOrder: 'top-down',
    //     componentTitleSeparator: ' > ',
    //     useComponentNames: true,
    //     componentPrefix: 'app-',
    //   },
    //   swapStrategy: 'add-first-sequential',
    //   routingHookIntegration: 'integrated',
    //   navigationSyncStates: ['guardedUnload', 'swapped', 'completed'],
    // };

    this.processingNavigation = null;
    this.isActive = false;
    this.pendingConnects = new Map();
    this.loadedFirst = false;
    this.lastNavigation = null;
    this.staleChecks = {}; // TODO: Switch this to use (probably) an event instead

    this.starters = [];
    /**
     * @internal
     */
    // TODO: use @bound and improve name (eslint-disable is temp)

    this.linkCallback = info => {
      let instruction = info.instruction || '';

      if (typeof instruction === 'string' && instruction.startsWith('#')) {
        instruction = instruction.slice(1); // '#' === '/' === '#/'

        if (!instruction.startsWith('/')) {
          instruction = "/" + instruction;
        }
      } // Adds to Navigator's Queue, which makes sure it's serial


      this.load(instruction, {
        origin: info.anchor
      }).catch(error => {
        throw error;
      });
    };
    /**
     * @internal
     */
    // TODO: use @bound and improve name (eslint-disable is temp)


    this.navigatorCallback = instruction => {
      // Instructions extracted from queue, one at a time
      this.processNavigations(instruction).catch(error => {
        throw error;
      });
    };
    /**
     * @internal
     */
    // TODO: use @bound and improve name (eslint-disable is temp)


    this.navigatorSerializeCallback = async (entry, preservedEntries) => {
      let excludeComponents = [];

      for (const preservedEntry of preservedEntries) {
        if (typeof preservedEntry.instruction !== 'string') {
          excludeComponents.push(...this.instructionResolver.flattenViewportInstructions(preservedEntry.instruction).filter(instruction => instruction.viewport !== null).map(instruction => instruction.componentInstance));
        }

        if (typeof preservedEntry.fullStateInstruction !== 'string') {
          excludeComponents.push(...this.instructionResolver.flattenViewportInstructions(preservedEntry.fullStateInstruction).filter(instruction => instruction.viewport !== null).map(instruction => instruction.componentInstance));
        }
      }

      excludeComponents = excludeComponents.filter((component, i, arr) => component !== null && arr.indexOf(component) === i);
      const serialized = { ...entry
      };
      let instructions = [];

      if (serialized.fullStateInstruction && typeof serialized.fullStateInstruction !== 'string') {
        instructions.push(...serialized.fullStateInstruction);
        serialized.fullStateInstruction = this.instructionResolver.stringifyViewportInstructions(serialized.fullStateInstruction);
      }

      if (serialized.instruction && typeof serialized.instruction !== 'string') {
        instructions.push(...serialized.instruction);
        serialized.instruction = this.instructionResolver.stringifyViewportInstructions(serialized.instruction);
      }

      instructions = instructions.filter((instruction, i, arr) => instruction !== null && instruction.componentInstance !== null && arr.indexOf(instruction) === i);
      const alreadyDone = [];

      for (const instruction of instructions) {
        await this.freeComponents(instruction, excludeComponents, alreadyDone);
      }

      return serialized;
    };
    /**
     * @internal
     */
    // TODO: use @bound and improve name (eslint-disable is temp)


    this.browserNavigatorCallback = browserNavigationEvent => {
      const entry = new _navigation.Navigation(browserNavigationEvent.state?.currentEntry);
      entry.instruction = browserNavigationEvent.instruction;
      entry.fromBrowser = true;
      this.navigator.navigate(entry).catch(error => {
        throw error;
      });
    };
    /**
     * @internal
     */
    // TODO: use @bound and improve name (eslint-disable is temp)


    this.processNavigations = async qInstruction => {
      const instruction = this.processingNavigation = qInstruction; // console.log('pendingConnects', [...this.pendingConnects]);

      this.pendingConnects.clear();

      if (this.options.reportCallback) {
        this.options.reportCallback(instruction);
      } // let {
      //   fullStateInstruction,
      //   instructionNavigation,
      //   configuredRoute,
      //   configuredRoutePath,
      //   instructions,
      //   clearScopeOwners,
      //   clearViewportScopes,
      // }


      const coordinator = _navigationCoordinator.NavigationCoordinator.create(this, instruction, {
        syncStates: this.options.navigationSyncStates
      }); // const steps = [
      //   () => coordinator.syncState('loaded'),
      //   () => { console.log('SyncState loaded resolved!', steps); },
      //   () => coordinator.syncState('swapped'),
      //   () => { console.log('SyncState swapped resolved!', steps); },
      //   () => coordinator.syncState('left'),
      //   () => { console.log('SyncState left resolved!', steps); },
      // ];
      // run(...steps);
      // const loadedPromise = ;
      // if (loadedPromise !== void 0) {
      //   loadedPromise.then((value: any) => {
      //     console.log('SyncState loaded resolved!', value);
      //   });
      // }
      // console.log(instruction.instruction);
      // console.log(this.rootScope?.scope.toString(true));


      let transformedInstruction = typeof instruction.instruction === 'string' && !instruction.useFullStateInstruction ? await this.hookManager.invokeTransformFromUrl(instruction.instruction, this.processingNavigation) : instruction.instruction; // TODO: Review this

      if (transformedInstruction === '/') {
        transformedInstruction = '';
      }

      instruction.scope = instruction.scope ?? this.rootScope.scope;
      let configuredRoute = instruction.scope.findInstructions(transformedInstruction);
      let configuredRoutePath = null; // let configuredRoute = await this.findInstructions(
      //   this.rootScope!.scope,
      //   instruction.instruction,
      //   instruction.scope ?? this.rootScope!.scope,
      //   !instruction.useFullStateInstruction);

      if (instruction.instruction.length > 0 && !configuredRoute.foundConfiguration && !configuredRoute.foundInstructions) {
        // TODO: Do something here!
        this.unknownRoute(configuredRoute.remaining);
      }

      let instructions = configuredRoute.instructions;

      if (configuredRoute.foundConfiguration) {
        instruction.path = instruction.instruction.startsWith('/') ? instruction.instruction.slice(1) : instruction.instruction;
        configuredRoutePath = (configuredRoutePath ?? '') + configuredRoute.matching;
        this.rootScope.path = configuredRoutePath;
      } // TODO: Used to have an early exit if no instructions. Restore it?


      if (!this.options.additiveInstructionDefault && instructions.length > 0 && !this.instructionResolver.isAddAllViewportsInstruction(instructions[0]) && !this.instructionResolver.isClearAllViewportsInstruction(instructions[0])) {
        const instr = this.createViewportInstruction(this.instructionResolver.clearViewportInstruction);
        instr.scope = instructions[0].scope;
        instructions.unshift(instr);
      }

      const clearScopeOwners = [];
      let clearViewportScopes = [];

      for (const clearInstruction of instructions.filter(instr => this.instructionResolver.isClearAllViewportsInstruction(instr))) {
        const scope = clearInstruction.scope || this.rootScope.scope;
        const scopes = scope.allScopes().filter(scope => !scope.owner.isEmpty).map(scope => scope.owner); // TODO: Tell Fred about the need for reverse
        // scopes.reverse();

        clearScopeOwners.push(...scopes);

        if (scope.viewportScope !== null && scope.viewportScope !== this.rootScope) {
          clearViewportScopes.push(scope.viewportScope);
        }
      }

      instructions = instructions.filter(instr => !this.instructionResolver.isClearAllViewportsInstruction(instr));

      for (const addInstruction of instructions.filter(instr => this.instructionResolver.isAddAllViewportsInstruction(instr))) {
        addInstruction.setViewport((addInstruction.scope || this.rootScope.scope).viewportScope.name);
        addInstruction.scope = addInstruction.scope.owningScope;
      }

      for (const instr of instructions) {
        instr.topInstruction = true;
      }

      const updatedScopeOwners = [];
      const alreadyFoundInstructions = []; // TODO: Take care of cancellations down in subsets/iterations

      let {
        found: viewportInstructions,
        remaining: remainingInstructions
      } = this.findViewports(instructions, alreadyFoundInstructions);
      let guard = 100;

      do {
        if (!guard--) {
          // Guard against endless loop
          const err = new Error(remainingInstructions.length + ' remaining instructions after 100 iterations; there is likely an infinite loop.');
          err['remainingInstructions'] = remainingInstructions;
          console.log('remainingInstructions', remainingInstructions);
          throw err;
        }

        const changedScopeOwners = []; // TODO: Review whether this await poses a problem (it's currently necessary for new viewports to load)

        const hooked = await this.hookManager.invokeBeforeNavigation(viewportInstructions, instruction);

        if (hooked === false) {
          coordinator.cancel();
          return; // return this.cancelNavigation([...changedScopeOwners, ...updatedScopeOwners], instruction);
        } else {
          viewportInstructions = hooked;
        }

        for (const viewportInstruction of viewportInstructions) {
          const scopeOwner = viewportInstruction.owner;

          if (scopeOwner !== null) {
            scopeOwner.path = configuredRoutePath;
            const action = scopeOwner.setNextContent(viewportInstruction, instruction);

            if (action !== 'skip') {
              changedScopeOwners.push(scopeOwner);
              coordinator.addEntity(scopeOwner);
            }

            const dontClear = [scopeOwner];

            if (action === 'swap') {
              dontClear.push(...scopeOwner.scope.allScopes(true, true).map(scope => scope.owner));
            }

            (0, _utils.arrayRemove)(clearScopeOwners, value => dontClear.includes(value)); // arrayRemove(clearScopeOwners, value => value === scopeOwner);

            if (!this.instructionResolver.isClearViewportInstruction(viewportInstruction) && viewportInstruction.scope !== null && viewportInstruction.scope.parent !== null && viewportInstruction.scope.parent.isViewportScope) {
              (0, _utils.arrayRemove)(clearViewportScopes, value => value === viewportInstruction.scope.parent.viewportScope);
            }
          }
        }

        if (!this.isRestrictedNavigation) {
          coordinator.finalEntity();
        }

        coordinator.run(); // await coordinator.syncState('routed');
        // // eslint-disable-next-line no-await-in-loop
        // let results = await Promise.all(changedScopeOwners.map((scopeOwner) => scopeOwner.canUnload()));
        // if (results.some(result => result === false)) {
        //   return this.cancelNavigation([...changedScopeOwners, ...updatedScopeOwners], instruction);
        // }
        // // eslint-disable-next-line no-await-in-loop
        // results = await Promise.all(changedScopeOwners.map(async (scopeOwner) => {
        //   const canLoad = await scopeOwner.canLoad();
        //   if (typeof canLoad === 'boolean') {
        //     if (canLoad) {
        //       coordinator.addEntityState(scopeOwner, 'loaded');
        //       return scopeOwner.load();
        //     } else {
        //       return false;
        //     }
        //   }
        //   await this.load(canLoad, { append: true });
        //   await scopeOwner.abortContentChange();
        //   // TODO: Abort content change in the viewports
        //   return true;
        // }));
        // if (results.some(result => result === false)) {
        //   return this.cancelNavigation([...changedScopeOwners, ...updatedScopeOwners], qInstruction);
        // }

        for (const viewport of changedScopeOwners) {
          if (updatedScopeOwners.every(scopeOwner => scopeOwner !== viewport)) {
            updatedScopeOwners.push(viewport);
          }
        } // TODO: Fix multi level recursiveness!


        alreadyFoundInstructions.push(...viewportInstructions);
        ({
          found: viewportInstructions,
          remaining: remainingInstructions
        } = this.findViewports(remainingInstructions, alreadyFoundInstructions)); // Look for configured child routes (once we've loaded everything so far?)

        if (configuredRoute.hasRemaining && viewportInstructions.length === 0 && remainingInstructions.length === 0) {
          let configured = new _foundRoute.FoundRoute();
          const routeScopeOwners = alreadyFoundInstructions.filter(instr => instr.owner !== null && instr.owner.path === configuredRoutePath).map(instr => instr.owner).filter((value, index, arr) => arr.indexOf(value) === index); // Need to await new viewports being bound

          if (!this.isRestrictedNavigation) {
            // await Promise.resolve();
            // console.log('Awaiting swapped');
            await coordinator.syncState('swapped'); // console.log('Awaited swapped');
            // console.log('pendingConnects before find new', [...this.pendingConnects]);
            // const pending = [...this.pendingConnects.values()].filter(connect => connect.isPending);
            // if (pending.length > 0) {
            //   console.log('Beginning await for ', pending.length);
            //   await Promise.all(pending.map(connect => connect.promise));
            //   console.log('Await done');
            // }
          }

          for (const owner of routeScopeOwners) {
            configured = owner.scope.findInstructions(configuredRoute.remaining); // configured = await this.findInstructions(owner.scope, configuredRoute.remaining, owner.scope);

            if (configured.foundConfiguration) {
              break;
            }
          }

          if (configured.foundInstructions) {
            configuredRoute = configured;
            configuredRoutePath = (configuredRoutePath ?? '') + "/" + configuredRoute.matching;
          } else {
            // TODO: Do something here!
            this.unknownRoute(configured.remaining);
          }

          this.appendInstructions(configured.instructions);
        } // Don't use defaults when it's a full state navigation


        if (instruction.useFullStateInstruction) {
          this.appendedInstructions = this.appendedInstructions.filter(instruction => !instruction.default);
        } // Process non-defaults first


        let appendedInstructions = this.appendedInstructions.filter(instruction => !instruction.default);
        this.appendedInstructions = this.appendedInstructions.filter(instruction => instruction.default);

        if (appendedInstructions.length === 0) {
          const index = this.appendedInstructions.findIndex(instruction => instruction.default);

          if (index >= 0) {
            appendedInstructions = this.appendedInstructions.splice(index, 1);
          }
        }

        while (appendedInstructions.length > 0) {
          const appendedInstruction = appendedInstructions.shift();
          const existingAlreadyFound = alreadyFoundInstructions.some(instruction => instruction.sameViewport(appendedInstruction));
          const existingFound = viewportInstructions.find(value => value.sameViewport(appendedInstruction));
          const existingRemaining = remainingInstructions.find(value => value.sameViewport(appendedInstruction));

          if (appendedInstruction.default && (existingAlreadyFound || existingFound !== void 0 && !existingFound.default || existingRemaining !== void 0 && !existingRemaining.default)) {
            continue;
          }

          if (existingFound !== void 0) {
            (0, _utils.arrayRemove)(viewportInstructions, value => value === existingFound);
          }

          if (existingRemaining !== void 0) {
            (0, _utils.arrayRemove)(remainingInstructions, value => value === existingRemaining);
          }

          if (appendedInstruction.viewport !== null) {
            viewportInstructions.push(appendedInstruction);
          } else {
            remainingInstructions.push(appendedInstruction);
          }
        }

        if (viewportInstructions.length === 0 && remainingInstructions.length === 0) {
          viewportInstructions = clearScopeOwners.map(owner => {
            const instruction = this.createViewportInstruction(this.instructionResolver.clearViewportInstruction, owner.isViewport ? owner : void 0);

            if (owner.isViewportScope) {
              instruction.viewportScope = owner;
            }

            return instruction;
          });
          viewportInstructions.push(...clearViewportScopes.map(viewportScope => {
            const instr = this.createViewportInstruction(this.instructionResolver.clearViewportInstruction);
            instr.viewportScope = viewportScope;
            return instr;
          }));
          clearViewportScopes = [];
        } // await new Promise(res => setTimeout(res, 100));

      } while (viewportInstructions.length > 0 || remainingInstructions.length > 0);

      coordinator.finalEntity(); // await Promise.all(updatedScopeOwners.map((value) => value.loadContent()));

      await coordinator.syncState('completed');
      coordinator.finalize(); // updatedScopeOwners.forEach((viewport) => {
      //   viewport.finalizeContentChange();
      // });

      await this.replacePaths(instruction); // this.updateNav();
      // Remove history entry if no history viewports updated

      if (instruction.navigation.new && !instruction.navigation.first && !instruction.repeating && updatedScopeOwners.every(viewport => viewport.options.noHistory)) {
        instruction.untracked = true;
      } // updatedScopeOwners.forEach((viewport) => {
      //   viewport.finalizeContentChange();
      // });


      this.lastNavigation = this.processingNavigation;

      if (this.lastNavigation?.repeating ?? false) {
        this.lastNavigation.repeating = false;
      }

      this.processingNavigation = null;
      await this.navigator.finalize(instruction);
    }; // this.hookManager = new HookManager();

  }
  /**
   * Public API
   */


  get isNavigating() {
    return this.processingNavigation !== null;
  }

  get isRestrictedNavigation() {
    const syncStates = this.options.navigationSyncStates;
    return syncStates.includes('guardedLoad') || syncStates.includes('unloaded') || syncStates.includes('loaded') || syncStates.includes('guarded') || syncStates.includes('routed');
  }
  /**
   * @internal
   */


  get statefulHistory() {
    return this.options.statefulHistoryLength !== void 0 && this.options.statefulHistoryLength > 0;
  }
  /**
   * Public API
   */


  start(options) {
    if (this.isActive) {
      throw new Error('Router has already been started');
    }

    this.isActive = true;
    options = options ?? {};
    const titleOptions = { ...this.options.title,
      ...(typeof options.title === 'string' ? {
        appTitle: options.title
      } : options.title)
    };
    options.title = titleOptions;
    const separatorOptions = { ...this.options.separators,
      ...(options.separators ?? {})
    };
    options.separators = separatorOptions;
    Object.assign(this.options, options);

    if (this.options.hooks !== void 0) {
      this.addHooks(this.options.hooks);
    }

    this.instructionResolver.start({
      separators: this.options.separators
    });
    this.navigator.start(this, {
      callback: this.navigatorCallback,
      store: this.navigation,
      statefulHistoryLength: this.options.statefulHistoryLength,
      serializeCallback: this.statefulHistory ? this.navigatorSerializeCallback : void 0
    });
    this.linkHandler.start({
      callback: this.linkCallback,
      useHref: this.options.useHref
    });
    this.navigation.start({
      callback: this.browserNavigatorCallback,
      useUrlFragmentHash: this.options.useUrlFragmentHash
    });
    this.ensureRootScope(); // TODO: Switch this to use (probably) an event instead

    for (const starter of this.starters) {
      starter();
    }
  }
  /**
   * Public API
   */


  async loadUrl() {
    const entry = new _navigation.Navigation({ ...this.navigation.viewerState,
      ...{
        fullStateInstruction: '',
        replacing: true,
        fromBrowser: false
      }
    });
    const result = this.navigator.navigate(entry);
    this.loadedFirst = true;
    return result;
  }
  /**
   * Public API
   */


  stop() {
    if (!this.isActive) {
      throw new Error('Router has not been started');
    }

    this.linkHandler.stop();
    this.navigator.stop();
    this.navigation.stop();
  }
  /**
   * @internal
   */


  findScope(origin) {
    // this.ensureRootScope();
    if (origin === void 0 || origin === null) {
      return this.rootScope.scope;
    }

    if (origin instanceof _scope.Scope || origin instanceof _viewport.Viewport) {
      return origin.scope;
    }

    return this.getClosestScope(origin) || this.rootScope.scope;
  }
  /**
   * @internal
   */


  findParentScope(container) {
    if (container === null) {
      return this.rootScope.scope;
    } // Already (prematurely) set on this view model so get it from container's parent instead


    if (container.has(ClosestScope, false)) {
      container = container.parent;

      if (container === null) {
        return this.rootScope.scope;
      }
    }

    if (container.has(ClosestScope, true)) {
      return container.get(ClosestScope);
    }

    return this.rootScope.scope;
  }
  /**
   * Public API - Get viewport by name
   */


  getViewport(name) {
    return this.allViewports().find(viewport => viewport.name === name) || null;
  }
  /**
   * Public API (not yet implemented)
   */


  addViewport(...args) {
    throw new Error('Not implemented');
  }
  /**
   * Public API (not yet implemented)
   */


  findViewportScope(...args) {
    throw new Error('Not implemented');
  }
  /**
   * Public API (not yet implemented)
   */


  addViewportScope(...args) {
    throw new Error('Not implemented');
  }
  /**
   * @internal - Called from the viewport scope custom element in created()
   */


  setClosestScope(viewModelOrContainer, scope) {
    const container = this.getContainer(viewModelOrContainer);

    _kernel.Registration.instance(ClosestScope, scope).register(container);
  }
  /**
   * @internal
   */


  getClosestScope(viewModelOrElement) {
    const container = 'resourceResolvers' in viewModelOrElement ? viewModelOrElement : this.getClosestContainer(viewModelOrElement);

    if (container === null) {
      return null;
    }

    if (!container.has(ClosestScope, true)) {
      return null;
    }

    return container.get(ClosestScope) || null;
  }
  /**
   * @internal
   */


  unsetClosestScope(viewModelOrContainer) {
    const container = this.getContainer(viewModelOrContainer); // TODO: Get an 'unregister' on container

    container.resolvers.delete(ClosestScope);
  }
  /**
   * @internal - Called from the viewport custom element
   */


  connectViewport(viewport, connectedCE, name, options) {
    const parentScope = this.findParentScope(connectedCE.container); // console.log('Viewport parentScope', parentScope.toString(), (connectedCE as any).getClosestCustomElement());

    const parentViewportScope = (connectedCE.parentViewport?.viewport ?? this.rootScope).scope;

    if (parentScope !== parentViewportScope) {
      console.error('Viewport parentScope !== parentViewportScope', parentScope.toString(true), parentViewportScope.toString(true), connectedCE.getClosestCustomElement());
    }

    if (viewport === null) {
      viewport = parentScope.addViewport(name, connectedCE, options);
      this.setClosestScope(connectedCE.container, viewport.connectedScope);

      if (!this.isRestrictedNavigation) {
        this.pendingConnects.set(connectedCE, new _openPromise.OpenPromise());
      }
    } else {
      this.pendingConnects.get(connectedCE)?.resolve();
    }

    return viewport;
  }
  /**
   * @internal - Called from the viewport custom element
   */


  disconnectViewport(viewport, connectedCE) {
    if (!viewport.connectedScope.parent.removeViewport(viewport, connectedCE)) {
      throw new Error("Failed to remove viewport: " + viewport.name);
    }

    this.unsetClosestScope(connectedCE.container);
  }
  /**
   * @internal - Called from the viewport scope custom element
   */


  connectViewportScope(viewportScope, connectedCE, name, options) {
    const parentScope = this.findParentScope(connectedCE.container); // console.log('ViewportScope parentScope', parentScope.toString(), (connectedCE as any).getClosestCustomElement());

    if (viewportScope === null) {
      viewportScope = parentScope.addViewportScope(name, connectedCE, options);
      this.setClosestScope(connectedCE.container, viewportScope.connectedScope);
    }

    return viewportScope;
  }
  /**
   * @internal - Called from the viewport scope custom element
   */


  disconnectViewportScope(viewportScope, connectedCE) {
    if (!viewportScope.connectedScope.parent.removeViewportScope(viewportScope)) {
      throw new Error("Failed to remove viewport scope: " + viewportScope.path);
    }

    this.unsetClosestScope(connectedCE.container);
  }

  allViewports(includeDisabled = false, includeReplaced = false) {
    // this.ensureRootScope();
    return this.rootScope.scope.allViewports(includeDisabled, includeReplaced);
  }
  /**
   * Public API - THE navigation API
   */


  async goto(instructions, options) {
    (0, _utils.deprecationWarning)('"goto" method', '"load" method');
    return this.load(instructions, options);
  }

  async load(instructions, options) {
    options = options || {}; // TODO: Review query extraction; different pos for path and fragment!

    if (typeof instructions === 'string' && !options.query) {
      const [path, search] = instructions.split('?');
      instructions = path;
      options.query = search;
    }

    const toOptions = {};

    if (options.origin) {
      toOptions.context = options.origin;
    }

    let scope = null;
    ({
      instructions,
      scope
    } = _typeResolvers.NavigationInstructionResolver.createViewportInstructions(this, instructions, toOptions));

    if (options.append && this.processingNavigation) {
      instructions = _typeResolvers.NavigationInstructionResolver.toViewportInstructions(this, instructions);
      this.appendInstructions(instructions, scope); // Can't return current navigation promise since it can lead to deadlock in load

      return Promise.resolve();
    }

    const entry = new _navigation.Navigation({
      instruction: instructions,
      fullStateInstruction: '',
      scope: scope,
      title: options.title,
      data: options.data,
      query: options.query,
      replacing: options.replace,
      repeating: options.append,
      fromBrowser: false,
      origin: options.origin
    });
    return this.navigator.navigate(entry);
  }
  /**
   * Public API
   */


  refresh() {
    return this.navigator.refresh();
  }
  /**
   * Public API
   */


  back() {
    return this.navigator.go(-1);
  }
  /**
   * Public API
   */


  forward() {
    return this.navigator.go(1);
  }
  /**
   * Public API
   */


  go(delta) {
    return this.navigator.go(delta);
  }
  /**
   * Public API
   */


  checkActive(instructions) {
    for (const instruction of instructions) {
      const scopeInstructions = this.instructionResolver.matchScope(this.activeComponents, instruction.scope);
      const matching = scopeInstructions.filter(instr => instr.sameComponent(instruction, true));

      if (matching.length === 0) {
        return false;
      }

      if (Array.isArray(instruction.nextScopeInstructions) && instruction.nextScopeInstructions.length > 0 && this.instructionResolver.matchChildren(instruction.nextScopeInstructions, matching.map(instr => Array.isArray(instr.nextScopeInstructions) ? instr.nextScopeInstructions : []).flat()) === false) {
        return false;
      }
    }

    return true;
  }
  /**
   * Public API
   */


  setNav(name, routes, classes) {
    const nav = this.findNav(name);

    if (nav !== void 0 && nav !== null) {
      nav.routes = [];
    }

    this.addNav(name, routes, classes);
  }
  /**
   * Public API
   */


  addNav(name, routes, classes) {
    let nav = this.navs[name];

    if (nav === void 0 || nav === null) {
      nav = this.navs[name] = new _nav.Nav(this, name, [], classes);
    }

    nav.addRoutes(routes);
    nav.update();
  }
  /**
   * Public API
   */


  updateNav(name) {
    const navs = name ? [name] : Object.keys(this.navs);

    for (const nav of navs) {
      if (this.navs[nav] !== void 0 && this.navs[nav] !== null) {
        this.navs[nav].update();
      }
    }
  }
  /**
   * Public API
   */


  findNav(name) {
    return this.navs[name];
  }
  /**
   * Public API
   */


  addRoutes(routes, context) {
    // TODO: This should add to the context instead
    // TODO: Add routes without context to rootScope content (which needs to be created)?
    return []; // const viewport = (context !== void 0 ? this.closestViewport(context) : this.rootScope) || this.rootScope as Viewport;
    // return viewport.addRoutes(routes);
  }
  /**
   * Public API
   */


  removeRoutes(routes, context) {// TODO: This should remove from the context instead
    // const viewport = (context !== void 0 ? this.closestViewport(context) : this.rootScope) || this.rootScope as Viewport;
    // return viewport.removeRoutes(routes);
  }
  /**
   * Public API
   */


  addHooks(hooks) {
    return hooks.map(hook => this.addHook(hook.hook, hook.options));
  }

  addHook(hook, options) {
    return this.hookManager.addHook(hook, options);
  }
  /**
   * Public API
   */


  removeHooks(hooks) {
    return;
  }
  /**
   * Public API - The right way to create ViewportInstructions
   */


  createViewportInstruction(component, viewport, parameters, ownsScope = true, nextScopeInstructions = null) {
    return this.instructionResolver.createViewportInstruction(component, viewport, parameters, ownsScope, nextScopeInstructions);
  }

  hasSiblingInstructions(instructions) {
    if (instructions === null) {
      return false;
    }

    if (instructions.length > 1) {
      return true;
    }

    return instructions.some(instruction => this.hasSiblingInstructions(instruction.nextScopeInstructions));
  }

  appendInstructions(instructions, scope = null) {
    if (scope === null) {
      scope = this.rootScope.scope;
    }

    for (const instruction of instructions) {
      if (instruction.scope === null) {
        instruction.scope = scope;
      }
    }

    this.appendedInstructions.push(...instructions);
  }

  checkStale(name, instructions) {
    const staleCheck = this.staleChecks[name];

    if (staleCheck === void 0) {
      this.staleChecks[name] = instructions.slice();
      return false;
    }

    if (staleCheck.length !== instructions.length) {
      this.staleChecks[name] = instructions.slice();
      return false;
    }

    for (let i = 0, ii = instructions.length; i < ii; i++) {
      if (staleCheck[i] !== instructions[i]) {
        this.staleChecks[name] = instructions.slice();
        return false;
      }
    }

    return true;
  }

  unknownRoute(route) {
    if (typeof route !== 'string' || route.length === 0) {
      return;
    }

    if (this.options.useConfiguredRoutes && this.options.useDirectRoutes) {
      // TODO: Add missing/unknown route handling
      throw new Error("No matching configured route or component found for '" + route + "'");
    } else if (this.options.useConfiguredRoutes) {
      // TODO: Add missing/unknown route handling
      throw new Error("No matching configured route found for '" + route + "'");
    } else {
      // TODO: Add missing/unknown route handling
      throw new Error("No matching route/component found for '" + route + "'");
    }
  }

  findViewports(instructions, alreadyFound, withoutViewports = false) {
    const found = [];
    const remaining = [];

    while (instructions.length) {
      if (instructions[0].scope === null) {
        instructions[0].scope = this.rootScope.scope;
      }

      const scope = instructions[0].scope;
      const {
        foundViewports,
        remainingInstructions
      } = scope.findViewports(instructions.filter(instruction => instruction.scope === scope), alreadyFound, withoutViewports);
      found.push(...foundViewports);
      remaining.push(...remainingInstructions);
      instructions = instructions.filter(instruction => instruction.scope !== scope);
    }

    return {
      found: found.slice(),
      remaining
    };
  }

  async cancelNavigation(updatedScopeOwners, qInstruction) {
    // TODO: Take care of disabling viewports when cancelling and stateful!
    updatedScopeOwners.forEach(viewport => {
      const abort = viewport.abortContentChange();

      if (abort instanceof Promise) {
        abort.catch(error => {
          throw error;
        });
      }
    });
    await this.navigator.cancel(qInstruction);
    this.processingNavigation = null;
    qInstruction.resolve();
  }

  ensureRootScope() {
    if (!this.rootScope) {
      const root = this.container.get(_runtimeHtml.IAppRoot); // root.config.component shouldn't be used in the end. Metadata will probably eliminate it

      this.rootScope = new _viewportScope.ViewportScope('rootScope', this, root.controller.viewModel, null, true, root.config.component);
    }

    return this.rootScope;
  }

  async replacePaths(instruction) {
    this.rootScope.scope.reparentViewportInstructions();
    let instructions = this.rootScope.scope.hoistedChildren.filter(scope => scope.viewportInstruction !== null && !scope.viewportInstruction.isEmpty()).map(scope => scope.viewportInstruction);
    instructions = this.instructionResolver.cloneViewportInstructions(instructions, true); // The following makes sure right viewport/viewport scopes are set and update
    // whether viewport name is necessary or not

    const alreadyFound = [];
    let {
      found,
      remaining
    } = this.findViewports(instructions, alreadyFound, true);
    let guard = 100;

    while (remaining.length > 0) {
      // Guard against endless loop
      if (guard-- === 0) {
        throw new Error('Failed to find viewport when updating viewer paths.');
      }

      alreadyFound.push(...found);
      ({
        found,
        remaining
      } = this.findViewports(remaining, alreadyFound, true));
    }

    this.activeComponents = instructions;
    this.activeRoute = instruction.route; // First invoke with viewport instructions (should it perhaps get full state?)

    let state = await this.hookManager.invokeTransformToUrl(instructions, instruction);

    if (typeof state !== 'string') {
      // Convert to string if necessary
      state = this.instructionResolver.stringifyViewportInstructions(state, false, true);
    } // Invoke again with string


    state = await this.hookManager.invokeTransformToUrl(state, instruction);
    const query = instruction.query && instruction.query.length ? "?" + instruction.query : ''; // if (instruction.path === void 0 || instruction.path.length === 0 || instruction.path === '/') {

    instruction.path = state + query; // }

    const fullViewportStates = [this.createViewportInstruction(this.instructionResolver.clearViewportInstruction)];
    fullViewportStates.push(...this.instructionResolver.cloneViewportInstructions(instructions, this.statefulHistory));
    instruction.fullStateInstruction = fullViewportStates;

    if ((instruction.title ?? null) === null) {
      const title = await this.getTitle(instructions, instruction);

      if (title !== null) {
        instruction.title = title;
      }
    }

    return Promise.resolve();
  }

  async getTitle(instructions, instruction) {
    // First invoke with viewport instructions
    let title = await this.hookManager.invokeSetTitle(instructions, instruction);

    if (typeof title !== 'string') {
      // Hook didn't return a title, so run title logic
      const componentTitles = this.stringifyTitles(title, instruction);
      title = this.options.title.appTitle;
      title = title.replace("${componentTitles}", componentTitles);
      title = title.replace("${appTitleSeparator}", componentTitles !== '' ? this.options.title.appTitleSeparator : '');
    } // Invoke again with complete string


    title = await this.hookManager.invokeSetTitle(title, instruction);
    return title;
  }

  stringifyTitles(instructions, navigationInstruction) {
    const titles = instructions.map(instruction => this.stringifyTitle(instruction, navigationInstruction)).filter(instruction => (instruction?.length ?? 0) > 0);
    return titles.join(' + ');
  }

  stringifyTitle(instruction, navigationInstruction) {
    if (typeof instruction === 'string') {
      return this.resolveTitle(instruction, navigationInstruction);
    }

    const route = instruction.route ?? null;
    const nextInstructions = instruction.nextScopeInstructions;
    let stringified = ''; // It's a configured route

    if (route !== null) {
      // Already added as part of a configuration, skip to next scope
      if (route === '') {
        return Array.isArray(nextInstructions) ? this.stringifyTitles(nextInstructions, navigationInstruction) : '';
      } else {
        stringified += this.resolveTitle(route, navigationInstruction);
      }
    } else {
      stringified += this.resolveTitle(instruction, navigationInstruction);
    }

    if (Array.isArray(nextInstructions) && nextInstructions.length > 0) {
      let nextStringified = this.stringifyTitles(nextInstructions, navigationInstruction);

      if (nextStringified.length > 0) {
        if (nextInstructions.length !== 1) {
          // TODO: This should really also check that the instructions have value
          nextStringified = "[ " + nextStringified + " ]";
        }

        if (stringified.length > 0) {
          stringified = this.options.title.componentTitleOrder === 'top-down' ? stringified + this.options.title.componentTitleSeparator + nextStringified : nextStringified + this.options.title.componentTitleSeparator + stringified;
        } else {
          stringified = nextStringified;
        }
      }
    }

    return stringified;
  }

  resolveTitle(instruction, navigationInstruction) {
    let title = '';

    if (typeof instruction === 'string') {
      title = instruction;
    } else if (instruction instanceof _viewportInstruction.ViewportInstruction) {
      return instruction.viewport.getTitle(navigationInstruction);
    } else if (instruction instanceof _foundRoute.FoundRoute) {
      const routeTitle = instruction.match?.title;

      if (routeTitle !== void 0) {
        if (typeof routeTitle === 'string') {
          title = routeTitle;
        } else {
          title = routeTitle.call(instruction, instruction, navigationInstruction);
        }
      }
    }

    if (this.options.title.transformTitle !== void 0) {
      title = this.options.title.transformTitle.call(this, title, instruction);
    }

    return title;
  }

  async freeComponents(instruction, excludeComponents, alreadyDone) {
    const component = instruction.componentInstance;
    const viewport = instruction.viewport;

    if (component === null || viewport === null || alreadyDone.some(done => done === component)) {
      return;
    }

    if (!excludeComponents.some(exclude => exclude === component)) {
      await viewport.freeContent(component);
      alreadyDone.push(component);
      return;
    }

    if (instruction.nextScopeInstructions !== null) {
      for (const nextInstruction of instruction.nextScopeInstructions) {
        await this.freeComponents(nextInstruction, excludeComponents, alreadyDone);
      }
    }
  }

  getClosestContainer(viewModelOrElement) {
    if ('context' in viewModelOrElement) {
      return viewModelOrElement.context;
    }

    if ('$controller' in viewModelOrElement) {
      return viewModelOrElement.$controller.context;
    }

    const controller = this.CustomElementFor(viewModelOrElement);

    if (controller === void 0) {
      return null;
    }

    return controller.context;
  }

  getContainer(viewModelOrContainer) {
    if ('resourceResolvers' in viewModelOrContainer) {
      return viewModelOrContainer;
    }

    if ((0, _runtimeHtml.isRenderContext)(viewModelOrContainer)) {
      return viewModelOrContainer.get(_kernel.IContainer);
    }

    if ('$controller' in viewModelOrContainer) {
      return viewModelOrContainer.$controller.context.get(_kernel.IContainer);
    }

    return null;
  } // TODO: This is probably wrong since it caused test fails when in CustomElement.for
  // Fred probably knows and will need to look at it
  // This can most likely also be changed so that the node traversal isn't necessary


  CustomElementFor(node) {
    let cur = node;

    while (cur !== null) {
      const nodeResourceName = cur.nodeName.toLowerCase();

      const controller = _kernel.Metadata.getOwn(_runtimeHtml.CustomElement.name + ":" + nodeResourceName, cur) || _kernel.Metadata.getOwn(_runtimeHtml.CustomElement.name, cur);

      if (controller !== void 0) {
        return controller;
      }

      cur = (0, _runtimeHtml.getEffectiveParentNode)(cur);
    }

    return void 0;
  }

}

exports.Router = Router;
Router.inject = [_kernel.IContainer, _navigator.Navigator, _browserViewerStore.BrowserViewerStore, _linkHandler.LinkHandler, _instructionResolver.InstructionResolver, _hookManager.HookManager, _routerOptions.RouterOptions];
});

;define.alias('@aurelia/router/router.js','@aurelia/router/dist/esm/router.js');
define('@aurelia/router/dist/esm/runner.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.Runner = void 0;

/**
 * Class for running a sequence of steps with values,
 * functions and promises. Stays sync if possible.
 *
 * Usage:
 *
 * ```ts
 * const promise = Runner.run(
 *   'one',
 *   prev => `${previous}, two`,
 *   prev => createPromise(prev), // creates a promise that resolves to `${prev}, three`
 * );
 *
 * // Run can be cancelled with Runner.cancel(promise);
 *
 * const stepsRunner = Runner.runner(promise);
 * const result = await promise;
 * if (stepsRunner?.isResolved) { // Make sure promise wasn't rejected
 *   // result === 'one, two, three'
 * }
 * ```
 */
class Runner {
  constructor() {
    this.isDone = false;
    this.isCancelled = false;
    this.isResolved = false;
    this.isRejected = false;
    this.isAsync = false;
  }

  get stop() {
    return this.isCancelled || this.isRejected;
  }
  /**
   * Runs a set of steps and retuns the last value
   *
   * Steps are processed in sequence and can be either a
   *
   * - value - which is then propagated as input into the next step
   * - function - which is executed in time. The result is replacing the step which is then reprocessed
   * - promise - which is awaited
   *
   * ```ts
   * result = await Runner.run(
   *   'one',
   *   prev => `${previous}, two`,
   *   prev => createPromise(prev), // creates a promise that resolves to `${prev}, three`
   * ); // result === 'one, two, three'
   * ```
   *
   */


  static run(...steps) {
    // debugger; // FIX ARRAY CHECK!
    const $runner = new Runner();
    const value = Runner.$run($runner, ...steps);

    if (value instanceof Promise) {
      this.runners.set(value, $runner);
      value.then(() => {
        $runner.isDone = true;

        if ($runner.isAsync && !$runner.stop) {
          $runner.isResolved = true;
        }

        this.runners.delete(value); // console.log('$runner done', $runner, this.runners);
      }).catch(err => {
        throw err;
      });
    }

    return value;
  }
  /**
   * Gets the runner for a promise returned by Runner.run
   *
   * The runner can be used to check status and outcome of
   * the run as well as cancel it
   *
   */


  static runner(value) {
    if (value instanceof Promise) {
      return Runner.runners.get(value);
    }
  }
  /**
   * Cancels the runner for a promise returned by Runner.run
   *
   * Once a runner has been cancelled, it's no longer possible
   * to retrieve it from the promise
   *
   */


  static cancel(value) {
    const $runner = Runner.runner(value);

    if ($runner !== void 0) {
      $runner.cancel();
    }
  }

  static runAll(steps) {
    const $runner = new Runner();
    const values = Runner.$runAll($runner, steps);

    if ($runner.isAsync) {
      const promise = Promise.all(values);
      this.runners.set(promise, $runner);
      promise.then(() => {
        $runner.isDone = true;

        if ($runner.isAsync && !$runner.stop) {
          $runner.isResolved = true;
        }

        this.runners.delete(promise); // console.log('$runner done', $runner, this.runners);
      }).catch(err => {
        throw err;
      });
      return promise;
    }

    return values;
  }

  static runOne(step) {
    let value; // Iteratively resolve Functions (until value or Promise)

    while (step instanceof Function) {
      step = step(value);

      if (!(step instanceof Function) && !(step instanceof Promise)) {
        // === isValue(step)
        value = step;
      }
    } // In case there wasn't a Function before the value


    if (!(step instanceof Function) && !(step instanceof Promise)) {
      // === isValue(step)
      value = step;
    } // If we've got a Promise, run the remaining


    if (step instanceof Promise) {
      return step.then(resolvedValue => {
        return Runner.runOne(resolvedValue);
      }).catch(err => {
        throw err;
      });
    }

    return value;
  }

  cancel() {
    this.isCancelled = true;
  }

  static $run($runner, ...steps) {
    let step;

    while (steps.length > 0 && !$runner.stop) {
      step = steps.shift(); // Iteratively resolve Functions (until value or Promise)

      while (step instanceof Function && !$runner.stop) {
        step = step($runner.value);

        if (!(step instanceof Function) && !(step instanceof Promise)) {
          // === isValue(step)
          $runner.value = step;
        }
      } // In case there wasn't a Function before the value


      if (!(step instanceof Function) && !(step instanceof Promise)) {
        // === isValue(step)
        $runner.value = step;
      } // Run steps until done or we get a Promise


      if (step instanceof Promise) {
        break;
      }
    } // If we've got a Promise, run the remaining


    if (step instanceof Promise && !$runner.stop) {
      $runner.isAsync = true;
      return step.then(resolvedValue => {
        return Runner.$run($runner, resolvedValue, ...steps);
      }).catch(err => {
        $runner.isRejected = true;
        throw err;
      });
    }

    return $runner.value;
  }

  static $runAll($runner, steps) {
    const results = new Array(steps.length);
    steps.forEach((step, index) => {
      // Iteratively resolve Functions (until value or Promise)
      while (step instanceof Function) {
        step = step(results[index]);

        if (!(step instanceof Function) && !(step instanceof Promise)) {
          // === isValue(step)
          results[index] = step;
        }
      } // In case there wasn't a Function before the value


      if (!(step instanceof Function)) {
        // === isValue(step)
        results[index] = step;
      } // If we've got a Promise, run the remaining


      if (step instanceof Promise) {
        $runner.isAsync = true;
      }
    });
    return results;
  }

}

exports.Runner = Runner;
Runner.runners = new WeakMap();
});

;define.alias('@aurelia/router/runner.js','@aurelia/router/dist/esm/runner.js');
define('@aurelia/router/dist/esm/scope.js',['require','exports','module','./viewport-scope.js','./found-route.js','./type-resolvers.js','./viewport.js','./utils.js','./collection.js','./route-recognizer.js','./runner.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.Scope = void 0;

var _viewportScope = require("./viewport-scope.js");

var _foundRoute = require("./found-route.js");

var _typeResolvers = require("./type-resolvers.js");

var _viewport = require("./viewport.js");

var _utils = require("./utils.js");

var _collection = require("./collection.js");

var _routeRecognizer = require("./route-recognizer.js");

var _runner = require("./runner.js");

/**
 * @internal - Shouldn't be used directly
 */
class Scope {
  constructor(router, hasScope, owningScope, viewport = null, viewportScope = null, rootComponentType = null) {
    this.router = router;
    this.hasScope = hasScope;
    this.owningScope = owningScope;
    this.viewport = viewport;
    this.viewportScope = viewportScope;
    this.rootComponentType = rootComponentType;
    this.id = '.';
    this.parent = null;
    this.children = [];
    this.replacedChildren = [];
    this.path = null;
    this.enabled = true; // Support collection feature in viewport scopes

    this.childCollections = {};
    this.owningScope = owningScope ?? this;
    this.scope = this.hasScope ? this : this.owningScope.scope; // console.log('Created scope', this.toString());
  }

  toString(recurse = false) {
    return `${this.owningScope !== this ? this.owningScope.toString() : ''}/${this.owner.toString()}` + // eslint-disable-next-line prefer-template
    `${recurse ? `\n` + this.children.map(child => child.toString(true)).join('') : ''}`;
  }

  get isViewport() {
    return this.viewport !== null;
  }

  get isViewportScope() {
    return this.viewportScope !== null;
  }

  get passThroughScope() {
    return this.isViewportScope && this.viewportScope.passThroughScope;
  }

  get owner() {
    if (this.isViewport) {
      return this.viewport;
    }

    if (this.isViewportScope) {
      return this.viewportScope;
    }

    return null;
  }

  get enabledChildren() {
    return this.children.filter(scope => scope.enabled);
  }

  get hoistedChildren() {
    const scopes = this.enabledChildren;

    while (scopes.some(scope => scope.passThroughScope)) {
      for (const scope of scopes.slice()) {
        if (scope.passThroughScope) {
          const index = scopes.indexOf(scope);
          scopes.splice(index, 1, ...scope.enabledChildren);
        }
      }
    }

    return scopes;
  }

  get enabledViewports() {
    return this.children.filter(scope => scope.isViewport && scope.enabled).map(scope => scope.viewport);
  }

  get viewportInstruction() {
    if (this.isViewportScope) {
      return this.viewportScope.content;
    }

    if (this.isViewport) {
      return this.viewport.content.content;
    }

    return null;
  }

  get parentNextContentAction() {
    if (this.parent === null) {
      return '';
    }

    const parentAction = this.parent.owner.nextContentAction;

    if (parentAction === 'swap' || parentAction === 'skip') {
      return parentAction;
    }

    return this.parent.parentNextContentAction;
  }

  getEnabledViewports(viewportScopes) {
    return viewportScopes.filter(scope => !scope.isViewportScope).map(scope => scope.viewport).reduce((viewports, viewport) => {
      viewports[viewport.name] = viewport;
      return viewports;
    }, {});
  }

  getOwnedViewports(includeDisabled = false) {
    return this.allViewports(includeDisabled).filter(viewport => viewport.owningScope === this);
  }

  getOwnedScopes(includeDisabled = false) {
    const scopes = this.allScopes(includeDisabled).filter(scope => scope.owningScope === this); // Hoist children to pass through scopes

    for (const scope of scopes.slice()) {
      if (scope.passThroughScope) {
        const index = scopes.indexOf(scope);
        scopes.splice(index, 1, ...scope.getOwnedScopes());
      }
    }

    return scopes;
  }

  findInstructions(instruction) {
    let route = new _foundRoute.FoundRoute();

    if (typeof instruction === 'string') {
      const instructions = this.router.instructionResolver.parseViewportInstructions(instruction);

      if (this.router.options.useConfiguredRoutes && !this.router.hasSiblingInstructions(instructions)) {
        const foundRoute = this.findMatchingRoute(instruction);

        if (foundRoute?.foundConfiguration ?? false) {
          route = foundRoute;
        } else {
          if (this.router.options.useDirectRoutes) {
            route.instructions = instructions;

            if (route.instructions.length > 0) {
              const nextInstructions = route.instructions[0].nextScopeInstructions ?? [];
              route.remaining = this.router.instructionResolver.stringifyViewportInstructions(nextInstructions); // TODO: Verify that it's okay to leave this in

              route.instructions[0].nextScopeInstructions = null;
            }
          }
        }
      } else if (this.router.options.useDirectRoutes) {
        route.instructions = instructions;
      }
    } else {
      route.instructions = instruction;
    }

    for (const instr of route.instructions) {
      if (instr.scope === null) {
        instr.scope = this;
      }
    }

    return route;
  } // Note: This can't change state other than the instructions!


  findViewports(instructions, alreadyFound, disregardViewports = false) {
    const foundViewports = [];
    let remainingInstructions = [];
    const ownedScopes = this.getOwnedScopes(); // Get a shallow copy of all available manual viewport scopes

    const viewportScopes = ownedScopes.filter(scope => scope.isViewportScope).map(scope => scope.viewportScope);
    const availableViewportScopes = viewportScopes.filter(viewportScope => alreadyFound.every(found => found.viewportScope !== viewportScope)); // Get a shallow copy of all available viewports

    const availableViewports = { ...this.getEnabledViewports(ownedScopes)
    };

    for (const instruction of alreadyFound.filter(found => found.scope === this)) {
      availableViewports[instruction.viewportName] = null;
    }

    const viewportInstructions = new _collection.Collection(...instructions.slice());
    let instruction = null; // The viewport scope is already known

    while ((instruction = viewportInstructions.next()) !== null) {
      if (instruction.viewportScope !== null && !this.router.instructionResolver.isAddViewportInstruction(instruction)) {
        remainingInstructions.push(...this.foundViewportScope(instruction, instruction.viewportScope));
        foundViewports.push(instruction);
        (0, _utils.arrayRemove)(availableViewportScopes, available => available === instruction.viewportScope);
        viewportInstructions.removeCurrent();
      }
    } // The viewport is already known


    if (!disregardViewports) {
      while ((instruction = viewportInstructions.next()) !== null) {
        if (instruction.viewport !== null) {
          remainingInstructions.push(...this.foundViewport(instruction, instruction.viewport, disregardViewports));
          foundViewports.push(instruction);
          availableViewports[instruction.viewport.name] = null;
          viewportInstructions.removeCurrent();
        }
      }
    } // Viewport scopes have priority


    while ((instruction = viewportInstructions.next()) !== null) {
      for (let viewportScope of viewportScopes) {
        if (viewportScope.acceptSegment(instruction.componentName)) {
          if (Array.isArray(viewportScope.source)) {
            // console.log('available', viewportScope.available, source);
            let available = availableViewportScopes.find(available => available.name === viewportScope.name);

            if (available === void 0 || this.router.instructionResolver.isAddViewportInstruction(instruction)) {
              const item = viewportScope.addSourceItem();
              available = this.getOwnedScopes().filter(scope => scope.isViewportScope).map(scope => scope.viewportScope).find(viewportScope => viewportScope.sourceItem === item);
            }

            viewportScope = available;
          }

          remainingInstructions.push(...this.foundViewportScope(instruction, viewportScope));
          foundViewports.push(instruction);
          (0, _utils.arrayRemove)(availableViewportScopes, available => available === instruction.viewportScope);
          viewportInstructions.removeCurrent();
          break;
        }
      }
    } // Configured viewport is ruling


    while ((instruction = viewportInstructions.next()) !== null) {
      instruction.needsViewportDescribed = true;

      for (const name in availableViewports) {
        const viewport = availableViewports[name]; // TODO: Also check if (resolved) component wants a specific viewport

        if (viewport?.wantComponent(instruction.componentName)) {
          const remaining = this.foundViewport(instruction, viewport, disregardViewports, true);
          foundViewports.push(instruction);
          remainingInstructions.push(...remaining);
          availableViewports[name] = null;
          viewportInstructions.removeCurrent();
          break;
        }
      }
    } // Next in line is specified viewport (but not if we're disregarding viewports)


    if (!disregardViewports) {
      while ((instruction = viewportInstructions.next()) !== null) {
        const name = instruction.viewportName;

        if (!name || !name.length) {
          continue;
        }

        const newScope = instruction.ownsScope;

        if (!this.getEnabledViewports(ownedScopes)[name]) {
          continue; // TODO: No longer pre-creating viewports. Evaluate!

          this.addViewport(name, null, {
            scope: newScope,
            forceDescription: true
          });
          availableViewports[name] = this.getEnabledViewports(ownedScopes)[name];
        }

        const viewport = availableViewports[name];

        if (viewport?.acceptComponent(instruction.componentName)) {
          const remaining = this.foundViewport(instruction, viewport, disregardViewports, true);
          foundViewports.push(instruction);
          remainingInstructions.push(...remaining);
          availableViewports[name] = null;
          viewportInstructions.removeCurrent();
        }
      }
    } // Finally, only one accepting viewport left?


    while ((instruction = viewportInstructions.next()) !== null) {
      const remainingViewports = [];

      for (const name in availableViewports) {
        const viewport = availableViewports[name];

        if (viewport?.acceptComponent(instruction.componentName)) {
          remainingViewports.push(viewport);
        }
      }

      if (remainingViewports.length === 1) {
        const viewport = remainingViewports.shift();
        const remaining = this.foundViewport(instruction, viewport, disregardViewports, true);
        foundViewports.push(instruction);
        remainingInstructions.push(...remaining);
        availableViewports[viewport.name] = null;
        viewportInstructions.removeCurrent();
      }
    } // If we're ignoring viewports, we now match them anyway


    if (disregardViewports) {
      while ((instruction = viewportInstructions.next()) !== null) {
        let viewport = instruction.viewport;

        if (!viewport) {
          const name = instruction.viewportName;

          if ((name?.length ?? 0) === 0) {
            continue;
          }

          const newScope = instruction.ownsScope;

          if (!this.getEnabledViewports(ownedScopes)[name]) {
            continue; // TODO: No longer pre-creating viewports. Evaluate!

            this.addViewport(name, null, {
              scope: newScope,
              forceDescription: true
            });
            availableViewports[name] = this.getEnabledViewports(ownedScopes)[name];
          }

          viewport = availableViewports[name];
        }

        if (viewport?.acceptComponent(instruction.componentName)) {
          const remaining = this.foundViewport(instruction, viewport, disregardViewports);
          foundViewports.push(instruction);
          remainingInstructions.push(...remaining);
          availableViewports[viewport.name] = null;
          viewportInstructions.removeCurrent();
        }
      }
    }

    remainingInstructions = [...viewportInstructions, ...remainingInstructions];
    return {
      foundViewports,
      remainingInstructions
    };
  }

  foundViewportScope(instruction, viewportScope) {
    instruction.viewportScope = viewportScope;
    instruction.needsViewportDescribed = false;
    const remaining = instruction.nextScopeInstructions?.slice() ?? [];

    for (const rem of remaining) {
      if (rem.scope === null) {
        rem.scope = viewportScope.scope.scope;
      }
    }

    return remaining;
  }

  foundViewport(instruction, viewport, withoutViewports, doesntNeedViewportDescribed = false) {
    instruction.setViewport(viewport);

    if (doesntNeedViewportDescribed) {
      instruction.needsViewportDescribed = false;
    }

    const remaining = instruction.nextScopeInstructions?.slice() ?? [];

    for (const rem of remaining) {
      if (rem.scope === null) {
        rem.scope = viewport.scope;
      }
    }

    return remaining;
  }

  addViewport(name, connectedCE, options = {}) {
    let viewport = this.getEnabledViewports(this.getOwnedScopes())[name]; // Each au-viewport element has its own Viewport

    if ((connectedCE ?? null) !== null && (viewport?.connectedCE ?? null) !== null && viewport.connectedCE !== connectedCE) {
      viewport.enabled = false;
      viewport = this.getOwnedViewports(true).find(child => child.name === name && child.connectedCE === connectedCE) ?? null;

      if ((viewport ?? null) !== null) {
        viewport.enabled = true;
      }
    }

    if ((viewport ?? null) === null) {
      viewport = new _viewport.Viewport(this.router, name, connectedCE, this.scope, !!options.scope, options);
      this.addChild(viewport.connectedScope);
    }

    if ((connectedCE ?? null) !== null) {
      viewport.setConnectedCE(connectedCE, options);
    }

    return viewport;
  }

  removeViewport(viewport, connectedCE) {
    if ((connectedCE ?? null) !== null || viewport.remove(connectedCE)) {
      this.removeChild(viewport.connectedScope);
      return true;
    }

    return false;
  }

  addViewportScope(name, connectedCE, options = {}) {
    const viewportScope = new _viewportScope.ViewportScope(name, this.router, connectedCE, this.scope, true, null, options);
    this.addChild(viewportScope.connectedScope);
    return viewportScope;
  }

  removeViewportScope(viewportScope) {
    // viewportScope.remove();
    this.removeChild(viewportScope.connectedScope);
    return true;
  }

  addChild(scope) {
    if (!this.children.some(vp => vp === scope)) {
      if (scope.parent !== null) {
        scope.parent.removeChild(scope);
      }

      this.children.push(scope);
      scope.parent = this;
    }
  }

  removeChild(scope) {
    const index = this.children.indexOf(scope);

    if (index >= 0) {
      this.children.splice(index, 1);
      scope.parent = null;
    }
  }

  clearReplacedChildren() {
    this.replacedChildren = [];
  }

  disableReplacedChildren() {
    this.replacedChildren = this.enabledChildren;

    for (const scope of this.replacedChildren) {
      scope.enabled = false;
    }
  }

  reenableReplacedChildren() {
    for (const scope of this.replacedChildren) {
      scope.enabled = true;
    }
  }

  allViewports(includeDisabled = false, includeReplaced = false) {
    return this.allScopes(includeDisabled, includeReplaced).filter(scope => scope.isViewport).map(scope => scope.viewport);
  }

  allScopes(includeDisabled = false, includeReplaced = false) {
    const scopes = includeDisabled ? this.children.slice() : this.enabledChildren;

    for (const scope of scopes.slice()) {
      scopes.push(...scope.allScopes(includeDisabled, includeReplaced));
    }

    return scopes;
  }

  reparentViewportInstructions() {
    const scopes = this.hoistedChildren.filter(scope => scope.viewportInstruction !== null && scope.viewportInstruction.componentName);

    if (!scopes.length) {
      return null;
    }

    for (const scope of scopes) {
      const childInstructions = scope.reparentViewportInstructions();
      scope.viewportInstruction.nextScopeInstructions = childInstructions !== null && childInstructions.length > 0 ? childInstructions : null;
    }

    return scopes.map(scope => scope.viewportInstruction);
  }

  findMatchingRoute(path) {
    if (this.isViewportScope && !this.passThroughScope) {
      return this.findMatchingRouteInRoutes(path, this.viewportScope.getRoutes());
    }

    if (this.isViewport) {
      return this.findMatchingRouteInRoutes(path, this.viewport.getRoutes());
    } // TODO: Match specified names here


    for (const child of this.enabledChildren) {
      const found = child.findMatchingRoute(path);

      if (found !== null) {
        return found;
      }
    }

    return null;
  }

  canLoad(recurse) {
    const results = _runner.Runner.runAll(this.children.map(child => child.viewport !== null ? child.viewport.canLoad(recurse) : child.canLoad(recurse)));

    if (results instanceof Promise) {
      return results.then(resolvedResults => resolvedResults.every(result => result));
    }

    return results.every(result => result);
  }

  canUnload() {
    const results = _runner.Runner.runAll(this.children.map(child => child.viewport !== null ? child.viewport.canUnload() : child.canUnload()));

    if (results instanceof Promise) {
      return results.then(resolvedResults => {
        return resolvedResults.every(result => result);
      });
    }

    return results.every(result => result);
  }

  load(recurse) {
    const results = _runner.Runner.runAll(this.children.map(child => child.viewport !== null ? child.viewport.load(recurse) : child.load(recurse)));

    if (results instanceof Promise) {
      return results;
    }
  }

  unload(recurse) {
    const results = _runner.Runner.runAll(this.children.map(child => child.viewport !== null ? child.viewport.unload(recurse) : child.unload(recurse)));

    if (results instanceof Promise) {
      return results;
    }
  }

  removeContent() {
    const results = _runner.Runner.runAll(this.children.map(child => child.viewport !== null ? child.viewport.removeContent() : child.removeContent()));

    if (results instanceof Promise) {
      return results;
    }
  }

  findMatchingRouteInRoutes(path, routes) {
    if (!Array.isArray(routes)) {
      return null;
    }

    routes = routes.map(route => this.ensureProperRoute(route));
    const cRoutes = routes.map(route => ({
      path: route.path,
      handler: route
    }));

    for (let i = 0, ii = cRoutes.length; i < ii; ++i) {
      const cRoute = cRoutes[i];
      cRoutes.push({ ...cRoute,
        path: `${cRoute.path}/*remainingPath`
      });
    }

    const found = new _foundRoute.FoundRoute();

    if (path.startsWith('/') || path.startsWith('+')) {
      path = path.slice(1);
    }

    const recognizer = new _routeRecognizer.RouteRecognizer();
    recognizer.add(cRoutes);
    const result = recognizer.recognize(path);

    if (result !== null) {
      found.match = result.endpoint.route.handler;
      found.matching = path;
      const $params = { ...result.params
      };

      if ($params.remainingPath !== void 0) {
        found.remaining = $params.remainingPath;
        Reflect.deleteProperty($params, 'remainingPath');
        found.matching = found.matching.slice(0, found.matching.indexOf(found.remaining));
      }

      found.params = $params;
    }

    if (found.foundConfiguration) {
      // clone it so config doesn't get modified
      found.instructions = this.router.instructionResolver.cloneViewportInstructions(found.match.instructions, false, true);
      const instructions = found.instructions.slice();

      while (instructions.length > 0) {
        const instruction = instructions.shift();
        instruction.addParameters(found.params);
        instruction.route = '';

        if (instruction.nextScopeInstructions !== null) {
          instructions.unshift(...instruction.nextScopeInstructions);
        }
      }

      if (found.instructions.length > 0) {
        found.instructions[0].route = found;
      }
    }

    return found;
  }

  ensureProperRoute(route) {
    if (route.id === void 0) {
      route.id = route.path;
    }

    if (route.instructions === void 0) {
      route.instructions = [{
        component: route.component,
        viewport: route.viewport,
        parameters: route.parameters,
        children: route.children
      }];
    }

    route.instructions = _typeResolvers.NavigationInstructionResolver.toViewportInstructions(this.router, route.instructions);
    return route;
  }

}

exports.Scope = Scope;
});

;define.alias('@aurelia/router/scope.js','@aurelia/router/dist/esm/scope.js');
define('@aurelia/router/dist/esm/state-coordinator.js',['require','exports','module','./open-promise.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.StateCoordinator = exports.Entity = void 0;

var _openPromise = require("./open-promise.js");

class Entity {
  constructor(entity) {
    this.entity = entity;
    this.running = false;
    this.states = [];
    this.checkedStates = [];
    this.syncState = null;
    this.syncPromise = null;
  }

}

exports.Entity = Entity;

class StateCoordinator {
  constructor() {
    this.entities = [];
    this.hasAllEntities = false;
    this.syncStates = new Map();
    this.checkedSyncStates = new Set();
  } // public constructor(@ILogger private readonly logger: ILogger) {
  //   this.logger = logger.root.scopeTo('StateCoordinator');
  //   this.logger.trace('constructor()');
  // }


  addSyncState(state) {
    const openPromise = new _openPromise.OpenPromise();
    this.syncStates.set(state, openPromise);
  }

  addEntity(entity) {
    // console.log('Entity received', entity);
    const ent = new Entity(entity);
    this.entities.push(ent);
    this.resetSyncStates();
    return ent;
  }

  addEntityState(entity, state) {
    // console.log(`#### EntityState received ${state}`, (entity as any).name);
    let ent = this.entities.find(e => e.entity === entity);

    if (ent === void 0) {
      ent = this.addEntity(entity);
    }

    ent.states.push(state);
    this.checkSyncState(state);
  }

  syncState(state, entity = null) {
    const openPromise = this.syncStates.get(state);

    if (openPromise === void 0) {
      return;
    }

    if (entity !== null) {
      const ent = this.entities.find(e => e.entity === entity);

      if (ent?.syncPromise === null && openPromise.isPending) {
        ent.syncState = state;
        ent.syncPromise = new _openPromise.OpenPromise();
        ent.checkedStates.push(state);
        this.checkedSyncStates.add(state);
        Promise.resolve().then(() => {
          this.checkSyncState(state);
        }).catch(err => {
          throw err;
        });
        return ent.syncPromise.promise;
      }
    } // this.checkSyncState(state);


    return openPromise.promise;
  }

  checkingSyncState(state) {
    return this.syncStates.has(state);
  }

  finalEntity() {
    this.hasAllEntities = true; // console.log('Final entity received', this.entities.length);

    this.syncStates.forEach((_promise, state) => this.checkSyncState(state));
  }

  finalize() {}

  cancel() {} // A new navigation should cancel replaced instructions


  cancelReplaced(navigation) {}

  checkSyncState(state) {
    // console.log('StateCoordinator check state', state, this);
    const openPromise = this.syncStates.get(state);

    if (openPromise === void 0) {
      return;
    }

    if (this.hasAllEntities && openPromise.isPending && // Check that this state has been done by all state entities and if so resolve the promise
    this.entities.every(ent => ent.states.includes(state)) && ( // Check that this state has been checked (reached) by all state entities and if so resolve the promise
    !this.checkedSyncStates.has(state) || this.entities.every(ent => ent.checkedStates.includes(state)))) {
      for (const entity of this.entities) {
        if (entity.syncState === state) {
          // console.log('Resolving entity promise for ', state, (entity.entity as any).toString());
          entity.syncPromise?.resolve();
          entity.syncPromise = null;
          entity.syncState = null;
        }
      }

      openPromise.resolve(); // console.log('#### StateCoordinator state resolved', state /*, this */);
    }
  }

  resetSyncStates() {
    this.syncStates.forEach((promise, state) => {
      if (!promise.isPending && !this.entities.every(entity => entity.states.includes(state))) {
        this.addSyncState(state);
      }
    });
  }

}

exports.StateCoordinator = StateCoordinator;
});

;define.alias('@aurelia/router/state-coordinator.js','@aurelia/router/dist/esm/state-coordinator.js');
define('@aurelia/router/dist/esm/task-queue.js',['require','exports','module','@aurelia/kernel'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.TaskQueue = exports.QueueTask = void 0;

var _kernel = require("@aurelia/kernel");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * @internal - Shouldn't be used directly
 */
class QueueTask {
  constructor(taskQueue, item, cost = 0) {
    this.taskQueue = taskQueue;
    this.item = item;
    this.cost = cost;
    this.done = false;
    this.promise = new Promise((resolve, reject) => {
      this.resolve = () => {
        this.taskQueue.resolve(this, resolve);
      };

      this.reject = reason => {
        this.taskQueue.reject(this, reject, reason);
      };
    });
  }

  async execute() {
    if ('execute' in this.item) {
      await this.item.execute(this);
    } else {
      await this.item(this);
    }
  }

  wait() {
    return this.promise;
  }

}
/**
 * A first-in-first-out task queue that only processes the next queued item
 * when the current one has been resolved or rejected. If a callback function
 * is specified, it receives the queued items as tasks one at a time. If no
 * callback is specified, the tasks themselves are either executed (if a
 * function) or the execute method in them are run. The executed function
 * should resolve or reject the task when processing is done.
 * Enqueued items' tasks can be awaited. Enqueued items can specify an
 * (arbitrary) execution cost and the queue can be set up (started) to
 * only process a specific amount of execution cost per RAF/tick.
 *
 * @internal - Shouldn't be used directly.
 */


exports.QueueTask = QueueTask;

class TaskQueue {
  constructor(callback) {
    this.callback = callback;
    this.pending = [];
    this.processing = null;
    this.allowedExecutionCostWithinTick = null;
    this.currentExecutionCostInCurrentTick = 0;
    this.platform = null;
    this.task = null;
  }

  get isActive() {
    return this.task !== null;
  }

  get length() {
    return this.pending.length;
  }

  start(options) {
    if (this.isActive) {
      throw new Error('TaskQueue has already been started');
    }

    this.platform = options.platform;
    this.allowedExecutionCostWithinTick = options.allowedExecutionCostWithinTick;
    this.task = this.platform.domWriteQueue.queueTask(this.dequeue, {
      persistent: true
    });
  }

  stop() {
    if (!this.isActive) {
      throw new Error('TaskQueue has not been started');
    }

    this.task.cancel();
    this.task = null;
    this.allowedExecutionCostWithinTick = null;
    this.clear();
  }

  enqueue(itemOrItems, costOrCosts) {
    const list = Array.isArray(itemOrItems);
    const items = list ? itemOrItems : [itemOrItems];
    const costs = items.map((value, index) => !Array.isArray(costOrCosts) ? costOrCosts : costOrCosts[index]).map(value => value !== undefined ? value : 1);
    const tasks = [];

    for (const item of items) {
      tasks.push(item instanceof QueueTask ? item : this.createQueueTask(item, costs.shift())); // TODO: Get cancellable in as well
    }

    this.pending.push(...tasks);
    this.dequeue();
    return list ? tasks : tasks[0];
  }

  createQueueTask(item, cost) {
    return new QueueTask(this, item, cost);
  }

  dequeue(delta) {
    if (this.processing !== null) {
      return;
    }

    if (delta !== undefined) {
      this.currentExecutionCostInCurrentTick = 0;
    }

    if (!this.pending.length) {
      return;
    }

    if (this.allowedExecutionCostWithinTick !== null && delta === undefined && this.currentExecutionCostInCurrentTick + (this.pending[0].cost || 0) > this.allowedExecutionCostWithinTick) {
      return;
    }

    this.processing = this.pending.shift() || null;

    if (this.processing) {
      this.currentExecutionCostInCurrentTick += this.processing.cost ?? 0;

      if (this.callback !== void 0) {
        this.callback(this.processing);
      } else {
        // Don't need to await this since next task won't be dequeued until
        // executed function is resolved
        this.processing.execute().catch(error => {
          throw error;
        });
      }
    }
  }

  clear() {
    this.pending.splice(0, this.pending.length);
  }

  resolve(task, resolve) {
    resolve();
    this.processing = null;
    this.dequeue();
  }

  reject(task, reject, reason) {
    reject(reason);
    this.processing = null;
    this.dequeue();
  }

}

exports.TaskQueue = TaskQueue;

__decorate([_kernel.bound], TaskQueue.prototype, "dequeue", null);
});

;define.alias('@aurelia/router/task-queue.js','@aurelia/router/dist/esm/task-queue.js');
define('@aurelia/router/dist/esm/type-resolvers.js',['require','exports','module','@aurelia/runtime-html','./viewport.js','./viewport-instruction.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.NavigationInstructionResolver = exports.ViewportHandleResolver = exports.ComponentAppellationResolver = void 0;

var _runtimeHtml = require("@aurelia/runtime-html");

var _viewport = require("./viewport.js");

var _viewportInstruction = require("./viewport-instruction.js");

const ComponentAppellationResolver = {
  isName(component) {
    return typeof component === 'string';
  },

  isType(component) {
    return _runtimeHtml.CustomElement.isType(component);
  },

  isInstance(component) {
    return !ComponentAppellationResolver.isName(component) && !ComponentAppellationResolver.isType(component);
  },

  getName(component) {
    if (ComponentAppellationResolver.isName(component)) {
      return component;
    } else if (ComponentAppellationResolver.isType(component)) {
      return _runtimeHtml.CustomElement.getDefinition(component).name;
    } else {
      return ComponentAppellationResolver.getName(component.constructor);
    }
  },

  getType(component) {
    if (ComponentAppellationResolver.isName(component)) {
      return null;
    } else if (ComponentAppellationResolver.isType(component)) {
      return component;
    } else {
      return component.constructor;
    }
  },

  getInstance(component) {
    if (ComponentAppellationResolver.isName(component) || ComponentAppellationResolver.isType(component)) {
      return null;
    } else {
      return component;
    }
  }

};
exports.ComponentAppellationResolver = ComponentAppellationResolver;
const ViewportHandleResolver = {
  isName(viewport) {
    return typeof viewport === 'string';
  },

  isInstance(viewport) {
    return viewport instanceof _viewport.Viewport;
  },

  getName(viewport) {
    if (ViewportHandleResolver.isName(viewport)) {
      return viewport;
    } else {
      return viewport ? viewport.name : null;
    }
  },

  getInstance(viewport) {
    if (ViewportHandleResolver.isName(viewport)) {
      return null;
    } else {
      return viewport;
    }
  }

};
exports.ViewportHandleResolver = ViewportHandleResolver;
const NavigationInstructionResolver = {
  createViewportInstructions(router, navigationInstructions, options) {
    options = options || {};
    let scope = null;

    if (options.context) {
      scope = router.findScope(options.context);

      if (typeof navigationInstructions === 'string') {
        // If it's not from scope root, figure out which scope
        if (!navigationInstructions.startsWith('/')) {
          // Scope modifications
          if (navigationInstructions.startsWith('.')) {
            // The same as no scope modification
            if (navigationInstructions.startsWith('./')) {
              navigationInstructions = navigationInstructions.slice(2);
            } // Find out how many scopes upwards we should move


            while (navigationInstructions.startsWith('../')) {
              scope = scope.parent || scope;
              navigationInstructions = navigationInstructions.slice(3);
            }
          }

          if (scope.path !== null) {
            navigationInstructions = `${scope.path}/${navigationInstructions}`;
            scope = router.rootScope.scope;
          }
        } else {
          // Specified root scope with /
          scope = router.rootScope.scope;
        }
      } else {
        navigationInstructions = NavigationInstructionResolver.toViewportInstructions(router, navigationInstructions);

        for (const instruction of navigationInstructions) {
          if (instruction.scope === null) {
            instruction.scope = scope;
          }
        }
      }
    }

    return {
      instructions: navigationInstructions,
      scope
    };
  },

  toViewportInstructions(router, navigationInstructions) {
    if (!Array.isArray(navigationInstructions)) {
      return NavigationInstructionResolver.toViewportInstructions(router, [navigationInstructions]);
    }

    const instructions = [];

    for (const instruction of navigationInstructions) {
      if (typeof instruction === 'string') {
        instructions.push(...router.instructionResolver.parseViewportInstructions(instruction));
      } else if (instruction instanceof _viewportInstruction.ViewportInstruction) {
        instructions.push(instruction);
      } else if (instruction.component) {
        const viewportComponent = instruction;
        const newInstruction = router.createViewportInstruction(viewportComponent.component, viewportComponent.viewport, viewportComponent.parameters);

        if (viewportComponent.children !== void 0 && viewportComponent.children !== null) {
          newInstruction.nextScopeInstructions = NavigationInstructionResolver.toViewportInstructions(router, viewportComponent.children);
        }

        instructions.push(newInstruction);
      } else {
        instructions.push(router.createViewportInstruction(instruction));
      }
    }

    return instructions;
  }

};
exports.NavigationInstructionResolver = NavigationInstructionResolver;
});

;define.alias('@aurelia/router/type-resolvers.js','@aurelia/router/dist/esm/type-resolvers.js');
define('@aurelia/router/dist/esm/utils.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.arrayRemove = arrayRemove;
exports.resolvePossiblePromise = resolvePossiblePromise;
exports.deprecationWarning = deprecationWarning;

/**
 * @internal - Shouldn't be used directly
 */
function arrayRemove(arr, func) {
  const removed = [];
  let arrIndex = arr.findIndex(func);

  while (arrIndex >= 0) {
    removed.push(arr.splice(arrIndex, 1)[0]);
    arrIndex = arr.findIndex(func);
  }

  return removed;
}

function resolvePossiblePromise(value, callback) {
  // If we've got a Promise, wait for it's resolve
  if (value instanceof Promise) {
    return value.then(resolvedValue => {
      if (callback !== void 0) {
        callback(resolvedValue);
      }

      return resolvedValue;
    });
  }

  if (callback !== void 0) {
    callback(value);
  }

  return value;
}

function deprecationWarning(oldFeature, newFeature) {
  console.warn(`[Deprecated] The ${oldFeature} has been deprecated. Please use the ${newFeature} instead.`);
}
});

;define.alias('@aurelia/router/utils.js','@aurelia/router/dist/esm/utils.js');
define('@aurelia/router/dist/esm/viewport-content.js',['require','exports','module','@aurelia/runtime-html','./parser.js','./viewport-instruction.js','./navigation.js','./runner.js','./awaitable-map.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.ViewportContent = exports.ContentStatus = void 0;

var _runtimeHtml = require("@aurelia/runtime-html");

var _parser = require("./parser.js");

var _viewportInstruction = require("./viewport-instruction.js");

var _navigation = require("./navigation.js");

var _runner = require("./runner.js");

var _awaitableMap = require("./awaitable-map.js");

/**
 * @internal - Shouldn't be used directly
 */
var ContentStatus;
exports.ContentStatus = ContentStatus;

(function (ContentStatus) {
  ContentStatus[ContentStatus["none"] = 0] = "none";
  ContentStatus[ContentStatus["created"] = 1] = "created";
  ContentStatus[ContentStatus["activated"] = 3] = "activated";
})(ContentStatus || (exports.ContentStatus = ContentStatus = {}));
/**
 * @internal - Shouldn't be used directly
 */


class ViewportContent {
  constructor( // Can (and wants) be a (resolved) type or a string (to be resolved later)
  // public content: ViewportInstruction = new ViewportInstruction(''),
  content = _viewportInstruction.ViewportInstruction.create(null, ''), instruction = new _navigation.Navigation({
    instruction: '',
    fullStateInstruction: ''
  }), connectedCE = null) {
    this.content = content;
    this.instruction = instruction; // public contentStatus: ContentStatus = ContentStatus.none;

    this.contentStates = new _awaitableMap.AwaitableMap(); // public contentStates: Map<ContentState, undefined> = new Map();

    this.loaded = false;
    this.fromCache = false;
    this.fromHistory = false;
    this.reentry = false; // If we've got a container, we're good to resolve type

    if (!this.content.isComponentType() && (connectedCE?.container ?? null) !== null) {
      this.content.componentType = this.toComponentType(connectedCE.container);
    }
  }

  get componentInstance() {
    return this.content.componentInstance;
  }

  get viewport() {
    return this.content.viewport;
  }

  equalComponent(other) {
    return this.content.sameComponent(other.content);
  }

  equalParameters(other) {
    return this.content.sameComponent(other.content, true) && // TODO: Review whether query is relevant
    this.instruction.query === other.instruction.query;
  }

  reentryBehavior() {
    return this.content.componentInstance !== null && 'reentryBehavior' in this.content.componentInstance && this.content.componentInstance.reentryBehavior !== void 0 ? this.content.componentInstance.reentryBehavior : "default"
    /* default */
    ;
  }

  isCacheEqual(other) {
    return this.content.sameComponent(other.content, true);
  }

  contentController(connectedCE) {
    return _runtimeHtml.Controller.forCustomElement(null, connectedCE.container, this.content.componentInstance, connectedCE.element, null, void 0);
  }

  createComponent(connectedCE, fallback) {
    // if (this.contentStatus !== ContentStatus.none) {
    if (this.contentStates.has('created')) {
      return;
    } // Don't load cached content or instantiated history content


    if (!this.fromCache && !this.fromHistory) {
      try {
        this.content.componentInstance = this.toComponentInstance(connectedCE.container);
      } catch (e) {
        if (fallback !== void 0) {
          this.content.setParameters({
            id: this.content.componentName
          });
          this.content.setComponent(fallback);

          try {
            this.content.componentInstance = this.toComponentInstance(connectedCE.container);
          } catch (ee) {
            throw e;
          }
        } else {
          throw e;
        }
      }
    }

    this.contentStates.set('created', void 0); // this.contentStatus = ContentStatus.created;
    // if (this.contentStatus !== ContentStatus.created || !this.loaded || !this.content.componentInstance) {
    // if (this.contentStatus !== ContentStatus.created || this.loaded || !this.content.componentInstance) {

    if (this.contentStates.has('loaded') || !this.content.componentInstance) {
      return;
    } // this.contentStatus = ContentStatus.loaded;
    // Don't load cached content or instantiated history content


    if (!this.fromCache || !this.fromHistory) {
      const controller = this.contentController(connectedCE);
      controller.parent = connectedCE.controller; // CustomElement.for(connectedCE.element)!;
    }
  } // public destroyComponent(): void {
  //   // TODO: We might want to do something here eventually, who knows?
  //   // if (this.contentStatus !== ContentStatus.created) {
  //   if (!this.contentStates.has('created')) {
  //     return;
  //   }
  //   // Don't destroy components when stateful
  //   // this.contentStatus = ContentStatus.none;
  //   this.contentStates.delete('created');
  // }


  canLoad(viewport, previousInstruction) {
    if (!this.contentStates.has('created') || this.contentStates.has('guarded') && !this.reentry) {
      return true;
    }

    this.contentStates.set('guarded', void 0);

    if (!this.content.componentInstance) {
      return false;
    }

    if (!this.content.componentInstance.canLoad) {
      return true;
    }

    const typeParameters = this.content.componentType ? this.content.componentType.parameters : null;
    this.instruction.parameters = this.content.toSpecifiedParameters(typeParameters);
    const merged = { ...(0, _parser.parseQuery)(this.instruction.query),
      ...this.instruction.parameters
    };
    const result = this.content.componentInstance.canLoad(merged, this.instruction, previousInstruction);

    if (typeof result === 'boolean') {
      return result;
    }

    if (typeof result === 'string') {
      return [viewport.router.createViewportInstruction(result, viewport)];
    }

    return result;
  }

  canUnload(nextInstruction) {
    if (!this.content.componentInstance || !this.content.componentInstance.canUnload) {
      return true;
    }

    if (!this.contentStates.has('loaded')) {
      return true;
    }

    return this.content.componentInstance.canUnload(nextInstruction, this.instruction);
  } // public async canUnload(nextInstruction: Navigation | null): Promise<boolean> {
  //   if (!this.content.componentInstance || !this.content.componentInstance.canUnload) {
  //     return true;
  //   }
  //   const result = this.content.componentInstance.canUnload(nextInstruction, this.instruction);
  //   if (typeof result === 'boolean') {
  //     return result;
  //   }
  //   return result;
  // }


  load(previousInstruction) {
    // if (!this.reentry && (this.contentStatus !== ContentStatus.created || this.loaded)) {
    // if (!this.reentry && this.loaded) {
    // if (!this.contentStates.has('created') || (this.contentStates.has('loaded') && !this.reentry)) {
    //   return;
    // }
    // this.reentry = false;
    return _runner.Runner.run(() => this.contentStates.await('guarded'), () => {
      if (!this.contentStates.has('created') || this.contentStates.has('loaded') && !this.reentry) {
        return;
      }

      this.reentry = false; // this.loaded = true;
      // console.log('loaded', this.content.componentName);

      this.contentStates.set('loaded', void 0);

      if (this.content.componentInstance && this.content.componentInstance.load) {
        const typeParameters = this.content.componentType ? this.content.componentType.parameters : null;
        this.instruction.parameters = this.content.toSpecifiedParameters(typeParameters);
        const merged = { ...(0, _parser.parseQuery)(this.instruction.query),
          ...this.instruction.parameters
        };
        return this.content.componentInstance.load(merged, this.instruction, previousInstruction);
      }
    });
  }

  unload(nextInstruction) {
    // if (!this.loaded) {
    if (!this.contentStates.has('loaded')) {
      return;
    } // this.loaded = false;
    // console.log('loaded', this.content.componentName, 'deleted');


    this.contentStates.delete('loaded');

    if (this.content.componentInstance && this.content.componentInstance.unload) {
      return this.content.componentInstance.unload(nextInstruction, this.instruction);
    }
  } // public unloadComponent(cache: ViewportContent[], stateful: boolean = false): void {
  //   // TODO: We might want to do something here eventually, who knows?
  //   // if (this.contentStatus !== ContentStatus.activated) {
  //   if (!this.contentStates.has('created')) {
  //     return;
  //   }
  //   // Don't unload components when stateful
  //   // TODO: We're missing stuff here
  //   if (!stateful) {
  //     // this.contentStatus = ContentStatus.created;
  //     this.contentStates.delete('created');
  //   } else {
  //     cache.push(this);
  //   }
  // }


  activateComponent(initiator, parent, flags, connectedCE, parentActivated) {
    // if (this.contentStates.has('activated') || !this.contentStates.has('created')) {
    // if (this.contentStates.has('activated')) {
    //   return;
    // }
    // this.contentStates.set('activated', void 0);
    // // if (parentActivated) { // Parent is already part of an activation
    // //   return ;
    // // }
    // const contentController = this.contentController(connectedCE);
    return _runner.Runner.run(() => this.contentStates.await('loaded'), () => {
      if (this.contentStates.has('activated')) {
        return;
      }

      this.contentStates.set('activated', void 0); // if (parentActivated) { // Parent is already part of an activation
      //   return ;
      // }

      const contentController = this.contentController(connectedCE);
      return contentController.activate(initiator ?? contentController, null
      /* TODO: take back: parent! */
      , flags);
    }, () => {
      if (this.fromCache || this.fromHistory) {
        const elements = Array.from(connectedCE.element.getElementsByTagName('*'));

        for (const el of elements) {
          const attr = el.getAttribute('au-element-scroll');

          if (attr) {
            const [top, left] = attr.split(',');
            el.removeAttribute('au-element-scroll');
            el.scrollTo(+left, +top);
          }
        }
      }
    });
  } // public async activateComponent(initiator: IHydratedController | null, parent: ICustomElementController<ICustomElementViewModel> | null, flags: LifecycleFlags, connectedCE: IConnectedCustomElement): Promise<void> {
  //   // if (this.contentStatus !== ContentStatus.created) {
  //   if (!this.contentStates.has('created')) {
  //     return;
  //   }
  //   // this.contentStatus = ContentStatus.activated;
  //   this.contentStates.add('activated');
  //   const contentController = this.contentController(connectedCE);
  //   await contentController.activate(initiator ?? contentController, parent!, flags);
  //   if (this.fromCache || this.fromHistory) {
  //     const elements = Array.from(connectedCE.element.getElementsByTagName('*'));
  //     for (const el of elements) {
  //       const attr = el.getAttribute('au-element-scroll');
  //       if (attr) {
  //         const [top, left] = attr.split(',');
  //         el.removeAttribute('au-element-scroll');
  //         el.scrollTo(+left, +top);
  //       }
  //     }
  //   }
  // }


  deactivateComponent(initiator, parent, flags, connectedCE, stateful = false) {
    // if (this.contentStatus !== ContentStatus.activated) {
    if (!this.contentStates.has('activated')) {
      return;
    } // this.contentStatus = ContentStatus.created;


    this.contentStates.delete('activated');

    if (stateful && connectedCE.element !== null) {
      // const contentController = this.content.componentInstance!.$controller!;
      const elements = Array.from(connectedCE.element.getElementsByTagName('*'));

      for (const el of elements) {
        if (el.scrollTop > 0 || el.scrollLeft) {
          el.setAttribute('au-element-scroll', `${el.scrollTop},${el.scrollLeft}`);
        }
      }
    }

    const contentController = this.contentController(connectedCE);
    return _runner.Runner.run(() => contentController.deactivate(initiator ?? contentController, parent, flags));
  }

  disposeComponent(connectedCE, cache, stateful = false) {
    if (!this.contentStates.has('created')) {
      return;
    } // Don't unload components when stateful
    // TODO: We're missing stuff here


    if (!stateful) {
      this.contentStates.delete('created');
      const contentController = this.contentController(connectedCE);
      return contentController.dispose();
    } else {
      cache.push(this);
    }
  }

  freeContent(connectedCE, nextInstruction, cache, stateful = false) {
    // switch (this.contentStatus) {
    //   case ContentStatus.activated:
    //     await this.unload(nextInstruction);
    //     await this.deactivateComponent(null, connectedCE!.controller, LifecycleFlags.none, connectedCE!, stateful);
    //     this.unloadComponent(cache, stateful); // TODO: Hook up to new dispose
    //   case ContentStatus.created:
    //     this.destroyComponent();
    // }
    // TODO: Fix execution order on these
    // These are all safe to run
    return _runner.Runner.run(() => this.unload(nextInstruction), () => this.deactivateComponent(null, connectedCE.controller, 0
    /* none */
    , connectedCE, stateful), // () => this.unloadComponent(cache, stateful), // TODO: Hook up to new dispose
    // () => this.destroyComponent(),
    () => this.disposeComponent(connectedCE, cache, stateful));
  }

  toComponentName() {
    return this.content.componentName;
  }

  toComponentType(container) {
    if (this.content.isEmpty()) {
      return null;
    }

    return this.content.toComponentType(container);
  }

  toComponentInstance(container) {
    if (this.content.isEmpty()) {
      return null;
    }

    return this.content.toComponentInstance(container);
  }

}

exports.ViewportContent = ViewportContent;
});

;define.alias('@aurelia/router/viewport-content.js','@aurelia/router/dist/esm/viewport-content.js');
define('@aurelia/router/dist/esm/viewport-instruction.js',['require','exports','module','@aurelia/runtime-html','./type-resolvers.js','./router-options.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.ViewportInstruction = exports.ParametersType = void 0;

var _runtimeHtml = require("@aurelia/runtime-html");

var _typeResolvers = require("./type-resolvers.js");

var _routerOptions = require("./router-options.js");

/**
 * @internal - Shouldn't be used directly
 */
var ParametersType;
exports.ParametersType = ParametersType;

(function (ParametersType) {
  ParametersType["none"] = "none";
  ParametersType["string"] = "string";
  ParametersType["array"] = "array";
  ParametersType["object"] = "object";
})(ParametersType || (exports.ParametersType = ParametersType = {}));
/**
 * Public API - The viewport instructions are the core of the router's navigations
 */


class ViewportInstruction {
  constructor() {
    this.componentName = null;
    this.componentType = null;
    this.componentInstance = null;
    this.viewportName = null;
    this.viewport = null;
    this.parametersString = null;
    this.parametersRecord = null;
    this.parametersList = null;
    this.parametersType = "none"
    /* none */
    ;
    this.ownsScope = true;
    this.nextScopeInstructions = null;
    this.scope = null;
    this.context = '';
    this.viewportScope = null;
    this.needsViewportDescribed = false;
    this.route = null;
    this.default = false;
    this.topInstruction = false;
    this.instructionResolver = null;
  } // public constructor(
  //   component: ComponentAppellation,
  //   viewport?: ViewportHandle,
  //   parameters?: ComponentParameters,
  //   public ownsScope: boolean = true,
  //   public nextScopeInstructions: ViewportInstruction[] | null = null,
  // ) {
  //   this.setComponent(component);
  //   this.setViewport(viewport);
  //   this.setParameters(parameters);
  // }


  static create(instructionResolver, component, viewport, parameters, ownsScope = true, nextScopeInstructions = null) {
    // if (component instanceof Promise) {
    //   return component.then((resolvedComponent) => {
    //     return ViewportInstruction.create(instructionResolver, resolvedComponent, viewport, parameters, ownsScope, nextScopeInstructions);
    //   });
    // }
    const instruction = new ViewportInstruction();
    instruction.setComponent(component);
    instruction.setViewport(viewport);
    instruction.setParameters(parameters);
    instruction.ownsScope = ownsScope;
    instruction.nextScopeInstructions = nextScopeInstructions;
    instruction.setInstructionResolver(instructionResolver);
    return instruction;
  }

  get owner() {
    return this.viewport ?? this.viewportScope ?? null;
  }

  get typedParameters() {
    switch (this.parametersType) {
      case "string"
      /* string */
      :
        return this.parametersString;

      case "array"
      /* array */
      :
        return this.parametersList;

      case "object"
      /* object */
      :
        return this.parametersRecord;

      default:
        return null;
    }
  }

  get parameters() {
    if (this.instructionResolver !== null) {
      return this.instructionResolver.parseComponentParameters(this.typedParameters);
    }

    return [];
  }

  get normalizedParameters() {
    if (this.instructionResolver !== null && this.typedParameters !== null) {
      return this.instructionResolver.stringifyComponentParameters(this.parameters);
    }

    return '';
  }

  setComponent(component) {
    if (_typeResolvers.ComponentAppellationResolver.isName(component)) {
      this.componentName = _typeResolvers.ComponentAppellationResolver.getName(component);
      this.componentType = null;
      this.componentInstance = null;
    } else if (_typeResolvers.ComponentAppellationResolver.isType(component)) {
      this.componentName = this.getNewName(component);
      this.componentType = _typeResolvers.ComponentAppellationResolver.getType(component);
      this.componentInstance = null;
    } else if (_typeResolvers.ComponentAppellationResolver.isInstance(component)) {
      this.componentName = this.getNewName(_typeResolvers.ComponentAppellationResolver.getType(component));
      this.componentType = _typeResolvers.ComponentAppellationResolver.getType(component);
      this.componentInstance = _typeResolvers.ComponentAppellationResolver.getInstance(component);
    }
  }

  setViewport(viewport) {
    if (viewport === undefined || viewport === '') {
      viewport = null;
    }

    if (typeof viewport === 'string') {
      this.viewportName = viewport;
      this.viewport = null;
    } else {
      this.viewport = viewport;

      if (viewport !== null) {
        this.viewportName = viewport.name;
        this.scope = viewport.owningScope;
      }
    }
  }

  setParameters(parameters) {
    if (parameters === undefined || parameters === null || parameters === '') {
      this.parametersType = "none"
      /* none */
      ;
      parameters = null;
    } else if (typeof parameters === 'string') {
      this.parametersType = "string"
      /* string */
      ;
      this.parametersString = parameters;
    } else if (Array.isArray(parameters)) {
      this.parametersType = "array"
      /* array */
      ;
      this.parametersList = parameters;
    } else {
      this.parametersType = "object"
      /* object */
      ;
      this.parametersRecord = parameters;
    }
  } // This only works with objects added to objects!


  addParameters(parameters) {
    if (this.parametersType === "none"
    /* none */
    ) {
        return this.setParameters(parameters);
      }

    if (this.parametersType !== "object"
    /* object */
    ) {
        throw new Error('Can\'t add object parameters to existing non-object parameters!');
      }

    this.setParameters({ ...this.parametersRecord,
      ...parameters
    });
  }

  setInstructionResolver(instructionResolver) {
    this.instructionResolver = instructionResolver;
  }

  isEmpty() {
    return !this.isComponentName() && !this.isComponentType() && !this.isComponentInstance();
  }

  isComponentName() {
    return !!this.componentName && !this.isComponentType() && !this.isComponentInstance();
  }

  isComponentType() {
    return this.componentType !== null && !this.isComponentInstance();
  }

  isComponentInstance() {
    return this.componentInstance !== null;
  }

  toComponentType(container) {
    if (this.componentType !== null) {
      return this.componentType;
    }

    if (this.componentName !== null && typeof this.componentName === 'string' && container !== null && container.has(_runtimeHtml.CustomElement.keyFrom(this.componentName), true)) {
      const resolver = container.getResolver(_runtimeHtml.CustomElement.keyFrom(this.componentName));

      if (resolver !== null && resolver.getFactory !== void 0) {
        const factory = resolver.getFactory(container);

        if (factory) {
          return factory.Type;
        }
      }
    }

    return null;
  }

  toComponentInstance(container) {
    if (this.componentInstance !== null) {
      return this.componentInstance;
    }

    if (container !== void 0 && container !== null) {
      const instance = this.isComponentType() ? container.get(this.componentType) : container.get(_runtimeHtml.CustomElement.keyFrom(this.componentName));

      if (this.isComponentType() && !(instance instanceof this.componentType)) {
        console.warn('Failed to instantiate', this.componentType, instance);
      }

      return instance ?? null;
    }

    return null;
  }

  toViewportInstance(router) {
    if (this.viewport !== null) {
      return this.viewport;
    }

    return router.getViewport(this.viewportName);
  }

  toSpecifiedParameters(specifications) {
    specifications = specifications || [];
    const parameters = this.parameters;
    const specified = {};

    for (const spec of specifications) {
      // First get named if it exists
      let index = parameters.findIndex(param => param.key === spec);

      if (index >= 0) {
        const [parameter] = parameters.splice(index, 1);
        specified[spec] = parameter.value;
      } else {
        // Otherwise get first unnamed
        index = parameters.findIndex(param => param.key === void 0);

        if (index >= 0) {
          const [parameter] = parameters.splice(index, 1);
          specified[spec] = parameter.value;
        }
      }
    } // Add all remaining named


    for (const parameter of parameters.filter(param => param.key !== void 0)) {
      specified[parameter.key] = parameter.value;
    }

    let index = specifications.length; // Add all remaining unnamed...

    for (const parameter of parameters.filter(param => param.key === void 0)) {
      // ..with an index
      specified[index++] = parameter.value;
    }

    return specified;
  }

  toSortedParameters(specifications) {
    specifications = specifications || [];
    const parameters = this.parameters;
    const sorted = [];

    for (const spec of specifications) {
      // First get named if it exists
      let index = parameters.findIndex(param => param.key === spec);

      if (index >= 0) {
        const parameter = { ...parameters.splice(index, 1)[0]
        };
        parameter.key = void 0;
        sorted.push(parameter);
      } else {
        // Otherwise get first unnamed
        index = parameters.findIndex(param => param.key === void 0);

        if (index >= 0) {
          const parameter = { ...parameters.splice(index, 1)[0]
          };
          sorted.push(parameter);
        } else {
          // Or an empty
          sorted.push({
            value: void 0
          });
        }
      }
    } // Add all remaining named


    const params = parameters.filter(param => param.key !== void 0);
    params.sort((a, b) => (a.key || '') < (b.key || '') ? 1 : (b.key || '') < (a.key || '') ? -1 : 0);
    sorted.push(...params); // Add all remaining unnamed...

    sorted.push(...parameters.filter(param => param.key === void 0));
    return sorted;
  }

  sameComponent(other, compareParameters = false, compareType = false) {
    if (compareParameters && !this.sameParameters(other, compareType)) {
      return false;
    }

    return compareType ? this.componentType === other.componentType : this.componentName === other.componentName;
  } // TODO: Somewhere we need to check for format such as spaces etc


  sameParameters(other, compareType = false) {
    if (!this.sameComponent(other, false, compareType)) {
      return false;
    }

    const typeParameters = this.componentType ? this.componentType.parameters : [];
    const mine = this.toSpecifiedParameters(typeParameters);
    const others = other.toSpecifiedParameters(typeParameters);
    return Object.keys(mine).every(key => mine[key] === others[key]) && Object.keys(others).every(key => others[key] === mine[key]);
  }

  sameViewport(other) {
    if (this.viewport !== null && other.viewport !== null) {
      return this.viewport === other.viewport;
    }

    return this.scope === other.scope && (this.viewport ? this.viewport.name : this.viewportName) === (other.viewport ? other.viewport.name : other.viewportName);
  }

  getNewName(type) {
    if (this.componentName === null // || !type.aliases?.includes(this.componentName)
    ) {
        return _typeResolvers.ComponentAppellationResolver.getName(type);
      }

    return this.componentName;
  }

}

exports.ViewportInstruction = ViewportInstruction;
ViewportInstruction.inject = [_routerOptions.RouterOptions];
});

;define.alias('@aurelia/router/viewport-instruction.js','@aurelia/router/dist/esm/viewport-instruction.js');
define('@aurelia/router/dist/esm/viewport-scope.js',['require','exports','module','./scope.js','./utils.js','./runner.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.ViewportScope = void 0;

var _scope = require("./scope.js");

var _utils = require("./utils.js");

var _runner = require("./runner.js");

class ViewportScope {
  constructor(name, router, connectedCE, owningScope, scope, rootComponentType = null, // temporary. Metadata will probably eliminate it
  options = {
    catches: [],
    source: null
  }) {
    this.name = name;
    this.router = router;
    this.connectedCE = connectedCE;
    this.rootComponentType = rootComponentType;
    this.options = options;
    this.path = null;
    this.content = null;
    this.nextContent = null;
    this.available = true;
    this.sourceItem = null;
    this.sourceItemIndex = -1;
    this.remove = false;
    this.add = false;
    this.connectedScope = new _scope.Scope(router, scope, owningScope, null, this);

    if (this.catches.length > 0) {
      this.content = router.createViewportInstruction(this.catches[0], this.name);
    }
  }

  get scope() {
    return this.connectedScope.scope;
  }

  get owningScope() {
    return this.connectedScope.owningScope;
  }

  get enabled() {
    return this.connectedScope.enabled;
  }

  set enabled(enabled) {
    this.connectedScope.enabled = enabled;
  }

  get isViewport() {
    return false;
  }

  get isViewportScope() {
    return true;
  }

  get isEmpty() {
    return this.content === null;
  }

  get passThroughScope() {
    return this.rootComponentType === null && this.catches.length === 0;
  }

  get siblings() {
    const parent = this.connectedScope.parent;

    if (parent === null) {
      return [this];
    }

    return parent.enabledChildren.filter(child => child.isViewportScope && child.viewportScope.name === this.name).map(child => child.viewportScope);
  }

  get source() {
    return this.options.source || null;
  }

  get catches() {
    let catches = this.options.catches || [];

    if (typeof catches === 'string') {
      catches = catches.split(',');
    }

    return catches;
  }

  get default() {
    if (this.catches.length > 0) {
      return this.catches[0];
    }
  }

  get nextContentActivated() {
    return this.scope.parent?.owner?.nextContentActivated ?? false;
  }

  get parentNextContentActivated() {
    return this.scope.parent?.owner?.nextContentActivated ?? false;
  }

  get nextContentAction() {
    return '';
  }

  toString() {
    const contentName = this.content?.componentName ?? '';
    const nextContentName = this.nextContent?.componentName ?? '';
    return `vs:${this.name}[${contentName}->${nextContentName}]`;
  }

  setNextContent(viewportInstruction, navigation) {
    viewportInstruction.viewportScope = this;
    this.remove = this.router.instructionResolver.isClearViewportInstruction(viewportInstruction) || this.router.instructionResolver.isClearAllViewportsInstruction(viewportInstruction);
    this.add = this.router.instructionResolver.isAddViewportInstruction(viewportInstruction) && Array.isArray(this.source);

    if (this.add) {
      viewportInstruction.componentName = null;
    }

    if (this.default !== void 0 && viewportInstruction.componentName === null) {
      viewportInstruction.componentName = this.default;
    }

    this.nextContent = viewportInstruction;
    return 'swap';
  }

  transition(coordinator) {
    // console.log('ViewportScope swap'/*, this, coordinator*/);
    _runner.Runner.run(() => coordinator.addEntityState(this, 'guardedUnload'), () => coordinator.addEntityState(this, 'guardedLoad'), () => coordinator.addEntityState(this, 'guarded'), () => coordinator.addEntityState(this, 'loaded'), () => coordinator.addEntityState(this, 'unloaded'), () => coordinator.addEntityState(this, 'routed'), () => coordinator.addEntityState(this, 'swapped'), () => {
      this.content = !this.remove ? this.nextContent : null;
      this.nextContent = null;
      coordinator.addEntityState(this, 'completed');
    });
  }

  canUnload() {
    return true;
  }

  canLoad() {
    return true;
  }

  unload() {
    return;
  }

  load() {
    return;
  } // public loadContent(): Promise<boolean> {
  //   this.content = !this.remove ? this.nextContent : null;
  //   this.nextContent = null;
  //   return Promise.resolve(true);
  // }


  finalizeContentChange() {
    // console.log('ViewportScope finalizing', this.content);
    if (this.remove && Array.isArray(this.source)) {
      this.removeSourceItem();
    }
  }

  abortContentChange() {
    this.nextContent = null;

    if (this.add) {
      const index = this.source.indexOf(this.sourceItem);
      this.source.splice(index, 1);
      this.sourceItem = null;
    }

    return Promise.resolve();
  }

  acceptSegment(segment) {
    if (segment === null && segment === void 0 || segment.length === 0) {
      return true;
    }

    if (segment === this.router.instructionResolver.clearViewportInstruction || segment === this.router.instructionResolver.addViewportInstruction || segment === this.name) {
      return true;
    }

    if (this.catches.length === 0) {
      return true;
    }

    if (this.catches.includes(segment)) {
      return true;
    }

    if (this.catches.filter(value => value.includes('*')).length) {
      return true;
    }

    return false;
  }

  binding() {
    const source = this.source || [];

    if (source.length > 0 && this.sourceItem === null) {
      this.sourceItem = this.getAvailableSourceItem();
    }
  }

  unbinding() {
    if (this.sourceItem !== null && this.source !== null) {
      (0, _utils.arrayRemove)(this.source, item => item === this.sourceItem);
    }

    this.sourceItem = null;
  }

  getAvailableSourceItem() {
    if (this.source === null) {
      return null;
    }

    const siblings = this.siblings;

    for (const item of this.source) {
      if (siblings.every(sibling => sibling.sourceItem !== item)) {
        return item;
      }
    }

    return null;
  }

  addSourceItem() {
    const item = {};
    this.source.push(item);
    return item;
  }

  removeSourceItem() {
    this.sourceItemIndex = this.source.indexOf(this.sourceItem);

    if (this.sourceItemIndex >= 0) {
      this.source.splice(this.sourceItemIndex, 1);
    }
  }

  getRoutes() {
    if (this.rootComponentType !== null) {
      return this.rootComponentType.routes;
    }

    return null;
  }

}

exports.ViewportScope = ViewportScope;
});

;define.alias('@aurelia/router/viewport-scope.js','@aurelia/router/dist/esm/viewport-scope.js');
define('@aurelia/router/dist/esm/viewport.js',['require','exports','module','@aurelia/runtime-html','./utils.js','./viewport-content.js','./scope.js','./runner.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.Viewport = void 0;

var _runtimeHtml = require("@aurelia/runtime-html");

var _utils = require("./utils.js");

var _viewportContent = require("./viewport-content.js");

var _scope = require("./scope.js");

var _runner = require("./runner.js");

class Viewport {
  constructor(router, name, connectedCE, owningScope, scope, options = {}) {
    this.router = router;
    this.name = name;
    this.connectedCE = connectedCE;
    this.options = options;
    this.nextContent = null;
    this.nextContentAction = '';
    this.forceRemove = false;
    this.path = null;
    this.clear = false;
    this.connectionResolve = null;
    this.previousViewportState = null;
    this.cache = [];
    this.historyCache = [];
    this.content = new _viewportContent.ViewportContent();
    this.connectedScope = new _scope.Scope(router, scope, owningScope, this);
  }

  get scope() {
    return this.connectedScope.scope;
  }

  get owningScope() {
    return this.connectedScope.owningScope;
  }

  get connectedController() {
    return this.connectedCE?.$controller ?? null;
  }

  get enabled() {
    return this.connectedScope.enabled;
  }

  set enabled(enabled) {
    this.connectedScope.enabled = enabled;
  }

  get isViewport() {
    return true;
  }

  get isViewportScope() {
    return false;
  }

  get isEmpty() {
    return this.content.componentInstance === null;
  }

  get doForceRemove() {
    let scope = this.connectedScope;

    while (scope !== null) {
      if (scope.viewport !== null && scope.viewport.forceRemove) {
        return true;
      }

      scope = scope.parent;
    }

    return false;
  }

  get activeContent() {
    return this.nextContent ?? this.content;
  }

  get nextContentActivated() {
    return this.nextContent?.contentStates.has('activated') ?? false;
  }

  get parentNextContentActivated() {
    return this.scope.parent?.owner?.nextContentActivated ?? false;
  }

  get performLoad() {
    return true; // return this.nextContentAction !== 'skip' && this.connectedScope.parentNextContentAction !== 'swap';
    // // return this.nextContentAction !== 'skip' && ((this.nextContent?.content.topInstruction ?? false) || this.clear);
  }

  get performSwap() {
    return true; // return this.nextContentAction !== 'skip' && this.connectedScope.parentNextContentAction !== 'swap';
    // // return this.nextContentAction !== 'skip' && ((this.nextContent?.content.topInstruction ?? false) || this.clear);
  }

  toString() {
    const contentName = this.content?.content.componentName ?? '';
    const nextContentName = this.nextContent?.content.componentName ?? '';
    return `v:${this.name}[${contentName}->${nextContentName}]`;
  }

  setNextContent(viewportInstruction, navigation) {
    viewportInstruction.setViewport(this);
    this.clear = this.router.instructionResolver.isClearViewportInstruction(viewportInstruction); // Can have a (resolved) type or a string (to be resolved later)

    this.nextContent = new _viewportContent.ViewportContent(!this.clear ? viewportInstruction : void 0, navigation, this.connectedCE ?? null);
    this.nextContent.fromHistory = this.nextContent.componentInstance && navigation.navigation ? !!navigation.navigation.back || !!navigation.navigation.forward : false;

    if (this.options.stateful) {
      // TODO: Add a parameter here to decide required equality
      const cached = this.cache.find(item => this.nextContent.isCacheEqual(item));

      if (cached) {
        this.nextContent = cached;
        this.nextContent.fromCache = true;
      } else {
        this.cache.push(this.nextContent);
      }
    } // Children that will be replaced (unless added again) by next content. Will
    // be re-enabled on cancel


    this.connectedScope.clearReplacedChildren(); // If we get the same _instance_, don't do anything (happens with cached and history)

    if (this.nextContent.componentInstance !== null && this.content.componentInstance === this.nextContent.componentInstance) {
      this.nextContent = null;
      return this.nextContentAction = 'skip'; // false;
    }

    if (!this.content.equalComponent(this.nextContent) || this.connectedScope.parentNextContentAction === 'swap' || // Some parent has been swapped, need to be new component
    navigation.navigation.refresh || // Navigation 'refresh' performed
    this.content.reentryBehavior() === "refresh"
    /* refresh */
    // ReentryBehavior 'refresh' takes precedence
    ) {
        this.connectedScope.disableReplacedChildren();
        return this.nextContentAction = 'swap'; // true;
      } // Component is the same name/type
    // Explicitly don't allow navigation back to the same component again


    if (this.content.reentryBehavior() === "disallow"
    /* disallow */
    ) {
        this.nextContent = null;
        return this.nextContentAction = 'skip'; // false;
      } // Explicitly re-load same component again


    if (this.content.reentryBehavior() === "load"
    /* load */
    ) {
        this.content.reentry = true;
        this.nextContent.content.setComponent(this.content.componentInstance); // this.nextContent.contentStatus = this.content.contentStatus;

        this.nextContent.contentStates = this.content.contentStates.clone(); // this.nextContent.contentStates = new Map(this.content.contentStates);

        this.nextContent.reentry = this.content.reentry;
        return this.nextContentAction = 'reload'; // true;
      } // ReentryBehavior is now 'default'
    // Requires updated parameters if viewport stateful


    if (this.options.stateful && this.content.equalParameters(this.nextContent)) {
      this.nextContent = null;
      return this.nextContentAction = 'skip'; // false;
    }

    if (!this.content.equalParameters(this.nextContent)) {
      // TODO: Fix a config option for this
      // eslint-disable-next-line no-constant-condition
      if (false) {
        // Re-use component, only reload with new parameters
        this.content.reentry = true;
        this.nextContent.content.setComponent(this.content.componentInstance);
        this.nextContent.contentStates = this.content.contentStates.clone();
        this.nextContent.reentry = this.content.reentry;
        return this.nextContentAction = 'reload';
      } else {
        // Perform a full swap
        this.connectedScope.disableReplacedChildren();
        return this.nextContentAction = 'swap';
      }
    } // Default is to do nothing


    return 'skip'; // // Default is to trigger a refresh (without a check of parameters)
    // this.connectedScope.disableReplacedChildren();
    // return this.nextContentAction = 'reload'; // true;
  }

  setConnectedCE(connectedCE, options) {
    options = options || {};

    if (this.connectedCE !== connectedCE) {
      // TODO: Restore this state on navigation cancel
      this.previousViewportState = { ...this
      };
      this.clearState();
      this.connectedCE = connectedCE;

      if (options.usedBy) {
        this.options.usedBy = options.usedBy;
      }

      if (options.default) {
        this.options.default = options.default;
      }

      if (options.fallback) {
        this.options.fallback = options.fallback;
      }

      if (options.noLink) {
        this.options.noLink = options.noLink;
      }

      if (options.noTitle) {
        this.options.noTitle = options.noTitle;
      }

      if (options.noHistory) {
        this.options.noHistory = options.noHistory;
      }

      if (options.stateful) {
        this.options.stateful = options.stateful;
      }

      if (this.connectionResolve) {
        this.connectionResolve();
      }
    } // TODO: Might not need this? Figure it out
    // if (container) {
    //   container['viewportName'] = this.name;
    // }


    if (!this.content.componentInstance && (!this.nextContent || !this.nextContent.componentInstance) && this.options.default) {
      const instructions = this.router.instructionResolver.parseViewportInstructions(this.options.default);

      for (const instruction of instructions) {
        // Set to name to be delayed one turn
        instruction.setViewport(this.name);
        instruction.scope = this.owningScope;
        instruction.default = true;
      }

      this.router.load(instructions, {
        append: true
      }).catch(error => {
        throw error;
      });
    }
  }

  remove(connectedCE) {
    if (this.connectedCE === connectedCE) {
      return _runner.Runner.run(() => {
        if (this.content.componentInstance) {
          return this.content.freeContent(this.connectedCE, this.nextContent ? this.nextContent.instruction : null, this.historyCache, this.doForceRemove ? false : this.router.statefulHistory || this.options.stateful); // .catch(error => { throw error; });
        }
      }, () => {
        if (this.doForceRemove) {
          const removes = [];

          for (const content of this.historyCache) {
            removes.push(() => content.freeContent(null, null, this.historyCache, false));
          }

          removes.push(() => {
            this.historyCache = [];
          });
          return _runner.Runner.run(...removes); // return Promise.all(this.historyCache.map(content => content.freeContent(
          //   null,
          //   null,
          //   this.historyCache,
          //   false,
          // )));
          // this.historyCache = [];
        }

        return true;
      });
    }

    return false;
  }

  transition(coordinator) {
    // console.log('Viewport transition', this.toString());
    // let run: unknown;
    const guarded = coordinator.checkingSyncState('guarded');
    const performLoad = this.performLoad || !guarded;
    const performSwap = this.performSwap || !guarded; // const performSwap = this.performSwap || !this.router.isRestrictedNavigation || this.clear;

    const guardSteps = [() => performLoad ? this.canUnload() : true, canUnloadResult => {
      if (!canUnloadResult) {
        _runner.Runner.cancel(void 0);

        coordinator.cancel();
        return;
      }

      if (this.router.isRestrictedNavigation) {
        this.nextContent.createComponent(this.connectedCE, this.options.fallback);
      }

      coordinator.addEntityState(this, 'guardedUnload');
    }, () => coordinator.syncState('guardedUnload', this), () => performLoad ? this.canLoad(guarded) : true, canLoadResult => {
      if (typeof canLoadResult === 'boolean') {
        if (!canLoadResult) {
          _runner.Runner.cancel(void 0);

          coordinator.cancel();
          return;
        }

        coordinator.addEntityState(this, 'guardedLoad');
        coordinator.addEntityState(this, 'guarded');
      } else {
        // Denied and (probably) redirected
        _runner.Runner.run(() => this.router.load(canLoadResult, {
          append: true
        }), () => this.abortContentChange());
      }
    }];
    const routingSteps = [// () => { console.log("I'm waiting for guarded", this.toString()); },
    () => coordinator.syncState('guarded', this), // () => { console.log("I'm guarded", this.toString()); },
    // TODO: For consistency it should probably be this option with 'routed'
    // () => performSwap ? this.unload(coordinator.checkingSyncState('routed')) : true,
    () => performLoad ? this.unload(true) : true, () => coordinator.addEntityState(this, 'unloaded'), // () => { console.log("I'm waiting for unloaded", this.toString()); },
    () => coordinator.syncState('unloaded', this), // () => { console.log("I'm done waiting for unloaded", this.toString()); },
    () => performLoad ? this.load(coordinator.checkingSyncState('routed')) : true, () => coordinator.addEntityState(this, 'loaded'), () => coordinator.addEntityState(this, 'routed')];
    const lifecycleSteps = [() => coordinator.syncState('routed', this)];

    if (performSwap) {
      if (this.router.options.swapStrategy.includes('parallel')) {
        lifecycleSteps.push(() => {
          if (this.router.options.swapStrategy.includes('add')) {
            return _runner.Runner.run(this.addContent(), this.removeContent());
          } else {
            return _runner.Runner.run(this.removeContent(), this.addContent());
          }
        });
      } else {
        lifecycleSteps.push(() => performSwap ? this.router.options.swapStrategy.includes('add') ? this.addContent() : this.removeContent() : void 0, () => performSwap ? this.router.options.swapStrategy.includes('add') ? this.removeContent() : this.addContent() : void 0);
      }
    }

    lifecycleSteps.push(() => coordinator.addEntityState(this, 'swapped')); // const lifecycleSteps = [
    //   () => coordinator.syncState('routed'),
    //   // () => coordinator.addEntityState(this, 'bound'),
    //   () => performSwap ? (this.router.options.swapStrategy.includes('add') ? this.addContent() : this.removeContent()) : true,
    //   () => performSwap ? (this.router.options.swapStrategy.includes('add') ? this.removeContent() : this.addContent()) : true,
    //   () => coordinator.addEntityState(this, 'swapped'),
    // ];
    // run =

    _runner.Runner.run(...guardSteps, ...routingSteps, ...lifecycleSteps, () => coordinator.addEntityState(this, 'completed'));
  }

  canUnload() {
    return _runner.Runner.run(() => {
      // console.log('viewport canUnload run', this.name, 'before');
      const result = this.connectedScope.canUnload(); // console.log('viewport canUnload run', this.name, 'after');

      return result;
    }, canUnloadChildren => {
      // console.log('viewport canUnload result', this.name, canUnloadChildren);
      if (!canUnloadChildren) {
        return false;
      } // This shouldn't happen
      // // Don't stop it because we're not going to actually do anything
      // if (this.content.componentInstance === this.nextContent?.componentInstance) {
      //   return true;
      // }


      return this.content.canUnload(this.nextContent?.instruction ?? null);
    });
  }

  canLoad(recurse) {
    // console.log(this.connectedScope.toString(), 'viewport content canLoad', this.nextContent?.content?.componentName);
    if (this.clear) {
      return true;
    }

    if ((this.nextContent?.content ?? null) === null) {
      return true;
    }

    return _runner.Runner.run(() => this.waitForConnected(), () => {
      this.nextContent.createComponent(this.connectedCE, this.options.fallback); // This shouldn't happen
      // // Don't stop it because we're not going to actually do anything
      // if (this.content.componentInstance === this.nextContent!.componentInstance) {
      //   return true;
      // }

      return this.nextContent.canLoad(this, this.content.instruction);
    });
  }

  load(recurse) {
    // console.log(this.connectedScope.toString(), 'viewport content load', this.nextContent?.content?.componentName);
    if (this.clear || (this.nextContent?.componentInstance ?? null) === null) {
      return;
    } // This shouldn't happen
    // // TODO: Verify this
    // if (this.nextContent === this.content) {
    //   return;
    // }


    return _runner.Runner.run(() => this.nextContent?.load(this.content.instruction)); // return this.nextContent?.load(this.content.instruction);
    // await this.nextContent.activateComponent(null, this.connectedCE!.$controller as ICustomElementController<ICustomElementViewModel>, LifecycleFlags.none, this.connectedCE!);
    // return true;
  }

  addContent() {
    // console.log('addContent', this.toString());
    return _runner.Runner.run(() => this.activate(null, this.connectedController, 0
    /* none */
    , this.parentNextContentActivated));
  }

  removeContent() {
    if (this.isEmpty) {
      return;
    } // console.log('removeContent', this.toString());


    return _runner.Runner.run(() => this.connectedScope.removeContent(), () => this.deactivate(null, null
    /* TODO: verify this.connectedController */
    , 0
    /* none */
    ), () => this.dispose());
  }

  removeChildrenContent() {
    // console.log(this.name, 'removeContent', this.content.content);
    return _runner.Runner.run(() => !this.isEmpty ? this.connectedScope.removeContent() : void 0);
  }

  activate(initiator, parent, flags, fromParent) {
    // console.log('activate' /* , { ...this } */);
    if (this.activeContent.componentInstance !== null) {
      this.connectedScope.reenableReplacedChildren();
      return _runner.Runner.run(() => this.activeContent.load(this.activeContent.instruction), // Only acts if not already loaded
      () => this.activeContent.activateComponent(initiator, parent, flags, this.connectedCE, fromParent));
    }
  }

  deactivate(initiator, parent, flags) {
    if (this.content.componentInstance && !this.content.reentry && this.content.componentInstance !== this.nextContent?.componentInstance) {
      return _runner.Runner.run(() => this.content?.unload(this.content.instruction), // Only acts if not already unloaded
      () => this.content?.deactivateComponent(initiator, parent, flags, this.connectedCE, this.router.statefulHistory || this.options.stateful));
    }
  }

  unload(recurse) {
    return _runner.Runner.run(() => recurse ? this.connectedScope.unload(recurse) : true, () => {
      // console.log(this.connectedScope.toString(), 'viewport content unload', this.content.content.componentName);
      // This shouldn't happen
      // // TODO: Verify this
      // if (this.nextContent === this.content) {
      //   return;
      // }
      if (this.content.componentInstance) {
        return this.content.unload(this.nextContent?.instruction ?? null);
      }
    });
  }

  dispose() {
    if (this.content.componentInstance && !this.content.reentry && this.content.componentInstance !== this.nextContent?.componentInstance) {
      return _runner.Runner.run( // () => this.content!.unloadComponent(
      //   this.historyCache,
      //   this.router.statefulHistory || this.options.stateful),
      // () => this.content!.destroyComponent(),
      () => this.content.disposeComponent(this.connectedCE, this.historyCache, this.router.statefulHistory || this.options.stateful)); // await this.content!.freeContent(
      //   this.connectedCE,
      //   this.nextContent!.instruction,
      //   this.historyCache,
      //   this.router.statefulHistory || this.options.stateful);
    }
  }

  finalizeContentChange() {
    // console.log('finalizeContent', this.nextContent!.content?.componentName);
    if (this.nextContent.componentInstance) {
      this.content = this.nextContent;
      this.content.reentry = false;
    }

    if (this.clear) {
      this.content = new _viewportContent.ViewportContent(void 0, this.nextContent.instruction);
    }

    this.nextContent = null;
    this.nextContentAction = '';
    this.previousViewportState = null;
    this.connectedScope.clearReplacedChildren();
  }

  abortContentChange() {
    this.connectedScope.reenableReplacedChildren();
    return _runner.Runner.run(() => this.nextContent.freeContent(this.connectedCE, this.nextContent.instruction, this.historyCache, this.router.statefulHistory || this.options.stateful), () => {
      if (this.previousViewportState) {
        Object.assign(this, this.previousViewportState);
      }

      this.nextContentAction = '';
    });
  } // TODO: Deal with non-string components


  wantComponent(component) {
    let usedBy = this.options.usedBy || [];

    if (typeof usedBy === 'string') {
      usedBy = usedBy.split(',');
    }

    return usedBy.includes(component);
  } // TODO: Deal with non-string components


  acceptComponent(component) {
    if (component === '-' || component === null) {
      return true;
    }

    let usedBy = this.options.usedBy;

    if (!usedBy || !usedBy.length) {
      return true;
    }

    if (typeof usedBy === 'string') {
      usedBy = usedBy.split(',');
    }

    if (usedBy.includes(component)) {
      return true;
    }

    if (usedBy.filter(value => value.includes('*')).length) {
      return true;
    }

    return false;
  }

  freeContent(component) {
    const content = this.historyCache.find(cached => cached.componentInstance === component);

    if (content !== void 0) {
      return _runner.Runner.run(() => {
        this.forceRemove = true;
        return content.freeContent(null, null, this.historyCache, false);
      }, () => {
        this.forceRemove = false;
        (0, _utils.arrayRemove)(this.historyCache, cached => cached === content);
      });
    }
  }

  getRoutes() {
    const componentType = this.getComponentType();

    if (componentType === null) {
      return null;
    }

    const routes = componentType.routes;
    return Array.isArray(routes) ? routes : null;
  }

  getTitle(navigationInstruction) {
    if (this.options.noTitle) {
      return '';
    }

    const componentType = this.getComponentType();

    if (componentType === null) {
      return '';
    }

    let title = '';
    const typeTitle = componentType.title;

    if (typeTitle !== void 0) {
      if (typeof typeTitle === 'string') {
        title = typeTitle;
      } else {
        const component = this.getComponentInstance();
        title = typeTitle.call(component, component, navigationInstruction);
      }
    } else if (this.router.options.title.useComponentNames) {
      let name = this.getContentInstruction().componentName ?? '';
      const prefix = this.router.options.title.componentPrefix ?? '';

      if (name.startsWith(prefix)) {
        name = name.slice(prefix.length);
      }

      name = name.replace('-', ' ');
      title = name.slice(0, 1).toLocaleUpperCase() + name.slice(1);
    }

    if (this.router.options.title.transformTitle !== void 0) {
      title = this.router.options.title.transformTitle.call(this, title, this.getContentInstruction());
    }

    return title;
  }

  getComponentType() {
    let componentType = this.getContentInstruction().componentType ?? null; // TODO: This is going away once Metadata is in!

    if (componentType === null) {
      const controller = _runtimeHtml.CustomElement.for(this.connectedCE.element);

      componentType = controller.context.componentType;
    }

    return componentType ?? null;
  }

  getComponentInstance() {
    return this.getContentInstruction().componentInstance ?? null;
  }

  getContentInstruction() {
    return this.nextContent?.content ?? this.content.content ?? null;
  }

  clearState() {
    this.options = {};
    this.content = new _viewportContent.ViewportContent();
    this.cache = [];
  }

  waitForConnected() {
    if (this.connectedCE === null) {
      return new Promise(resolve => {
        this.connectionResolve = resolve;
      });
    }
  }

}

exports.Viewport = Viewport;
});

;define.alias('@aurelia/router/viewport.js','@aurelia/router/dist/esm/viewport.js');
define('@aurelia/runtime-html/dist/esm/app-root.js',['require','exports','module','@aurelia/kernel','./dom.js','./app-task.js','./resources/custom-element.js','./templating/controller.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.AppRoot = exports.IAppRoot = void 0;

var _kernel = require("@aurelia/kernel");

var _dom = require("./dom.js");

var _appTask = require("./app-task.js");

var _customElement = require("./resources/custom-element.js");

var _controller = require("./templating/controller.js");

const IAppRoot = _kernel.DI.createInterface('IAppRoot');

exports.IAppRoot = IAppRoot;

class AppRoot {
  constructor(config, platform, container, rootProvider, enhance = false) {
    this.config = config;
    this.platform = platform;
    this.container = container;
    this.controller = void 0;
    this.hydratePromise = void 0;
    this.host = config.host;
    rootProvider.prepare(this);

    if (container.has(_dom.INode, false) && container.get(_dom.INode) !== config.host) {
      this.container = container.createChild();
    }

    this.container.register(_kernel.Registration.instance(_dom.INode, config.host));

    if (enhance) {
      const component = config.component;
      this.enhanceDefinition = _customElement.CustomElement.getDefinition(_customElement.CustomElement.isType(component) ? _customElement.CustomElement.define({ ..._customElement.CustomElement.getDefinition(component),
        template: this.host,
        enhance: true
      }, component) : _customElement.CustomElement.define({
        name: void 0,
        template: this.host,
        enhance: true
      }));
    }

    this.hydratePromise = (0, _kernel.onResolve)(this.runAppTasks('beforeCreate'), () => {
      const instance = _customElement.CustomElement.isType(config.component) ? this.container.get(config.component) : config.component;

      const controller = this.controller = _controller.Controller.forCustomElement(this, container, instance, this.host, null, 0
      /* none */
      , false, this.enhanceDefinition);

      controller.hydrateCustomElement(container, null);
      return (0, _kernel.onResolve)(this.runAppTasks('hydrating'), () => {
        controller.hydrate(null);
        return (0, _kernel.onResolve)(this.runAppTasks('hydrated'), () => {
          controller.hydrateChildren();
          this.hydratePromise = void 0;
        });
      });
    });
  }

  activate() {
    return (0, _kernel.onResolve)(this.hydratePromise, () => {
      return (0, _kernel.onResolve)(this.runAppTasks('beforeActivate'), () => {
        return (0, _kernel.onResolve)(this.controller.activate(this.controller, null, 32
        /* fromBind */
        , void 0), () => {
          return this.runAppTasks('afterActivate');
        });
      });
    });
  }

  deactivate() {
    return (0, _kernel.onResolve)(this.runAppTasks('beforeDeactivate'), () => {
      return (0, _kernel.onResolve)(this.controller.deactivate(this.controller, null, 0
      /* none */
      ), () => {
        return this.runAppTasks('afterDeactivate');
      });
    });
  }
  /** @internal */


  runAppTasks(slot) {
    return (0, _kernel.resolveAll)(...this.container.getAll(_appTask.IAppTask).reduce((results, task) => {
      if (task.slot === slot) {
        results.push(task.run());
      }

      return results;
    }, []));
  }

  dispose() {
    this.controller?.dispose();
  }

}

exports.AppRoot = AppRoot;
});

;define.alias('@aurelia/runtime-html/app-root.js','@aurelia/runtime-html/dist/esm/app-root.js');
define('@aurelia/runtime-html/dist/esm/app-task.js',['require','exports','module','@aurelia/kernel'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.AppTask = exports.IAppTask = void 0;

var _kernel = require("@aurelia/kernel");

const IAppTask = _kernel.DI.createInterface('IAppTask');

exports.IAppTask = IAppTask;

class $AppTask {
  constructor(key) {
    this.key = key;
    this.slot = void 0;
    this.callback = void 0;
    this.container = void 0;
  }

  static with(key) {
    return new $AppTask(key);
  }

  beforeCreate() {
    return this.at('beforeCreate');
  }

  hydrating() {
    return this.at('hydrating');
  }

  hydrated() {
    return this.at('hydrated');
  }

  beforeActivate() {
    return this.at('beforeActivate');
  }

  afterActivate() {
    return this.at('afterActivate');
  }

  beforeDeactivate() {
    return this.at('beforeDeactivate');
  }

  afterDeactivate() {
    return this.at('afterDeactivate');
  }

  at(slot) {
    this.slot = slot;
    return this;
  }

  call(fn) {
    this.callback = fn;
    return this;
  }

  register(container) {
    return this.container = container.register(_kernel.Registration.instance(IAppTask, this));
  }

  run() {
    const callback = this.callback;
    const instance = this.container.get(this.key);
    return callback(instance);
  }

}

const AppTask = $AppTask;
exports.AppTask = AppTask;
});

;define.alias('@aurelia/runtime-html/app-task.js','@aurelia/runtime-html/dist/esm/app-task.js');
define('@aurelia/runtime-html/dist/esm/attribute-syntax-transformer.js',['require','exports','module','@aurelia/kernel'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.AttrSyntaxTransformer = exports.IAttrSyntaxTransformer = void 0;

var _kernel = require("@aurelia/kernel");

const IAttrSyntaxTransformer = _kernel.DI.createInterface('IAttrSyntaxTransformer', x => x.singleton(AttrSyntaxTransformer));

exports.IAttrSyntaxTransformer = IAttrSyntaxTransformer;

class AttrSyntaxTransformer {
  constructor() {
    /**
     * @internal
     */
    this.fns = [];
  }
  /**
   * Add a given function to a list of fns that will be used
   * to check if `'bind'` command can be transformed to `'two-way'` command.
   *
   * If one of those functions in this lists returns true, the `'bind'` command
   * will be transformed into `'two-way'` command.
   *
   * The function will be called with 2 parameters:
   * - element: the element that the template compiler is currently working with
   * - property: the target property name
   */


  useTwoWay(fn) {
    this.fns.push(fn);
  }
  /**
   * @internal
   */


  transform(node, attrSyntax) {
    if (attrSyntax.command === 'bind' && ( // note: even though target could possibly be mapped to a different name
    // the final property name shouldn't affect the two way transformation
    // as they both should work with original source attribute name
    shouldDefaultToTwoWay(node, attrSyntax.target) || this.fns.length > 0 && this.fns.some(fn => fn(node, attrSyntax.target)))) {
      attrSyntax.command = 'two-way';
    }

    attrSyntax.target = this.map(node.tagName, attrSyntax.target);
  }
  /**
   * todo: this should be in the form of a lookup. the following is not extensible
   *
   * @internal
   */


  map(tagName, attr) {
    switch (tagName) {
      case 'LABEL':
        switch (attr) {
          case 'for':
            return 'htmlFor';

          default:
            return attr;
        }

      case 'IMG':
        switch (attr) {
          case 'usemap':
            return 'useMap';

          default:
            return attr;
        }

      case 'INPUT':
        switch (attr) {
          case 'maxlength':
            return 'maxLength';

          case 'minlength':
            return 'minLength';

          case 'formaction':
            return 'formAction';

          case 'formenctype':
            return 'formEncType';

          case 'formmethod':
            return 'formMethod';

          case 'formnovalidate':
            return 'formNoValidate';

          case 'formtarget':
            return 'formTarget';

          case 'inputmode':
            return 'inputMode';

          default:
            return attr;
        }

      case 'TEXTAREA':
        switch (attr) {
          case 'maxlength':
            return 'maxLength';

          default:
            return attr;
        }

      case 'TD':
      case 'TH':
        switch (attr) {
          case 'rowspan':
            return 'rowSpan';

          case 'colspan':
            return 'colSpan';

          default:
            return attr;
        }

      default:
        switch (attr) {
          case 'accesskey':
            return 'accessKey';

          case 'contenteditable':
            return 'contentEditable';

          case 'tabindex':
            return 'tabIndex';

          case 'textcontent':
            return 'textContent';

          case 'innerhtml':
            return 'innerHTML';

          case 'scrolltop':
            return 'scrollTop';

          case 'scrollleft':
            return 'scrollLeft';

          case 'readonly':
            return 'readOnly';

          default:
            return attr;
        }

    }
  }

}

exports.AttrSyntaxTransformer = AttrSyntaxTransformer;

function shouldDefaultToTwoWay(element, attr) {
  switch (element.tagName) {
    case 'INPUT':
      switch (element.type) {
        case 'checkbox':
        case 'radio':
          return attr === 'checked';

        default:
          return attr === 'value' || attr === 'files';
      }

    case 'TEXTAREA':
    case 'SELECT':
      return attr === 'value';

    default:
      switch (attr) {
        case 'textcontent':
        case 'innerhtml':
          return element.hasAttribute('contenteditable');

        case 'scrolltop':
        case 'scrollleft':
          return true;

        default:
          return false;
      }

  }
}
});

;define.alias('@aurelia/runtime-html/attribute-syntax-transformer.js','@aurelia/runtime-html/dist/esm/attribute-syntax-transformer.js');
define('@aurelia/runtime-html/dist/esm/aurelia.js',['require','exports','module','@aurelia/kernel','@aurelia/platform-browser','./app-root.js','./platform.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.Aurelia = exports.IAurelia = void 0;

var _kernel = require("@aurelia/kernel");

var _platformBrowser = require("@aurelia/platform-browser");

var _appRoot = require("./app-root.js");

var _platform = require("./platform.js");

const IAurelia = _kernel.DI.createInterface('IAurelia');

exports.IAurelia = IAurelia;

class Aurelia {
  constructor(container = _kernel.DI.createContainer()) {
    this.container = container;
    this._isRunning = false;
    this._isStarting = false;
    this._isStopping = false;
    this._root = void 0;
    this.next = void 0;
    this.startPromise = void 0;
    this.stopPromise = void 0;

    if (container.has(IAurelia, true)) {
      throw new Error('An instance of Aurelia is already registered with the container or an ancestor of it.');
    }

    container.register(_kernel.Registration.instance(IAurelia, this));
    container.registerResolver(_appRoot.IAppRoot, this.rootProvider = new _kernel.InstanceProvider('IAppRoot'));
  }

  get isRunning() {
    return this._isRunning;
  }

  get isStarting() {
    return this._isStarting;
  }

  get isStopping() {
    return this._isStopping;
  }

  get root() {
    if (this._root == void 0) {
      if (this.next == void 0) {
        throw new Error(`root is not defined`); // TODO: create error code
      }

      return this.next;
    }

    return this._root;
  }

  register(...params) {
    this.container.register(...params);
    return this;
  }

  app(config) {
    this.next = new _appRoot.AppRoot(config, this.initPlatform(config.host), this.container, this.rootProvider, false);
    return this;
  }

  enhance(config) {
    this.next = new _appRoot.AppRoot(config, this.initPlatform(config.host), this.container, this.rootProvider, true);
    return this;
  }

  async waitForIdle() {
    const platform = this.root.platform;
    await platform.domWriteQueue.yield();
    await platform.domReadQueue.yield();
    await platform.macroTaskQueue.yield();
  }

  initPlatform(host) {
    let p;

    if (!this.container.has(_platform.IPlatform, false)) {
      if (host.ownerDocument.defaultView === null) {
        throw new Error(`Failed to initialize the platform object. The host element's ownerDocument does not have a defaultView`);
      }

      p = new _platformBrowser.BrowserPlatform(host.ownerDocument.defaultView);
      this.container.register(_kernel.Registration.instance(_platform.IPlatform, p));
    } else {
      p = this.container.get(_platform.IPlatform);
    }

    return p;
  }

  start(root = this.next) {
    if (root == void 0) {
      throw new Error(`There is no composition root`);
    }

    if (this.startPromise instanceof Promise) {
      return this.startPromise;
    }

    return this.startPromise = (0, _kernel.onResolve)(this.stop(), () => {
      Reflect.set(root.host, '$aurelia', this);
      this.rootProvider.prepare(this._root = root);
      this._isStarting = true;
      return (0, _kernel.onResolve)(root.activate(), () => {
        this._isRunning = true;
        this._isStarting = false;
        this.startPromise = void 0;
        this.dispatchEvent(root, 'au-started', root.host);
      });
    });
  }

  stop(dispose = false) {
    if (this.stopPromise instanceof Promise) {
      return this.stopPromise;
    }

    if (this._isRunning === true) {
      const root = this._root;
      this._isRunning = false;
      this._isStopping = true;
      return this.stopPromise = (0, _kernel.onResolve)(root.deactivate(), () => {
        Reflect.deleteProperty(root.host, '$aurelia');

        if (dispose) {
          root.dispose();
        }

        this._root = void 0;
        this.rootProvider.dispose();
        this._isStopping = false;
        this.dispatchEvent(root, 'au-stopped', root.host);
      });
    }
  }

  dispose() {
    if (this._isRunning || this._isStopping) {
      throw new Error(`The aurelia instance must be fully stopped before it can be disposed`);
    }

    this.container.dispose();
  }

  dispatchEvent(root, name, target) {
    const ev = new root.platform.window.CustomEvent(name, {
      detail: this,
      bubbles: true,
      cancelable: true
    });
    target.dispatchEvent(ev);
  }

}

exports.Aurelia = Aurelia;
});

;define.alias('@aurelia/runtime-html/aurelia.js','@aurelia/runtime-html/dist/esm/aurelia.js');
define('@aurelia/runtime-html/dist/esm/bindable.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.bindable = bindable;
exports.BindableDefinition = exports.Bindable = void 0;

var _kernel = require("@aurelia/kernel");

var _runtime = require("@aurelia/runtime");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

function bindable(configOrTarget, prop) {
  let config;

  function decorator($target, $prop) {
    if (arguments.length > 1) {
      // Non invocation:
      // - @bindable
      // Invocation with or w/o opts:
      // - @bindable()
      // - @bindable({...opts})
      config.property = $prop;
    }

    _kernel.Metadata.define(Bindable.name, BindableDefinition.create($prop, config), $target.constructor, $prop);

    _kernel.Protocol.annotation.appendTo($target.constructor, Bindable.keyFrom($prop));
  }

  if (arguments.length > 1) {
    // Non invocation:
    // - @bindable
    config = {};
    decorator(configOrTarget, prop);
    return;
  } else if (typeof configOrTarget === 'string') {
    // ClassDecorator
    // - @bindable('bar')
    // Direct call:
    // - @bindable('bar')(Foo)
    config = {};
    return decorator;
  } // Invocation with or w/o opts:
  // - @bindable()
  // - @bindable({...opts})


  config = configOrTarget === void 0 ? {} : configOrTarget;
  return decorator;
}

function isBindableAnnotation(key) {
  return key.startsWith(Bindable.name);
}

const Bindable = {
  name: _kernel.Protocol.annotation.keyFor('bindable'),

  keyFrom(name) {
    return `${Bindable.name}:${name}`;
  },

  from(...bindableLists) {
    const bindables = {};
    const isArray = Array.isArray;

    function addName(name) {
      bindables[name] = BindableDefinition.create(name);
    }

    function addDescription(name, def) {
      bindables[name] = def instanceof BindableDefinition ? def : BindableDefinition.create(name, def);
    }

    function addList(maybeList) {
      if (isArray(maybeList)) {
        maybeList.forEach(addName);
      } else if (maybeList instanceof BindableDefinition) {
        bindables[maybeList.property] = maybeList;
      } else if (maybeList !== void 0) {
        Object.keys(maybeList).forEach(name => addDescription(name, maybeList[name]));
      }
    }

    bindableLists.forEach(addList);
    return bindables;
  },

  for(Type) {
    let def;
    const builder = {
      add(configOrProp) {
        let prop;
        let config;

        if (typeof configOrProp === 'string') {
          prop = configOrProp;
          config = {
            property: prop
          };
        } else {
          prop = configOrProp.property;
          config = configOrProp;
        }

        def = BindableDefinition.create(prop, config);

        if (!_kernel.Metadata.hasOwn(Bindable.name, Type, prop)) {
          _kernel.Protocol.annotation.appendTo(Type, Bindable.keyFrom(prop));
        }

        _kernel.Metadata.define(Bindable.name, def, Type, prop);

        return builder;
      },

      mode(mode) {
        def.mode = mode;
        return builder;
      },

      callback(callback) {
        def.callback = callback;
        return builder;
      },

      attribute(attribute) {
        def.attribute = attribute;
        return builder;
      },

      primary() {
        def.primary = true;
        return builder;
      },

      set(setInterpreter) {
        def.set = setInterpreter;
        return builder;
      }

    };
    return builder;
  },

  getAll(Type) {
    const propStart = Bindable.name.length + 1;
    const defs = [];
    const prototypeChain = (0, _kernel.getPrototypeChain)(Type);
    let iProto = prototypeChain.length;
    let iDefs = 0;
    let keys;
    let keysLen;
    let Class;

    while (--iProto >= 0) {
      Class = prototypeChain[iProto];
      keys = _kernel.Protocol.annotation.getKeys(Class).filter(isBindableAnnotation);
      keysLen = keys.length;

      for (let i = 0; i < keysLen; ++i) {
        defs[iDefs++] = _kernel.Metadata.getOwn(Bindable.name, Class, keys[i].slice(propStart));
      }
    }

    return defs;
  }

};
exports.Bindable = Bindable;

class BindableDefinition {
  constructor(attribute, callback, mode, primary, property, set) {
    this.attribute = attribute;
    this.callback = callback;
    this.mode = mode;
    this.primary = primary;
    this.property = property;
    this.set = set;
  }

  static create(prop, def = {}) {
    return new BindableDefinition((0, _kernel.firstDefined)(def.attribute, (0, _kernel.kebabCase)(prop)), (0, _kernel.firstDefined)(def.callback, `${prop}Changed`), (0, _kernel.firstDefined)(def.mode, _runtime.BindingMode.toView), (0, _kernel.firstDefined)(def.primary, false), (0, _kernel.firstDefined)(def.property, prop), (0, _kernel.firstDefined)(def.set, _kernel.noop));
  }

}
/* eslint-disable @typescript-eslint/no-unused-vars,spaced-comment */

/**
 * This function serves two purposes:
 * - A playground for contributors to try their changes to the APIs.
 * - Cause the API surface to be properly type-checked and protected against accidental type regressions.
 *
 * It will be automatically removed by dead code elimination.
 */


exports.BindableDefinition = BindableDefinition;

function apiTypeCheck() {
  let Foo = // > expected error - class decorator only accepts a string
  //@bindable({})
  class Foo {};

  __decorate([bindable, bindable(), bindable({}) // > expected error - 'property' does not exist on decorator input object
  //@bindable({ property: 'prop' })
  , bindable({
    mode: _runtime.BindingMode.twoWay
  }), bindable({
    callback: 'propChanged'
  }), bindable({
    attribute: 'prop'
  }), bindable({
    primary: true
  }), bindable({
    set: value => String(value)
  }), bindable({
    set: value => Number(value)
  }), bindable({
    mode: _runtime.BindingMode.twoWay,
    callback: 'propChanged',
    attribute: 'prop',
    primary: true,
    set: value => String(value)
  })], Foo.prototype, "prop", void 0);

  Foo = __decorate([bindable('prop') // > expected error - class decorator only accepts a string
  //@bindable({})
  ], Foo);
  Bindable.for(Foo) // > expected error - there is no add() function with only optional params on the fluent api
  //.add()
  // > expected error - 'property' is a required property on the fluent api
  //.add({})
  .add({
    property: 'prop'
  }).add({
    property: 'prop',
    mode: _runtime.BindingMode.twoWay
  }).add({
    property: 'prop',
    callback: 'propChanged'
  }).add({
    property: 'prop',
    attribute: 'prop'
  }).add({
    property: 'prop',
    primary: true
  }).add({
    property: 'prop',
    mode: _runtime.BindingMode.twoWay,
    callback: 'propChanged',
    attribute: 'prop',
    primary: true
  }).add('prop') // > expected error - the add() method that accepts an object literal does not return a fluent api
  //.add({ property: 'prop' }).mode(BindingMode.twoWay)
  //.add({ property: 'prop' }).callback('propChanged')
  //.add({ property: 'prop' }).attribute('prop')
  //.add({ property: 'prop' }).primary()
  // > expected error - fluent api methods can only be invoked once per bindable
  //.add('prop').mode(BindingMode.twoWay).mode(BindingMode.twoWay)
  //.add('prop').mode(BindingMode.twoWay).callback('propChanged').mode(BindingMode.twoWay)
  //.add('prop').mode(BindingMode.twoWay).callback('propChanged').callback('propChanged') // etc
  // > expected error - wrong invocation order
  //.add('prop').callback('propChanged').mode(BindingMode.twoWay)
  //.add('prop').primary().mode(BindingMode.twoWay)  // etc
  .add('prop').mode(_runtime.BindingMode.twoWay).add('prop').mode(_runtime.BindingMode.twoWay).callback('propChanged').add('prop').mode(_runtime.BindingMode.twoWay).callback('propChanged').attribute('prop').add('prop').mode(_runtime.BindingMode.twoWay).callback('propChanged').attribute('prop').primary().add('prop').mode(_runtime.BindingMode.twoWay).set(value => Number(value)).add('prop').mode(_runtime.BindingMode.twoWay).callback('propChanged').set(value => Number(value)).add('prop').callback('propChanged').add('prop').callback('propChanged').attribute('prop').add('prop').callback('propChanged').attribute('prop').primary().add('prop').attribute('prop').add('prop').attribute('prop').primary().add('prop').primary();
}
/* eslint-enable @typescript-eslint/no-unused-vars,spaced-comment */
});

;define.alias('@aurelia/runtime-html/bindable.js','@aurelia/runtime-html/dist/esm/bindable.js');
define('@aurelia/runtime-html/dist/esm/binding-behaviors/binding-mode.js',['require','exports','module','@aurelia/runtime'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.TwoWayBindingBehavior = exports.FromViewBindingBehavior = exports.ToViewBindingBehavior = exports.OneTimeBindingBehavior = exports.BindingModeBehavior = void 0;

var _runtime = require("@aurelia/runtime");

class BindingModeBehavior {
  constructor(mode) {
    this.mode = mode;
    this.originalModes = new Map();
  }

  bind(flags, scope, hostScope, binding) {
    this.originalModes.set(binding, binding.mode);
    binding.mode = this.mode;
  }

  unbind(flags, scope, hostScope, binding) {
    binding.mode = this.originalModes.get(binding);
    this.originalModes.delete(binding);
  }

}

exports.BindingModeBehavior = BindingModeBehavior;

class OneTimeBindingBehavior extends BindingModeBehavior {
  constructor() {
    super(_runtime.BindingMode.oneTime);
  }

}

exports.OneTimeBindingBehavior = OneTimeBindingBehavior;

class ToViewBindingBehavior extends BindingModeBehavior {
  constructor() {
    super(_runtime.BindingMode.toView);
  }

}

exports.ToViewBindingBehavior = ToViewBindingBehavior;

class FromViewBindingBehavior extends BindingModeBehavior {
  constructor() {
    super(_runtime.BindingMode.fromView);
  }

}

exports.FromViewBindingBehavior = FromViewBindingBehavior;

class TwoWayBindingBehavior extends BindingModeBehavior {
  constructor() {
    super(_runtime.BindingMode.twoWay);
  }

}

exports.TwoWayBindingBehavior = TwoWayBindingBehavior;
(0, _runtime.bindingBehavior)('oneTime')(OneTimeBindingBehavior);
(0, _runtime.bindingBehavior)('toView')(ToViewBindingBehavior);
(0, _runtime.bindingBehavior)('fromView')(FromViewBindingBehavior);
(0, _runtime.bindingBehavior)('twoWay')(TwoWayBindingBehavior);
});

;define.alias('@aurelia/runtime-html/binding-behaviors/binding-mode.js','@aurelia/runtime-html/dist/esm/binding-behaviors/binding-mode.js');
define('@aurelia/runtime-html/dist/esm/binding-behaviors/debounce.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.DebounceBindingBehavior = void 0;

var _kernel = require("@aurelia/kernel");

var _runtime = require("@aurelia/runtime");

class DebounceBindingBehavior extends _runtime.BindingInterceptor {
  constructor(binding, expr) {
    super(binding, expr);
    this.opts = {
      delay: 0
    };
    this.firstArg = null;
    this.task = null;
    this.taskQueue = binding.locator.get(_kernel.IPlatform).macroTaskQueue;

    if (expr.args.length > 0) {
      this.firstArg = expr.args[0];
    }
  }

  callSource(args) {
    this.queueTask(() => this.binding.callSource(args));
    return void 0;
  }

  handleChange(newValue, previousValue, flags) {
    this.queueTask(() => this.binding.handleChange(newValue, previousValue, flags));
  }

  queueTask(callback) {
    if (this.task !== null) {
      this.task.cancel();
    }

    this.task = this.taskQueue.queueTask(() => {
      this.task = null;
      return callback();
    }, this.opts);
  }

  $bind(flags, scope, hostScope) {
    if (this.firstArg !== null) {
      const delay = Number(this.firstArg.evaluate(flags, scope, hostScope, this.locator, null));

      if (!isNaN(delay)) {
        this.opts.delay = delay;
      }
    }

    this.binding.$bind(flags, scope, hostScope);
  }

  $unbind(flags) {
    this.task?.cancel();
    this.task = null;
    this.binding.$unbind(flags);
  }

}

exports.DebounceBindingBehavior = DebounceBindingBehavior;
(0, _runtime.bindingBehavior)('debounce')(DebounceBindingBehavior);
});

;define.alias('@aurelia/runtime-html/binding-behaviors/debounce.js','@aurelia/runtime-html/dist/esm/binding-behaviors/debounce.js');
define('@aurelia/runtime-html/dist/esm/binding-behaviors/signals.js',['require','exports','module','@aurelia/runtime'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.SignalBindingBehavior = void 0;

var _runtime = require("@aurelia/runtime");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

let SignalBindingBehavior = class SignalBindingBehavior {
  constructor(signaler) {
    this.signaler = signaler;
    this.lookup = new Map();
  }

  bind(flags, scope, hostScope, binding, ...names) {
    if (!('handleChange' in binding)) {
      throw new Error(`The signal behavior can only be used with bindings that have a 'handleChange' method`);
    }

    if (names.length === 0) {
      throw new Error(`At least one signal name must be passed to the signal behavior, e.g. \`expr & signal:'my-signal'\``);
    }

    this.lookup.set(binding, names);

    for (const name of names) {
      this.signaler.addSignalListener(name, binding);
    }
  }

  unbind(flags, scope, hostScope, binding) {
    const names = this.lookup.get(binding);
    this.lookup.delete(binding);

    for (const name of names) {
      this.signaler.removeSignalListener(name, binding);
    }
  }

};
exports.SignalBindingBehavior = SignalBindingBehavior;
exports.SignalBindingBehavior = SignalBindingBehavior = __decorate([__param(0, _runtime.ISignaler)], SignalBindingBehavior);
(0, _runtime.bindingBehavior)('signal')(SignalBindingBehavior);
});

;define.alias('@aurelia/runtime-html/binding-behaviors/signals.js','@aurelia/runtime-html/dist/esm/binding-behaviors/signals.js');
define('@aurelia/runtime-html/dist/esm/binding-behaviors/throttle.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.ThrottleBindingBehavior = void 0;

var _kernel = require("@aurelia/kernel");

var _runtime = require("@aurelia/runtime");

class ThrottleBindingBehavior extends _runtime.BindingInterceptor {
  constructor(binding, expr) {
    super(binding, expr);
    this.opts = {
      delay: 0
    };
    this.firstArg = null;
    this.task = null;
    this.lastCall = 0;
    this.platform = binding.locator.get(_kernel.IPlatform);
    this.taskQueue = this.platform.macroTaskQueue;

    if (expr.args.length > 0) {
      this.firstArg = expr.args[0];
    }
  }

  callSource(args) {
    this.queueTask(() => this.binding.callSource(args));
    return void 0;
  }

  handleChange(newValue, previousValue, flags) {
    this.queueTask(() => this.binding.handleChange(newValue, previousValue, flags));
  }

  queueTask(callback) {
    const opts = this.opts;
    const platform = this.platform;
    const nextDelay = this.lastCall + opts.delay - platform.performanceNow();

    if (nextDelay > 0) {
      if (this.task !== null) {
        this.task.cancel();
      }

      opts.delay = nextDelay;
      this.task = this.taskQueue.queueTask(() => {
        this.lastCall = platform.performanceNow();
        this.task = null;
        callback();
      }, opts);
    } else {
      this.lastCall = platform.performanceNow();
      callback();
    }
  }

  $bind(flags, scope, hostScope) {
    if (this.firstArg !== null) {
      const delay = Number(this.firstArg.evaluate(flags, scope, hostScope, this.locator, null));

      if (!isNaN(delay)) {
        this.opts.delay = delay;
      }
    }

    this.binding.$bind(flags, scope, hostScope);
  }

  $unbind(flags) {
    this.task?.cancel();
    this.task = null;
    super.$unbind(flags);
  }

}

exports.ThrottleBindingBehavior = ThrottleBindingBehavior;
(0, _runtime.bindingBehavior)('throttle')(ThrottleBindingBehavior);
});

;define.alias('@aurelia/runtime-html/binding-behaviors/throttle.js','@aurelia/runtime-html/dist/esm/binding-behaviors/throttle.js');
define('@aurelia/runtime-html/dist/esm/binding/attribute.js',['require','exports','module','@aurelia/runtime','../observation/element-attribute-observer.js','../platform.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.AttributeBinding = void 0;

var _runtime = require("@aurelia/runtime");

var _elementAttributeObserver = require("../observation/element-attribute-observer.js");

var _platform = require("../platform.js");

// BindingMode is not a const enum (and therefore not inlined), so assigning them to a variable to save a member accessor is a minor perf tweak
const {
  oneTime,
  toView,
  fromView
} = _runtime.BindingMode; // pre-combining flags for bitwise checks is a minor perf tweak

const toViewOrOneTime = toView | oneTime;
const taskOptions = {
  reusable: false,
  preempt: true
};
/**
 * Attribute binding. Handle attribute binding betwen view/view model. Understand Html special attributes
 */

class AttributeBinding {
  constructor(sourceExpression, target, // some attributes may have inner structure
  // such as class -> collection of class names
  // such as style -> collection of style rules
  //
  // for normal attributes, targetAttribute and targetProperty are the same and can be ignore
  targetAttribute, targetProperty, mode, observerLocator, locator) {
    this.sourceExpression = sourceExpression;
    this.targetAttribute = targetAttribute;
    this.targetProperty = targetProperty;
    this.mode = mode;
    this.observerLocator = observerLocator;
    this.locator = locator;
    this.interceptor = this;
    this.isBound = false;
    this.$scope = null;
    this.$hostScope = null;
    this.task = null;
    this.persistentFlags = 0
    /* none */
    ;
    this.value = void 0;
    this.target = target;

    _runtime.connectable.assignIdTo(this);

    this.$platform = locator.get(_platform.IPlatform);
  }

  updateTarget(value, flags) {
    flags |= this.persistentFlags;
    this.targetObserver.setValue(value, flags | 8
    /* updateTarget */
    , this.target, this.targetProperty);
  }

  updateSource(value, flags) {
    flags |= this.persistentFlags;
    this.sourceExpression.assign(flags | 16
    /* updateSource */
    , this.$scope, this.$hostScope, this.locator, value);
  }

  handleChange(newValue, _previousValue, flags) {
    if (!this.isBound) {
      return;
    }

    flags |= this.persistentFlags;
    const mode = this.mode;
    const interceptor = this.interceptor;
    const sourceExpression = this.sourceExpression;
    const $scope = this.$scope;
    const locator = this.locator;

    if (mode === _runtime.BindingMode.fromView) {
      flags &= ~8
      /* updateTarget */
      ;
      flags |= 16
      /* updateSource */
      ;
    }

    if (flags & 8
    /* updateTarget */
    ) {
        const targetObserver = this.targetObserver; // Alpha: during bind a simple strategy for bind is always flush immediately
        // todo:
        //  (1). determine whether this should be the behavior
        //  (2). if not, then fix tests to reflect the changes/platform to properly yield all with aurelia.start()

        const shouldQueueFlush = (flags & 32
        /* fromBind */
        ) === 0 && (targetObserver.type & 4
        /* Layout */
        ) > 0;

        if (sourceExpression.$kind !== 10082
        /* AccessScope */
        || this.obs.count > 1) {
          const shouldConnect = (mode & oneTime) === 0;

          if (shouldConnect) {
            this.obs.version++;
          }

          newValue = sourceExpression.evaluate(flags, $scope, this.$hostScope, locator, interceptor);

          if (shouldConnect) {
            this.obs.clear(false);
          }
        }

        if (newValue !== this.value) {
          this.value = newValue;

          if (shouldQueueFlush) {
            this.task?.cancel();
            this.task = this.$platform.domWriteQueue.queueTask(() => {
              this.task = null;
              interceptor.updateTarget(newValue, flags);
            }, taskOptions);
          } else {
            interceptor.updateTarget(newValue, flags);
          }
        }

        return;
      }

    if (flags & 16
    /* updateSource */
    ) {
        if (newValue !== sourceExpression.evaluate(flags, $scope, this.$hostScope, locator, null)) {
          interceptor.updateSource(newValue, flags);
        }

        return;
      }

    throw new Error('Unexpected handleChange context in AttributeBinding');
  }

  $bind(flags, scope, hostScope, projection) {
    if (this.isBound) {
      if (this.$scope === scope) {
        return;
      }

      this.interceptor.$unbind(flags | 32
      /* fromBind */
      );
    } // Store flags which we can only receive during $bind and need to pass on
    // to the AST during evaluate/connect/assign


    this.persistentFlags = flags & 15367
    /* persistentBindingFlags */
    ;
    this.$scope = scope;
    this.$hostScope = hostScope;
    this.projection = projection;
    let sourceExpression = this.sourceExpression;

    if (sourceExpression.hasBind) {
      sourceExpression.bind(flags, scope, hostScope, this.interceptor);
    }

    let targetObserver = this.targetObserver;

    if (!targetObserver) {
      targetObserver = this.targetObserver = new _elementAttributeObserver.AttributeObserver(this.$platform, this.observerLocator, this.target, this.targetProperty, this.targetAttribute);
    } // during bind, binding behavior might have changed sourceExpression


    sourceExpression = this.sourceExpression;
    const $mode = this.mode;
    const interceptor = this.interceptor;

    if ($mode & toViewOrOneTime) {
      const shouldConnect = ($mode & toView) > 0;
      interceptor.updateTarget(this.value = sourceExpression.evaluate(flags, scope, this.$hostScope, this.locator, shouldConnect ? interceptor : null), flags);
    }

    if ($mode & fromView) {
      targetObserver[this.id] |= 16
      /* updateSource */
      ;
      targetObserver.subscribe(interceptor);
    }

    this.isBound = true;
  }

  $unbind(flags) {
    if (!this.isBound) {
      return;
    } // clear persistent flags


    this.persistentFlags = 0
    /* none */
    ;

    if (this.sourceExpression.hasUnbind) {
      this.sourceExpression.unbind(flags, this.$scope, this.$hostScope, this.interceptor);
    }

    this.$scope = this.$hostScope = null;
    this.value = void 0;
    const targetObserver = this.targetObserver;

    if (targetObserver.unsubscribe) {
      targetObserver.unsubscribe(this.interceptor);
      targetObserver[this.id] &= ~16
      /* updateSource */
      ;
    }

    this.task?.cancel();
    this.task = null;
    this.obs.clear(true); // remove isBound and isUnbinding flags

    this.isBound = false;
  }

}

exports.AttributeBinding = AttributeBinding;
(0, _runtime.connectable)(AttributeBinding);
});

;define.alias('@aurelia/runtime-html/binding/attribute.js','@aurelia/runtime-html/dist/esm/binding/attribute.js');
define('@aurelia/runtime-html/dist/esm/binding/call-binding.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.CallBinding = void 0;

class CallBinding {
  constructor(sourceExpression, target, targetProperty, observerLocator, locator) {
    this.sourceExpression = sourceExpression;
    this.target = target;
    this.targetProperty = targetProperty;
    this.locator = locator;
    this.interceptor = this;
    this.isBound = false;
    this.$hostScope = null;
    this.targetObserver = observerLocator.getObserver(target, targetProperty);
  }

  callSource(args) {
    const overrideContext = this.$scope.overrideContext; // really need to delete the following line
    // and the for..in loop below
    // convenience in the template won't outweight the draw back of such confusing feature
    // OR, at the very least, use getter/setter for each property in args to get/set original source
    // ---

    Object.assign(overrideContext, args);
    const result = this.sourceExpression.evaluate(128
    /* mustEvaluate */
    , this.$scope, this.$hostScope, this.locator, null);

    for (const prop in args) {
      Reflect.deleteProperty(overrideContext, prop);
    }

    return result;
  }

  $bind(flags, scope, hostScope) {
    if (this.isBound) {
      if (this.$scope === scope) {
        return;
      }

      this.interceptor.$unbind(flags | 32
      /* fromBind */
      );
    }

    this.$scope = scope;
    this.$hostScope = hostScope;

    if (this.sourceExpression.hasBind) {
      this.sourceExpression.bind(flags, scope, hostScope, this.interceptor);
    }

    this.targetObserver.setValue($args => this.interceptor.callSource($args), flags, this.target, this.targetProperty); // add isBound flag and remove isBinding flag

    this.isBound = true;
  }

  $unbind(flags) {
    if (!this.isBound) {
      return;
    }

    if (this.sourceExpression.hasUnbind) {
      this.sourceExpression.unbind(flags, this.$scope, this.$hostScope, this.interceptor);
    }

    this.$scope = void 0;
    this.targetObserver.setValue(null, flags, this.target, this.targetProperty);
    this.isBound = false;
  }

  observeProperty(obj, propertyName) {
    return;
  }

  handleChange(newValue, previousValue, flags) {
    return;
  }

}

exports.CallBinding = CallBinding;
});

;define.alias('@aurelia/runtime-html/binding/call-binding.js','@aurelia/runtime-html/dist/esm/binding/call-binding.js');
define('@aurelia/runtime-html/dist/esm/binding/interpolation-binding.js',['require','exports','module','@aurelia/runtime'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.ContentBinding = exports.InterpolationBinding = void 0;

var _runtime = require("@aurelia/runtime");

const {
  toView
} = _runtime.BindingMode;
const queueTaskOptions = {
  reusable: false,
  preempt: true
}; // a pseudo binding to manage multiple InterpolationBinding s
// ========
// Note: the child expressions of an Interpolation expression are full Aurelia expressions, meaning they may include
// value converters and binding behaviors.
// Each expression represents one ${interpolation}, and for each we create a child TextBinding unless there is only one,
// in which case the renderer will create the TextBinding directly

class InterpolationBinding {
  constructor(observerLocator, interpolation, target, targetProperty, mode, locator, taskQueue) {
    this.observerLocator = observerLocator;
    this.interpolation = interpolation;
    this.target = target;
    this.targetProperty = targetProperty;
    this.mode = mode;
    this.locator = locator;
    this.taskQueue = taskQueue;
    this.interceptor = this;
    this.isBound = false;
    this.$scope = void 0;
    this.$hostScope = null;
    this.task = null;
    this.targetObserver = observerLocator.getAccessor(target, targetProperty);
    const expressions = interpolation.expressions;
    const partBindings = this.partBindings = Array(expressions.length);

    for (let i = 0, ii = expressions.length; i < ii; ++i) {
      partBindings[i] = new ContentBinding(expressions[i], target, targetProperty, locator, observerLocator, this);
    }
  }

  updateTarget(value, flags) {
    const partBindings = this.partBindings;
    const staticParts = this.interpolation.parts;
    const ii = partBindings.length;
    let result = '';

    if (ii === 1) {
      result = staticParts[0] + partBindings[0].value + staticParts[1];
    } else {
      result = staticParts[0];

      for (let i = 0; ii > i; ++i) {
        result += partBindings[i].value + staticParts[i + 1];
      }
    }

    const targetObserver = this.targetObserver; // Alpha: during bind a simple strategy for bind is always flush immediately
    // todo:
    //  (1). determine whether this should be the behavior
    //  (2). if not, then fix tests to reflect the changes/platform to properly yield all with aurelia.start().wait()

    const shouldQueueFlush = (flags & 32
    /* fromBind */
    ) === 0 && (targetObserver.type & 4
    /* Layout */
    ) > 0;

    if (shouldQueueFlush) {
      this.task?.cancel();
      this.task = this.taskQueue.queueTask(() => {
        this.task = null;
        targetObserver.setValue(result, flags, this.target, this.targetProperty);
      }, queueTaskOptions);
    } else {
      targetObserver.setValue(result, flags, this.target, this.targetProperty);
    }
  }

  $bind(flags, scope, hostScope) {
    if (this.isBound) {
      if (this.$scope === scope) {
        return;
      }

      this.interceptor.$unbind(flags);
    }

    this.isBound = true;
    this.$scope = scope;
    const partBindings = this.partBindings;

    for (let i = 0, ii = partBindings.length; ii > i; ++i) {
      partBindings[i].$bind(flags, scope, hostScope);
    }

    this.updateTarget(void 0, flags);
  }

  $unbind(flags) {
    if (!this.isBound) {
      return;
    }

    this.isBound = false;
    this.$scope = void 0;
    const partBindings = this.partBindings;

    for (let i = 0, ii = partBindings.length; i < ii; ++i) {
      partBindings[i].interceptor.$unbind(flags);
    }

    this.task?.cancel();
    this.task = null;
  }

}

exports.InterpolationBinding = InterpolationBinding;

class ContentBinding {
  constructor(sourceExpression, target, targetProperty, locator, observerLocator, owner) {
    this.sourceExpression = sourceExpression;
    this.target = target;
    this.targetProperty = targetProperty;
    this.locator = locator;
    this.observerLocator = observerLocator;
    this.owner = owner;
    this.interceptor = this; // at runtime, mode may be overriden by binding behavior
    // but it wouldn't matter here, just start with something for later check

    this.mode = _runtime.BindingMode.toView;
    this.value = '';
    this.$hostScope = null;
    this.task = null;
    this.isBound = false;
  }

  handleChange(newValue, oldValue, flags) {
    if (!this.isBound) {
      return;
    }

    const sourceExpression = this.sourceExpression;
    const obsRecord = this.obs;
    const canOptimize = sourceExpression.$kind === 10082
    /* AccessScope */
    && obsRecord.count === 1;

    if (!canOptimize) {
      const shouldConnect = (this.mode & toView) > 0;

      if (shouldConnect) {
        obsRecord.version++;
      }

      newValue = sourceExpression.evaluate(flags, this.$scope, this.$hostScope, this.locator, shouldConnect ? this.interceptor : null);

      if (shouldConnect) {
        obsRecord.clear(false);
      }
    }

    if (newValue != this.value) {
      this.value = newValue;

      if (newValue instanceof Array) {
        this.observeCollection(newValue);
      }

      this.owner.updateTarget(newValue, flags);
    }
  }

  handleCollectionChange(indexMap, flags) {
    this.owner.updateTarget(void 0, flags);
  }

  $bind(flags, scope, hostScope) {
    if (this.isBound) {
      if (this.$scope === scope) {
        return;
      }

      this.interceptor.$unbind(flags);
    }

    this.isBound = true;
    this.$scope = scope;
    this.$hostScope = hostScope;

    if (this.sourceExpression.hasBind) {
      this.sourceExpression.bind(flags, scope, hostScope, this.interceptor);
    }

    const v = this.value = this.sourceExpression.evaluate(flags, scope, hostScope, this.locator, (this.mode & toView) > 0 ? this.interceptor : null);

    if (v instanceof Array) {
      this.observeCollection(v);
    }
  }

  $unbind(flags) {
    if (!this.isBound) {
      return;
    }

    this.isBound = false;

    if (this.sourceExpression.hasUnbind) {
      this.sourceExpression.unbind(flags, this.$scope, this.$hostScope, this.interceptor);
    }

    this.$scope = void 0;
    this.$hostScope = null;
    this.obs.clear(true);
  }

}

exports.ContentBinding = ContentBinding;
(0, _runtime.connectable)(ContentBinding);
});

;define.alias('@aurelia/runtime-html/binding/interpolation-binding.js','@aurelia/runtime-html/dist/esm/binding/interpolation-binding.js');
define('@aurelia/runtime-html/dist/esm/binding/let-binding.js',['require','exports','module','@aurelia/runtime'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.LetBinding = void 0;

var _runtime = require("@aurelia/runtime");

class LetBinding {
  constructor(sourceExpression, targetProperty, observerLocator, locator, toBindingContext = false) {
    this.sourceExpression = sourceExpression;
    this.targetProperty = targetProperty;
    this.observerLocator = observerLocator;
    this.locator = locator;
    this.toBindingContext = toBindingContext;
    this.interceptor = this;
    this.isBound = false;
    this.$scope = void 0;
    this.$hostScope = null;
    this.task = null;
    this.target = null;

    _runtime.connectable.assignIdTo(this);
  }

  handleChange(_newValue, _previousValue, flags) {
    if (!this.isBound) {
      return;
    }

    if (flags & 8
    /* updateTarget */
    ) {
        const target = this.target;
        const targetProperty = this.targetProperty;
        const previousValue = target[targetProperty];
        this.obs.version++;
        const newValue = this.sourceExpression.evaluate(flags, this.$scope, this.$hostScope, this.locator, this.interceptor);
        this.obs.clear(false);

        if (newValue !== previousValue) {
          target[targetProperty] = newValue;
        }

        return;
      }

    throw new Error('Unexpected handleChange context in LetBinding');
  }

  $bind(flags, scope, hostScope) {
    if (this.isBound) {
      if (this.$scope === scope) {
        return;
      }

      this.interceptor.$unbind(flags | 32
      /* fromBind */
      );
    }

    this.$scope = scope;
    this.$hostScope = hostScope;
    this.target = this.toBindingContext ? (hostScope ?? scope).bindingContext : (hostScope ?? scope).overrideContext;
    const sourceExpression = this.sourceExpression;

    if (sourceExpression.hasBind) {
      sourceExpression.bind(flags, scope, hostScope, this.interceptor);
    } // sourceExpression might have been changed during bind


    this.target[this.targetProperty] = this.sourceExpression.evaluate(flags | 32
    /* fromBind */
    , scope, hostScope, this.locator, this.interceptor); // add isBound flag and remove isBinding flag

    this.isBound = true;
  }

  $unbind(flags) {
    if (!this.isBound) {
      return;
    }

    const sourceExpression = this.sourceExpression;

    if (sourceExpression.hasUnbind) {
      sourceExpression.unbind(flags, this.$scope, this.$hostScope, this.interceptor);
    }

    this.$scope = void 0;
    this.$hostScope = null;
    this.obs.clear(true); // remove isBound and isUnbinding flags

    this.isBound = false;
  }

}

exports.LetBinding = LetBinding;
(0, _runtime.connectable)(LetBinding);
});

;define.alias('@aurelia/runtime-html/binding/let-binding.js','@aurelia/runtime-html/dist/esm/binding/let-binding.js');
define('@aurelia/runtime-html/dist/esm/binding/listener.js',['require','exports','module','@aurelia/runtime','../dom.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.Listener = void 0;

var _runtime = require("@aurelia/runtime");

var _dom = require("../dom.js");

const options = {
  [_runtime.DelegationStrategy.capturing]: {
    capture: true
  },
  [_runtime.DelegationStrategy.bubbling]: {
    capture: false
  }
};
/**
 * Listener binding. Handle event binding between view and view model
 */

class Listener {
  constructor(platform, targetEvent, delegationStrategy, sourceExpression, target, preventDefault, eventDelegator, locator) {
    this.platform = platform;
    this.targetEvent = targetEvent;
    this.delegationStrategy = delegationStrategy;
    this.sourceExpression = sourceExpression;
    this.target = target;
    this.preventDefault = preventDefault;
    this.eventDelegator = eventDelegator;
    this.locator = locator;
    this.interceptor = this;
    this.isBound = false;
    this.$hostScope = null;
    this.handler = null;
  }

  callSource(event) {
    const overrideContext = this.$scope.overrideContext;
    overrideContext.$event = event;
    const result = this.sourceExpression.evaluate(128
    /* mustEvaluate */
    , this.$scope, this.$hostScope, this.locator, null);
    Reflect.deleteProperty(overrideContext, '$event');

    if (result !== true && this.preventDefault) {
      event.preventDefault();
    }

    return result;
  }

  handleEvent(event) {
    this.interceptor.callSource(event);
  }

  $bind(flags, scope, hostScope) {
    if (this.isBound) {
      if (this.$scope === scope) {
        return;
      }

      this.interceptor.$unbind(flags | 32
      /* fromBind */
      );
    }

    this.$scope = scope;
    this.$hostScope = hostScope;
    const sourceExpression = this.sourceExpression;

    if (sourceExpression.hasBind) {
      sourceExpression.bind(flags, scope, hostScope, this.interceptor);
    }

    if (this.delegationStrategy === _runtime.DelegationStrategy.none) {
      this.target.addEventListener(this.targetEvent, this);
    } else {
      const eventTarget = this.locator.get(_dom.IEventTarget);
      this.handler = this.eventDelegator.addEventListener(eventTarget, this.target, this.targetEvent, this, options[this.delegationStrategy]);
    } // add isBound flag and remove isBinding flag


    this.isBound = true;
  }

  $unbind(flags) {
    if (!this.isBound) {
      return;
    }

    const sourceExpression = this.sourceExpression;

    if (sourceExpression.hasUnbind) {
      sourceExpression.unbind(flags, this.$scope, this.$hostScope, this.interceptor);
    }

    this.$scope = null;

    if (this.delegationStrategy === _runtime.DelegationStrategy.none) {
      this.target.removeEventListener(this.targetEvent, this);
    } else {
      this.handler.dispose();
      this.handler = null;
    } // remove isBound and isUnbinding flags


    this.isBound = false;
  }

  observeProperty(obj, propertyName) {
    return;
  }

  handleChange(newValue, previousValue, flags) {
    return;
  }

}

exports.Listener = Listener;
});

;define.alias('@aurelia/runtime-html/binding/listener.js','@aurelia/runtime-html/dist/esm/binding/listener.js');
define('@aurelia/runtime-html/dist/esm/binding/property-binding.js',['require','exports','module','@aurelia/runtime'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.PropertyBinding = void 0;

var _runtime = require("@aurelia/runtime");

// BindingMode is not a const enum (and therefore not inlined), so assigning them to a variable to save a member accessor is a minor perf tweak
const {
  oneTime,
  toView,
  fromView
} = _runtime.BindingMode; // pre-combining flags for bitwise checks is a minor perf tweak

const toViewOrOneTime = toView | oneTime;
const updateTaskOpts = {
  reusable: false,
  preempt: true
};

class PropertyBinding {
  constructor(sourceExpression, target, targetProperty, mode, observerLocator, locator, taskQueue) {
    this.sourceExpression = sourceExpression;
    this.target = target;
    this.targetProperty = targetProperty;
    this.mode = mode;
    this.observerLocator = observerLocator;
    this.locator = locator;
    this.taskQueue = taskQueue;
    this.interceptor = this;
    this.isBound = false;
    this.$scope = void 0;
    this.$hostScope = null;
    this.targetObserver = void 0;
    this.persistentFlags = 0
    /* none */
    ;
    this.task = null;

    _runtime.connectable.assignIdTo(this);
  }

  updateTarget(value, flags) {
    flags |= this.persistentFlags;
    this.targetObserver.setValue(value, flags, this.target, this.targetProperty);
  }

  updateSource(value, flags) {
    flags |= this.persistentFlags;
    this.sourceExpression.assign(flags, this.$scope, this.$hostScope, this.locator, value);
  }

  handleChange(newValue, _previousValue, flags) {
    if (!this.isBound) {
      return;
    }

    flags |= this.persistentFlags;
    const targetObserver = this.targetObserver;
    const interceptor = this.interceptor;
    const sourceExpression = this.sourceExpression;
    const $scope = this.$scope;
    const locator = this.locator;

    if ((flags & 8
    /* updateTarget */
    ) > 0) {
      // Alpha: during bind a simple strategy for bind is always flush immediately
      // todo:
      //  (1). determine whether this should be the behavior
      //  (2). if not, then fix tests to reflect the changes/platform to properly yield all with aurelia.start()
      const shouldQueueFlush = (flags & 32
      /* fromBind */
      ) === 0 && (targetObserver.type & 4
      /* Layout */
      ) > 0;
      const obsRecord = this.obs; // if the only observable is an AccessScope then we can assume the passed-in newValue is the correct and latest value

      if (sourceExpression.$kind !== 10082
      /* AccessScope */
      || obsRecord.count > 1) {
        // todo: in VC expressions, from view also requires connect
        const shouldConnect = this.mode > oneTime;

        if (shouldConnect) {
          obsRecord.version++;
        }

        newValue = sourceExpression.evaluate(flags, $scope, this.$hostScope, locator, interceptor);

        if (shouldConnect) {
          obsRecord.clear(false);
        }
      }

      if (shouldQueueFlush) {
        this.task?.cancel();
        this.task = this.taskQueue.queueTask(() => {
          interceptor.updateTarget(newValue, flags);
          this.task = null;
        }, updateTaskOpts);
      } else {
        interceptor.updateTarget(newValue, flags);
      }

      return;
    }

    if ((flags & 16
    /* updateSource */
    ) > 0) {
      if (newValue !== sourceExpression.evaluate(flags, $scope, this.$hostScope, locator, null)) {
        interceptor.updateSource(newValue, flags);
      }

      return;
    }

    throw new Error('Unexpected handleChange context in PropertyBinding');
  }

  $bind(flags, scope, hostScope) {
    if (this.isBound) {
      if (this.$scope === scope) {
        return;
      }

      this.interceptor.$unbind(flags | 32
      /* fromBind */
      );
    } // Force property binding to always be strict


    flags |= 4
    /* isStrictBindingStrategy */
    ; // Store flags which we can only receive during $bind and need to pass on
    // to the AST during evaluate/connect/assign

    this.persistentFlags = flags & 15367
    /* persistentBindingFlags */
    ;
    this.$scope = scope;
    this.$hostScope = hostScope;
    let sourceExpression = this.sourceExpression;

    if (sourceExpression.hasBind) {
      sourceExpression.bind(flags, scope, hostScope, this.interceptor);
    }

    const $mode = this.mode;
    let targetObserver = this.targetObserver;

    if (!targetObserver) {
      const observerLocator = this.observerLocator;

      if ($mode & fromView) {
        targetObserver = observerLocator.getObserver(this.target, this.targetProperty);
      } else {
        targetObserver = observerLocator.getAccessor(this.target, this.targetProperty);
      }

      this.targetObserver = targetObserver;
    } // during bind, binding behavior might have changed sourceExpression
    // deepscan-disable-next-line


    sourceExpression = this.sourceExpression;
    const interceptor = this.interceptor;
    const shouldConnect = ($mode & toView) > 0;

    if ($mode & toViewOrOneTime) {
      interceptor.updateTarget(sourceExpression.evaluate(flags, scope, this.$hostScope, this.locator, shouldConnect ? interceptor : null), flags);
    }

    if ($mode & fromView) {
      targetObserver.subscribe(interceptor);

      if (!shouldConnect) {
        interceptor.updateSource(targetObserver.getValue(this.target, this.targetProperty), flags);
      }

      targetObserver[this.id] |= 16
      /* updateSource */
      ;
    }

    this.isBound = true;
  }

  $unbind(flags) {
    if (!this.isBound) {
      return;
    }

    this.persistentFlags = 0
    /* none */
    ;

    if (this.sourceExpression.hasUnbind) {
      this.sourceExpression.unbind(flags, this.$scope, this.$hostScope, this.interceptor);
    }

    this.$scope = void 0;
    this.$hostScope = null;
    const targetObserver = this.targetObserver;
    const task = this.task;

    if (targetObserver.unsubscribe) {
      targetObserver.unsubscribe(this.interceptor);
      targetObserver[this.id] &= ~16
      /* updateSource */
      ;
    }

    if (task != null) {
      task.cancel();
      this.task = null;
    }

    this.obs.clear(true);
    this.isBound = false;
  }

}

exports.PropertyBinding = PropertyBinding;
(0, _runtime.connectable)(PropertyBinding);
});

;define.alias('@aurelia/runtime-html/binding/property-binding.js','@aurelia/runtime-html/dist/esm/binding/property-binding.js');
define('@aurelia/runtime-html/dist/esm/binding/ref-binding.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.RefBinding = void 0;

class RefBinding {
  constructor(sourceExpression, target, locator) {
    this.sourceExpression = sourceExpression;
    this.target = target;
    this.locator = locator;
    this.interceptor = this;
    this.isBound = false;
    this.$scope = void 0;
    this.$hostScope = null;
  }

  $bind(flags, scope, hostScope) {
    if (this.isBound) {
      if (this.$scope === scope) {
        return;
      }

      this.interceptor.$unbind(flags | 32
      /* fromBind */
      );
    }

    this.$scope = scope;
    this.$hostScope = hostScope;

    if (this.sourceExpression.hasBind) {
      this.sourceExpression.bind(flags, scope, hostScope, this);
    }

    this.sourceExpression.assign(flags | 16
    /* updateSource */
    , this.$scope, hostScope, this.locator, this.target); // add isBound flag and remove isBinding flag

    this.isBound = true;
  }

  $unbind(flags) {
    if (!this.isBound) {
      return;
    }

    let sourceExpression = this.sourceExpression;

    if (sourceExpression.evaluate(flags, this.$scope, this.$hostScope, this.locator, null) === this.target) {
      sourceExpression.assign(flags, this.$scope, this.$hostScope, this.locator, null);
    } // source expression might have been modified durring assign, via a BB
    // deepscan-disable-next-line


    sourceExpression = this.sourceExpression;

    if (sourceExpression.hasUnbind) {
      sourceExpression.unbind(flags, this.$scope, this.$hostScope, this.interceptor);
    }

    this.$scope = void 0;
    this.$hostScope = null;
    this.isBound = false;
  }

  observeProperty(obj, propertyName) {
    return;
  }

  handleChange(newValue, previousValue, flags) {
    return;
  }

}

exports.RefBinding = RefBinding;
});

;define.alias('@aurelia/runtime-html/binding/ref-binding.js','@aurelia/runtime-html/dist/esm/binding/ref-binding.js');
define('@aurelia/runtime-html/dist/esm/configuration.js',['require','exports','module','@aurelia/kernel','./resources/attribute-pattern.js','./resources/binding-command.js','./template-compiler.js','./renderer.js','./binding-behaviors/binding-mode.js','./binding-behaviors/debounce.js','./binding-behaviors/signals.js','./binding-behaviors/throttle.js','./observation/svg-analyzer.js','./resources/binding-behaviors/attr.js','./resources/binding-behaviors/self.js','./resources/binding-behaviors/update-trigger.js','./resources/custom-attributes/blur.js','./resources/custom-attributes/focus.js','./resources/custom-attributes/show.js','./resources/template-controllers/portal.js','./resources/template-controllers/flags.js','./resources/template-controllers/if.js','./resources/template-controllers/repeat.js','./resources/template-controllers/with.js','./resources/template-controllers/switch.js','./resources/custom-elements/compose.js','./resources/custom-elements/au-slot.js','./resources/value-converters/sanitize.js','./resources/value-converters/view.js','./observation/observer-locator.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.StandardConfiguration = exports.DefaultRenderers = exports.TextBindingRendererRegistration = exports.StylePropertyBindingRendererRegistration = exports.SetStyleAttributeRendererRegistration = exports.SetClassAttributeRendererRegistration = exports.SetAttributeRendererRegistration = exports.AttributeBindingRendererRegistration = exports.ListenerBindingRendererRegistration = exports.TemplateControllerRendererRegistration = exports.SetPropertyRendererRegistration = exports.RefBindingRendererRegistration = exports.PropertyBindingRendererRegistration = exports.LetElementRendererRegistration = exports.IteratorBindingRendererRegistration = exports.InterpolationBindingRendererRegistration = exports.CustomElementRendererRegistration = exports.CustomAttributeRendererRegistration = exports.CallBindingRendererRegistration = exports.DefaultResources = exports.ShowRegistration = exports.BlurRegistration = exports.FocusRegistration = exports.PortalRegistration = exports.ComposeRegistration = exports.UpdateTriggerBindingBehaviorRegistration = exports.SelfBindingBehaviorRegistration = exports.AttrBindingBehaviorRegistration = exports.DefaultCaseRegistration = exports.CaseRegistration = exports.SwitchRegistration = exports.WithRegistration = exports.RepeatRegistration = exports.ElseRegistration = exports.IfRegistration = exports.ObserveShallowRegistration = exports.FrequentMutationsRegistration = exports.ViewValueConverterRegistration = exports.SanitizeValueConverterRegistration = exports.DefaultBindingLanguage = exports.StyleBindingCommandRegistration = exports.ClassBindingCommandRegistration = exports.AttrBindingCommandRegistration = exports.CaptureBindingCommandRegistration = exports.DelegateBindingCommandRegistration = exports.TriggerBindingCommandRegistration = exports.RefBindingCommandRegistration = exports.TwoWayBindingCommandRegistration = exports.ToViewBindingCommandRegistration = exports.OneTimeBindingCommandRegistration = exports.FromViewBindingCommandRegistration = exports.ForBindingCommandRegistration = exports.DefaultBindingCommandRegistration = exports.CallBindingCommandRegistration = exports.ShortHandBindingSyntax = exports.DefaultBindingSyntax = exports.DotSeparatedAttributePatternRegistration = exports.RefAttributePatternRegistration = exports.ColonPrefixedBindAttributePatternRegistration = exports.AtPrefixedTriggerAttributePatternRegistration = exports.SVGAnalyzerRegistration = exports.DefaultComponents = exports.INodeObserverLocatorRegistration = exports.ITemplateCompilerRegistration = exports.TwoWayBindingBehaviorRegistration = exports.ThrottleBindingBehaviorRegistration = exports.SignalBindingBehaviorRegistration = exports.FromViewBindingBehaviorRegistration = exports.ToViewBindingBehaviorRegistration = exports.OneTimeBindingBehaviorRegistration = exports.DebounceBindingBehaviorRegistration = void 0;

var _kernel = require("@aurelia/kernel");

var _attributePattern = require("./resources/attribute-pattern.js");

var _bindingCommand = require("./resources/binding-command.js");

var _templateCompiler = require("./template-compiler.js");

var _renderer = require("./renderer.js");

var _bindingMode = require("./binding-behaviors/binding-mode.js");

var _debounce = require("./binding-behaviors/debounce.js");

var _signals = require("./binding-behaviors/signals.js");

var _throttle = require("./binding-behaviors/throttle.js");

var _svgAnalyzer = require("./observation/svg-analyzer.js");

var _attr = require("./resources/binding-behaviors/attr.js");

var _self = require("./resources/binding-behaviors/self.js");

var _updateTrigger = require("./resources/binding-behaviors/update-trigger.js");

var _blur = require("./resources/custom-attributes/blur.js");

var _focus = require("./resources/custom-attributes/focus.js");

var _show = require("./resources/custom-attributes/show.js");

var _portal = require("./resources/template-controllers/portal.js");

var _flags = require("./resources/template-controllers/flags.js");

var _if = require("./resources/template-controllers/if.js");

var _repeat = require("./resources/template-controllers/repeat.js");

var _with = require("./resources/template-controllers/with.js");

var _switch = require("./resources/template-controllers/switch.js");

var _compose = require("./resources/custom-elements/compose.js");

var _auSlot = require("./resources/custom-elements/au-slot.js");

var _sanitize = require("./resources/value-converters/sanitize.js");

var _view = require("./resources/value-converters/view.js");

var _observerLocator = require("./observation/observer-locator.js");

const DebounceBindingBehaviorRegistration = _debounce.DebounceBindingBehavior;
exports.DebounceBindingBehaviorRegistration = DebounceBindingBehaviorRegistration;
const OneTimeBindingBehaviorRegistration = _bindingMode.OneTimeBindingBehavior;
exports.OneTimeBindingBehaviorRegistration = OneTimeBindingBehaviorRegistration;
const ToViewBindingBehaviorRegistration = _bindingMode.ToViewBindingBehavior;
exports.ToViewBindingBehaviorRegistration = ToViewBindingBehaviorRegistration;
const FromViewBindingBehaviorRegistration = _bindingMode.FromViewBindingBehavior;
exports.FromViewBindingBehaviorRegistration = FromViewBindingBehaviorRegistration;
const SignalBindingBehaviorRegistration = _signals.SignalBindingBehavior;
exports.SignalBindingBehaviorRegistration = SignalBindingBehaviorRegistration;
const ThrottleBindingBehaviorRegistration = _throttle.ThrottleBindingBehavior;
exports.ThrottleBindingBehaviorRegistration = ThrottleBindingBehaviorRegistration;
const TwoWayBindingBehaviorRegistration = _bindingMode.TwoWayBindingBehavior;
exports.TwoWayBindingBehaviorRegistration = TwoWayBindingBehaviorRegistration;
const ITemplateCompilerRegistration = _templateCompiler.TemplateCompiler;
exports.ITemplateCompilerRegistration = ITemplateCompilerRegistration;
const INodeObserverLocatorRegistration = _observerLocator.NodeObserverLocator;
/**
 * Default HTML-specific (but environment-agnostic) implementations for the following interfaces:
 * - `ITemplateCompiler`
 * - `ITargetAccessorLocator`
 * - `ITargetObserverLocator`
 */

exports.INodeObserverLocatorRegistration = INodeObserverLocatorRegistration;
const DefaultComponents = [ITemplateCompilerRegistration, INodeObserverLocatorRegistration];
exports.DefaultComponents = DefaultComponents;
const SVGAnalyzerRegistration = _svgAnalyzer.SVGAnalyzer;
exports.SVGAnalyzerRegistration = SVGAnalyzerRegistration;
const AtPrefixedTriggerAttributePatternRegistration = _attributePattern.AtPrefixedTriggerAttributePattern;
exports.AtPrefixedTriggerAttributePatternRegistration = AtPrefixedTriggerAttributePatternRegistration;
const ColonPrefixedBindAttributePatternRegistration = _attributePattern.ColonPrefixedBindAttributePattern;
exports.ColonPrefixedBindAttributePatternRegistration = ColonPrefixedBindAttributePatternRegistration;
const RefAttributePatternRegistration = _attributePattern.RefAttributePattern;
exports.RefAttributePatternRegistration = RefAttributePatternRegistration;
const DotSeparatedAttributePatternRegistration = _attributePattern.DotSeparatedAttributePattern;
/**
 * Default binding syntax for the following attribute name patterns:
 * - `ref`
 * - `target.command` (dot-separated)
 */

exports.DotSeparatedAttributePatternRegistration = DotSeparatedAttributePatternRegistration;
const DefaultBindingSyntax = [RefAttributePatternRegistration, DotSeparatedAttributePatternRegistration];
/**
 * Binding syntax for short-hand attribute name patterns:
 * - `@target` (short-hand for `target.trigger`)
 * - `:target` (short-hand for `target.bind`)
 */

exports.DefaultBindingSyntax = DefaultBindingSyntax;
const ShortHandBindingSyntax = [AtPrefixedTriggerAttributePatternRegistration, ColonPrefixedBindAttributePatternRegistration];
exports.ShortHandBindingSyntax = ShortHandBindingSyntax;
const CallBindingCommandRegistration = _bindingCommand.CallBindingCommand;
exports.CallBindingCommandRegistration = CallBindingCommandRegistration;
const DefaultBindingCommandRegistration = _bindingCommand.DefaultBindingCommand;
exports.DefaultBindingCommandRegistration = DefaultBindingCommandRegistration;
const ForBindingCommandRegistration = _bindingCommand.ForBindingCommand;
exports.ForBindingCommandRegistration = ForBindingCommandRegistration;
const FromViewBindingCommandRegistration = _bindingCommand.FromViewBindingCommand;
exports.FromViewBindingCommandRegistration = FromViewBindingCommandRegistration;
const OneTimeBindingCommandRegistration = _bindingCommand.OneTimeBindingCommand;
exports.OneTimeBindingCommandRegistration = OneTimeBindingCommandRegistration;
const ToViewBindingCommandRegistration = _bindingCommand.ToViewBindingCommand;
exports.ToViewBindingCommandRegistration = ToViewBindingCommandRegistration;
const TwoWayBindingCommandRegistration = _bindingCommand.TwoWayBindingCommand;
exports.TwoWayBindingCommandRegistration = TwoWayBindingCommandRegistration;
const RefBindingCommandRegistration = _bindingCommand.RefBindingCommand;
exports.RefBindingCommandRegistration = RefBindingCommandRegistration;
const TriggerBindingCommandRegistration = _bindingCommand.TriggerBindingCommand;
exports.TriggerBindingCommandRegistration = TriggerBindingCommandRegistration;
const DelegateBindingCommandRegistration = _bindingCommand.DelegateBindingCommand;
exports.DelegateBindingCommandRegistration = DelegateBindingCommandRegistration;
const CaptureBindingCommandRegistration = _bindingCommand.CaptureBindingCommand;
exports.CaptureBindingCommandRegistration = CaptureBindingCommandRegistration;
const AttrBindingCommandRegistration = _bindingCommand.AttrBindingCommand;
exports.AttrBindingCommandRegistration = AttrBindingCommandRegistration;
const ClassBindingCommandRegistration = _bindingCommand.ClassBindingCommand;
exports.ClassBindingCommandRegistration = ClassBindingCommandRegistration;
const StyleBindingCommandRegistration = _bindingCommand.StyleBindingCommand;
/**
 * Default HTML-specific (but environment-agnostic) binding commands:
 * - Property observation: `.bind`, `.one-time`, `.from-view`, `.to-view`, `.two-way`
 * - Function call: `.call`
 * - Collection observation: `.for`
 * - Event listeners: `.trigger`, `.delegate`, `.capture`
 */

exports.StyleBindingCommandRegistration = StyleBindingCommandRegistration;
const DefaultBindingLanguage = [DefaultBindingCommandRegistration, OneTimeBindingCommandRegistration, FromViewBindingCommandRegistration, ToViewBindingCommandRegistration, TwoWayBindingCommandRegistration, CallBindingCommandRegistration, ForBindingCommandRegistration, RefBindingCommandRegistration, TriggerBindingCommandRegistration, DelegateBindingCommandRegistration, CaptureBindingCommandRegistration, ClassBindingCommandRegistration, StyleBindingCommandRegistration, AttrBindingCommandRegistration];
exports.DefaultBindingLanguage = DefaultBindingLanguage;
const SanitizeValueConverterRegistration = _sanitize.SanitizeValueConverter;
exports.SanitizeValueConverterRegistration = SanitizeValueConverterRegistration;
const ViewValueConverterRegistration = _view.ViewValueConverter;
exports.ViewValueConverterRegistration = ViewValueConverterRegistration;
const FrequentMutationsRegistration = _flags.FrequentMutations;
exports.FrequentMutationsRegistration = FrequentMutationsRegistration;
const ObserveShallowRegistration = _flags.ObserveShallow;
exports.ObserveShallowRegistration = ObserveShallowRegistration;
const IfRegistration = _if.If;
exports.IfRegistration = IfRegistration;
const ElseRegistration = _if.Else;
exports.ElseRegistration = ElseRegistration;
const RepeatRegistration = _repeat.Repeat;
exports.RepeatRegistration = RepeatRegistration;
const WithRegistration = _with.With;
exports.WithRegistration = WithRegistration;
const SwitchRegistration = _switch.Switch;
exports.SwitchRegistration = SwitchRegistration;
const CaseRegistration = _switch.Case;
exports.CaseRegistration = CaseRegistration;
const DefaultCaseRegistration = _switch.DefaultCase;
exports.DefaultCaseRegistration = DefaultCaseRegistration;
const AttrBindingBehaviorRegistration = _attr.AttrBindingBehavior;
exports.AttrBindingBehaviorRegistration = AttrBindingBehaviorRegistration;
const SelfBindingBehaviorRegistration = _self.SelfBindingBehavior;
exports.SelfBindingBehaviorRegistration = SelfBindingBehaviorRegistration;
const UpdateTriggerBindingBehaviorRegistration = _updateTrigger.UpdateTriggerBindingBehavior;
exports.UpdateTriggerBindingBehaviorRegistration = UpdateTriggerBindingBehaviorRegistration;
const ComposeRegistration = _compose.Compose;
exports.ComposeRegistration = ComposeRegistration;
const PortalRegistration = _portal.Portal;
exports.PortalRegistration = PortalRegistration;
const FocusRegistration = _focus.Focus;
exports.FocusRegistration = FocusRegistration;
const BlurRegistration = _blur.Blur;
exports.BlurRegistration = BlurRegistration;
const ShowRegistration = _show.Show;
/**
 * Default HTML-specific (but environment-agnostic) resources:
 * - Binding Behaviors: `oneTime`, `toView`, `fromView`, `twoWay`, `signal`, `debounce`, `throttle`, `attr`, `self`, `updateTrigger`
 * - Custom Elements: `au-compose`, `au-slot`
 * - Custom Attributes: `blur`, `focus`, `portal`
 * - Template controllers: `if`/`else`, `repeat`, `with`
 * - Value Converters: `sanitize`
 */

exports.ShowRegistration = ShowRegistration;
const DefaultResources = [DebounceBindingBehaviorRegistration, OneTimeBindingBehaviorRegistration, ToViewBindingBehaviorRegistration, FromViewBindingBehaviorRegistration, SignalBindingBehaviorRegistration, ThrottleBindingBehaviorRegistration, TwoWayBindingBehaviorRegistration, SanitizeValueConverterRegistration, ViewValueConverterRegistration, FrequentMutationsRegistration, ObserveShallowRegistration, IfRegistration, ElseRegistration, RepeatRegistration, WithRegistration, SwitchRegistration, CaseRegistration, DefaultCaseRegistration, AttrBindingBehaviorRegistration, SelfBindingBehaviorRegistration, UpdateTriggerBindingBehaviorRegistration, ComposeRegistration, PortalRegistration, FocusRegistration, BlurRegistration, ShowRegistration, _auSlot.AuSlot];
exports.DefaultResources = DefaultResources;
const CallBindingRendererRegistration = _renderer.CallBindingRenderer;
exports.CallBindingRendererRegistration = CallBindingRendererRegistration;
const CustomAttributeRendererRegistration = _renderer.CustomAttributeRenderer;
exports.CustomAttributeRendererRegistration = CustomAttributeRendererRegistration;
const CustomElementRendererRegistration = _renderer.CustomElementRenderer;
exports.CustomElementRendererRegistration = CustomElementRendererRegistration;
const InterpolationBindingRendererRegistration = _renderer.InterpolationBindingRenderer;
exports.InterpolationBindingRendererRegistration = InterpolationBindingRendererRegistration;
const IteratorBindingRendererRegistration = _renderer.IteratorBindingRenderer;
exports.IteratorBindingRendererRegistration = IteratorBindingRendererRegistration;
const LetElementRendererRegistration = _renderer.LetElementRenderer;
exports.LetElementRendererRegistration = LetElementRendererRegistration;
const PropertyBindingRendererRegistration = _renderer.PropertyBindingRenderer;
exports.PropertyBindingRendererRegistration = PropertyBindingRendererRegistration;
const RefBindingRendererRegistration = _renderer.RefBindingRenderer;
exports.RefBindingRendererRegistration = RefBindingRendererRegistration;
const SetPropertyRendererRegistration = _renderer.SetPropertyRenderer;
exports.SetPropertyRendererRegistration = SetPropertyRendererRegistration;
const TemplateControllerRendererRegistration = _renderer.TemplateControllerRenderer;
exports.TemplateControllerRendererRegistration = TemplateControllerRendererRegistration;
const ListenerBindingRendererRegistration = _renderer.ListenerBindingRenderer;
exports.ListenerBindingRendererRegistration = ListenerBindingRendererRegistration;
const AttributeBindingRendererRegistration = _renderer.AttributeBindingRenderer;
exports.AttributeBindingRendererRegistration = AttributeBindingRendererRegistration;
const SetAttributeRendererRegistration = _renderer.SetAttributeRenderer;
exports.SetAttributeRendererRegistration = SetAttributeRendererRegistration;
const SetClassAttributeRendererRegistration = _renderer.SetClassAttributeRenderer;
exports.SetClassAttributeRendererRegistration = SetClassAttributeRendererRegistration;
const SetStyleAttributeRendererRegistration = _renderer.SetStyleAttributeRenderer;
exports.SetStyleAttributeRendererRegistration = SetStyleAttributeRendererRegistration;
const StylePropertyBindingRendererRegistration = _renderer.StylePropertyBindingRenderer;
exports.StylePropertyBindingRendererRegistration = StylePropertyBindingRendererRegistration;
const TextBindingRendererRegistration = _renderer.TextBindingRenderer;
/**
 * Default renderers for:
 * - PropertyBinding: `bind`, `one-time`, `to-view`, `from-view`, `two-way`
 * - IteratorBinding: `for`
 * - CallBinding: `call`
 * - RefBinding: `ref`
 * - InterpolationBinding: `${}`
 * - SetProperty
 * - `customElement` hydration
 * - `customAttribute` hydration
 * - `templateController` hydration
 * - `let` element hydration
 * - Listener Bindings: `trigger`, `capture`, `delegate`
 * - SetAttribute
 * - StyleProperty: `style`, `css`
 * - TextBinding: `${}`
 */

exports.TextBindingRendererRegistration = TextBindingRendererRegistration;
const DefaultRenderers = [PropertyBindingRendererRegistration, IteratorBindingRendererRegistration, CallBindingRendererRegistration, RefBindingRendererRegistration, InterpolationBindingRendererRegistration, SetPropertyRendererRegistration, CustomElementRendererRegistration, CustomAttributeRendererRegistration, TemplateControllerRendererRegistration, LetElementRendererRegistration, ListenerBindingRendererRegistration, AttributeBindingRendererRegistration, SetAttributeRendererRegistration, SetClassAttributeRendererRegistration, SetStyleAttributeRendererRegistration, StylePropertyBindingRendererRegistration, TextBindingRendererRegistration];
/**
 * A DI configuration object containing html-specific (but environment-agnostic) registrations:
 * - `RuntimeConfiguration` from `@aurelia/runtime`
 * - `DefaultComponents`
 * - `DefaultResources`
 * - `DefaultRenderers`
 */

exports.DefaultRenderers = DefaultRenderers;
const StandardConfiguration = {
  /**
   * Apply this configuration to the provided container.
   */
  register(container) {
    return container.register(...DefaultComponents, ...DefaultResources, ...DefaultBindingSyntax, ...DefaultBindingLanguage, ...DefaultRenderers);
  },

  /**
   * Create a new container with this configuration applied to it.
   */
  createContainer() {
    return this.register(_kernel.DI.createContainer());
  }

};
exports.StandardConfiguration = StandardConfiguration;
});

;define.alias('@aurelia/runtime-html/configuration.js','@aurelia/runtime-html/dist/esm/configuration.js');
define('@aurelia/runtime-html/dist/esm/create-element.js',['require','exports','module','./renderer.js','./resources/custom-element.js','./templating/render-context.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.createElement = createElement;
exports.RenderPlan = void 0;

var _renderer = require("./renderer.js");

var _customElement = require("./resources/custom-element.js");

var _renderContext = require("./templating/render-context.js");

function createElement(p, tagOrType, props, children) {
  if (typeof tagOrType === 'string') {
    return createElementForTag(p, tagOrType, props, children);
  } else if (_customElement.CustomElement.isType(tagOrType)) {
    return createElementForType(p, tagOrType, props, children);
  } else {
    throw new Error(`Invalid tagOrType.`);
  }
}
/**
 * RenderPlan. Todo: describe goal of this class
 */


class RenderPlan {
  constructor(node, instructions, dependencies) {
    this.node = node;
    this.instructions = instructions;
    this.dependencies = dependencies;
    this.lazyDefinition = void 0;
  }

  get definition() {
    if (this.lazyDefinition === void 0) {
      this.lazyDefinition = _customElement.CustomElementDefinition.create({
        name: _customElement.CustomElement.generateName(),
        template: this.node,
        needsCompile: typeof this.node === 'string',
        instructions: this.instructions,
        dependencies: this.dependencies
      });
    }

    return this.lazyDefinition;
  }

  getContext(parentContainer) {
    return (0, _renderContext.getRenderContext)(this.definition, parentContainer);
  }

  createView(parentContainer) {
    return this.getViewFactory(parentContainer).create();
  }

  getViewFactory(parentContainer) {
    return this.getContext(parentContainer).getViewFactory();
  }
  /** @internal */


  mergeInto(parent, instructions, dependencies) {
    parent.appendChild(this.node);
    instructions.push(...this.instructions);
    dependencies.push(...this.dependencies);
  }

}

exports.RenderPlan = RenderPlan;

function createElementForTag(p, tagName, props, children) {
  const instructions = [];
  const allInstructions = [];
  const dependencies = [];
  const element = p.document.createElement(tagName);
  let hasInstructions = false;

  if (props) {
    Object.keys(props).forEach(to => {
      const value = props[to];

      if ((0, _renderer.isInstruction)(value)) {
        hasInstructions = true;
        instructions.push(value);
      } else {
        element.setAttribute(to, value);
      }
    });
  }

  if (hasInstructions) {
    element.className = 'au';
    allInstructions.push(instructions);
  }

  if (children) {
    addChildren(p, element, children, allInstructions, dependencies);
  }

  return new RenderPlan(element, allInstructions, dependencies);
}

function createElementForType(p, Type, props, children) {
  const definition = _customElement.CustomElement.getDefinition(Type);

  const tagName = definition.name;
  const instructions = [];
  const allInstructions = [instructions];
  const dependencies = [];
  const childInstructions = [];
  const bindables = definition.bindables;
  const element = p.document.createElement(tagName);
  element.className = 'au';

  if (!dependencies.includes(Type)) {
    dependencies.push(Type);
  }

  instructions.push(new _renderer.HydrateElementInstruction(tagName, void 0, childInstructions, null));

  if (props) {
    Object.keys(props).forEach(to => {
      const value = props[to];

      if ((0, _renderer.isInstruction)(value)) {
        childInstructions.push(value);
      } else {
        const bindable = bindables[to];

        if (bindable !== void 0) {
          childInstructions.push({
            type: "re"
            /* setProperty */
            ,
            to,
            value
          });
        } else {
          childInstructions.push(new _renderer.SetAttributeInstruction(value, to));
        }
      }
    });
  }

  if (children) {
    addChildren(p, element, children, allInstructions, dependencies);
  }

  return new RenderPlan(element, allInstructions, dependencies);
}

function addChildren(p, parent, children, allInstructions, dependencies) {
  for (let i = 0, ii = children.length; i < ii; ++i) {
    const current = children[i];

    switch (typeof current) {
      case 'string':
        parent.appendChild(p.document.createTextNode(current));
        break;

      case 'object':
        if (current instanceof p.Node) {
          parent.appendChild(current);
        } else if ('mergeInto' in current) {
          current.mergeInto(parent, allInstructions, dependencies);
        }

    }
  }
}
});

;define.alias('@aurelia/runtime-html/create-element.js','@aurelia/runtime-html/dist/esm/create-element.js');
define('@aurelia/runtime-html/dist/esm/dom.js',['require','exports','module','@aurelia/kernel','./app-root.js','./platform.js','./resources/custom-element.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.getEffectiveParentNode = getEffectiveParentNode;
exports.setEffectiveParentNode = setEffectiveParentNode;
exports.convertToRenderLocation = convertToRenderLocation;
exports.isRenderLocation = isRenderLocation;
exports.IHistory = exports.ILocation = exports.IWindow = exports.FragmentNodeSequence = exports.NodeType = exports.IRenderLocation = exports.IEventTarget = exports.INode = void 0;

var _kernel = require("@aurelia/kernel");

var _appRoot = require("./app-root.js");

var _platform = require("./platform.js");

var _customElement = require("./resources/custom-element.js");

const INode = _kernel.DI.createInterface('INode');

exports.INode = INode;

const IEventTarget = _kernel.DI.createInterface('IEventTarget', x => x.cachedCallback(handler => {
  if (handler.has(_appRoot.IAppRoot, true)) {
    return handler.get(_appRoot.IAppRoot).host;
  }

  return handler.get(_platform.IPlatform).document;
}));

exports.IEventTarget = IEventTarget;

const IRenderLocation = _kernel.DI.createInterface('IRenderLocation');

exports.IRenderLocation = IRenderLocation;
var NodeType;
exports.NodeType = NodeType;

(function (NodeType) {
  NodeType[NodeType["Element"] = 1] = "Element";
  NodeType[NodeType["Attr"] = 2] = "Attr";
  NodeType[NodeType["Text"] = 3] = "Text";
  NodeType[NodeType["CDATASection"] = 4] = "CDATASection";
  NodeType[NodeType["EntityReference"] = 5] = "EntityReference";
  NodeType[NodeType["Entity"] = 6] = "Entity";
  NodeType[NodeType["ProcessingInstruction"] = 7] = "ProcessingInstruction";
  NodeType[NodeType["Comment"] = 8] = "Comment";
  NodeType[NodeType["Document"] = 9] = "Document";
  NodeType[NodeType["DocumentType"] = 10] = "DocumentType";
  NodeType[NodeType["DocumentFragment"] = 11] = "DocumentFragment";
  NodeType[NodeType["Notation"] = 12] = "Notation";
})(NodeType || (exports.NodeType = NodeType = {}));

const effectiveParentNodeOverrides = new WeakMap();
/**
 * Returns the effective parentNode according to Aurelia's component hierarchy.
 *
 * Used by Aurelia to find the closest parent controller relative to a node.
 *
 * This method supports 3 additional scenarios that `node.parentNode` does not support:
 * - Containerless elements. The parentNode in this case is a comment precending the element under specific conditions, rather than a node wrapping the element.
 * - ShadowDOM. If a `ShadowRoot` is encountered, this method retrieves the associated controller via the metadata api to locate the original host.
 * - Portals. If the provided node was moved to a different location in the DOM by a `portal` attribute, then the original parent of the node will be returned.
 *
 * @param node - The node to get the parent for.
 * @returns Either the closest parent node, the closest `IRenderLocation` (comment node that is the containerless host), original portal host, or `null` if this is either the absolute document root or a disconnected node.
 */

function getEffectiveParentNode(node) {
  // TODO: this method needs more tests!
  // First look for any overrides
  if (effectiveParentNodeOverrides.has(node)) {
    return effectiveParentNodeOverrides.get(node);
  } // Then try to get the nearest au-start render location, which would be the containerless parent,
  // again looking for any overrides along the way.
  // otherwise return the normal parent node


  let containerlessOffset = 0;
  let next = node.nextSibling;

  while (next !== null) {
    if (next.nodeType === 8
    /* Comment */
    ) {
        switch (next.textContent) {
          case 'au-start':
            // If we see an au-start before we see au-end, it will precede the host of a sibling containerless element rather than a parent.
            // So we use the offset to ignore the next au-end
            ++containerlessOffset;
            break;

          case 'au-end':
            if (containerlessOffset-- === 0) {
              return next;
            }

        }
      }

    next = next.nextSibling;
  }

  if (node.parentNode === null && node.nodeType === 11
  /* DocumentFragment */
  ) {
      // Could be a shadow root; see if there's a controller and if so, get the original host via the projector
      const controller = _customElement.CustomElement.for(node);

      if (controller === void 0) {
        // Not a shadow root (or at least, not one created by Aurelia)
        // Nothing more we can try, just return null
        return null;
      }

      if (controller.mountTarget === 2
      /* shadowRoot */
      ) {
          return getEffectiveParentNode(controller.host);
        }
    }

  return node.parentNode;
}

function setEffectiveParentNode(childNodeOrNodeSequence, parentNode) {
  if (childNodeOrNodeSequence.platform !== void 0 && !(childNodeOrNodeSequence instanceof childNodeOrNodeSequence.platform.Node)) {
    const nodes = childNodeOrNodeSequence.childNodes;

    for (let i = 0, ii = nodes.length; i < ii; ++i) {
      effectiveParentNodeOverrides.set(nodes[i], parentNode);
    }
  } else {
    effectiveParentNodeOverrides.set(childNodeOrNodeSequence, parentNode);
  }
}

function convertToRenderLocation(node) {
  if (isRenderLocation(node)) {
    return node; // it's already a IRenderLocation (converted by FragmentNodeSequence)
  }

  const locationEnd = node.ownerDocument.createComment('au-end');
  const locationStart = node.ownerDocument.createComment('au-start');

  if (node.parentNode !== null) {
    node.parentNode.replaceChild(locationEnd, node);
    locationEnd.parentNode.insertBefore(locationStart, locationEnd);
  }

  locationEnd.$start = locationStart;
  return locationEnd;
}

function isRenderLocation(node) {
  return node.textContent === 'au-end';
}

class FragmentNodeSequence {
  constructor(platform, fragment) {
    this.platform = platform;
    this.fragment = fragment;
    this.isMounted = false;
    this.isLinked = false;
    this.next = void 0;
    this.refNode = void 0;
    const targetNodeList = fragment.querySelectorAll('.au');
    let i = 0;
    let ii = targetNodeList.length;
    const targets = this.targets = Array(ii);

    while (i < ii) {
      // eagerly convert all markers to RenderLocations (otherwise the renderer
      // will do it anyway) and store them in the target list (since the comments
      // can't be queried)
      const target = targetNodeList[i];

      if (target.nodeName === 'AU-M') {
        // note the renderer will still call this method, but it will just return the
        // location if it sees it's already a location
        targets[i] = convertToRenderLocation(target);
      } else {
        // also store non-markers for consistent ordering
        targets[i] = target;
      }

      ++i;
    }

    const childNodeList = fragment.childNodes;
    i = 0;
    ii = childNodeList.length;
    const childNodes = this.childNodes = Array(ii);

    while (i < ii) {
      childNodes[i] = childNodeList[i];
      ++i;
    }

    this.firstChild = fragment.firstChild;
    this.lastChild = fragment.lastChild;
  }

  findTargets() {
    return this.targets;
  }

  insertBefore(refNode) {
    if (this.isLinked && !!this.refNode) {
      this.addToLinked();
    } else {
      const parent = refNode.parentNode;

      if (this.isMounted) {
        let current = this.firstChild;
        const end = this.lastChild;
        let next;

        while (current != null) {
          next = current.nextSibling;
          parent.insertBefore(current, refNode);

          if (current === end) {
            break;
          }

          current = next;
        }
      } else {
        this.isMounted = true;
        refNode.parentNode.insertBefore(this.fragment, refNode);
      }
    }
  }

  appendTo(parent, enhance = false) {
    if (this.isMounted) {
      let current = this.firstChild;
      const end = this.lastChild;
      let next;

      while (current != null) {
        next = current.nextSibling;
        parent.appendChild(current);

        if (current === end) {
          break;
        }

        current = next;
      }
    } else {
      this.isMounted = true;

      if (!enhance) {
        parent.appendChild(this.fragment);
      }
    }
  }

  remove() {
    if (this.isMounted) {
      this.isMounted = false;
      const fragment = this.fragment;
      const end = this.lastChild;
      let next;
      let current = this.firstChild;

      while (current !== null) {
        next = current.nextSibling;
        fragment.appendChild(current);

        if (current === end) {
          break;
        }

        current = next;
      }
    }
  }

  addToLinked() {
    const refNode = this.refNode;
    const parent = refNode.parentNode;

    if (this.isMounted) {
      let current = this.firstChild;
      const end = this.lastChild;
      let next;

      while (current != null) {
        next = current.nextSibling;
        parent.insertBefore(current, refNode);

        if (current === end) {
          break;
        }

        current = next;
      }
    } else {
      this.isMounted = true;
      parent.insertBefore(this.fragment, refNode);
    }
  }

  unlink() {
    this.isLinked = false;
    this.next = void 0;
    this.refNode = void 0;
  }

  link(next) {
    this.isLinked = true;

    if (isRenderLocation(next)) {
      this.refNode = next;
    } else {
      this.next = next;
      this.obtainRefNode();
    }
  }

  obtainRefNode() {
    if (this.next !== void 0) {
      this.refNode = this.next.firstChild;
    } else {
      this.refNode = void 0;
    }
  }

}

exports.FragmentNodeSequence = FragmentNodeSequence;

const IWindow = _kernel.DI.createInterface('IWindow', x => x.callback(handler => handler.get(_platform.IPlatform).window));

exports.IWindow = IWindow;

const ILocation = _kernel.DI.createInterface('ILocation', x => x.callback(handler => handler.get(IWindow).location));

exports.ILocation = ILocation;

const IHistory = _kernel.DI.createInterface('IHistory', x => x.callback(handler => handler.get(IWindow).history));

exports.IHistory = IHistory;
});

;define.alias('@aurelia/runtime-html/dom.js','@aurelia/runtime-html/dist/esm/dom.js');
define('@aurelia/runtime-html/dist/esm/index.js',['require','exports','module','@aurelia/platform','@aurelia/platform-browser','./bindable.js','./observation/bindable-observer.js','./configuration.js','./binding-behaviors/binding-mode.js','./binding-behaviors/debounce.js','./binding-behaviors/signals.js','./binding-behaviors/throttle.js','@aurelia/runtime','./aurelia.js','./app-root.js','./app-task.js','./resources/attribute-pattern.js','./resources/binding-command.js','./attribute-syntax-transformer.js','./binding/listener.js','./binding/attribute.js','./binding/call-binding.js','./binding/interpolation-binding.js','./binding/let-binding.js','./binding/property-binding.js','./binding/ref-binding.js','./renderer.js','./observation/attribute-ns-accessor.js','./observation/checked-observer.js','./observation/class-attribute-accessor.js','./observation/data-attribute-accessor.js','./observation/event-delegator.js','./observation/observer-locator.js','./observation/select-value-observer.js','./observation/style-attribute-accessor.js','./observation/svg-analyzer.js','./observation/value-attribute-observer.js','./resources/binding-behaviors/attr.js','./resources/binding-behaviors/self.js','./resources/binding-behaviors/update-trigger.js','./resources/custom-attribute.js','./resources/template-controllers/flags.js','./resources/template-controllers/if.js','./resources/template-controllers/repeat.js','./resources/template-controllers/with.js','./resources/template-controllers/switch.js','./resources/custom-attributes/blur.js','./resources/custom-attributes/focus.js','./resources/template-controllers/portal.js','./resources/custom-elements/au-slot.js','./resources/custom-element.js','./resources/custom-elements/compose.js','./resources/value-converters/sanitize.js','./resources/value-converters/view.js','./template-binder.js','./template-element-factory.js','./templating/children.js','./templating/controller.js','./templating/render-context.js','./templating/view.js','./create-element.js','./dom.js','./platform.js','./semantic-model.js','./templating/styles.js','./watch.js','./templating/watchers.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.BindingBehaviorStrategy = exports.BindingBehaviorFactory = exports.BindingInterceptor = exports.BindingBehaviorDefinition = exports.BindingBehavior = exports.bindingBehavior = exports.subscriberCollection = exports.ISignaler = exports.SetterObserver = exports.PropertyAccessor = exports.PrimitiveObserver = exports.ObserverLocator = exports.getCollectionObserver = exports.INodeObserverLocator = exports.IObserverLocator = exports.observable = exports.ComputedObserver = exports.DirtyCheckSettings = exports.DirtyCheckProperty = exports.IDirtyChecker = exports.CollectionSizeObserver = exports.CollectionLengthObserver = exports.OverrideContext = exports.Scope = exports.BindingContext = exports.disableSetObservation = exports.enableSetObservation = exports.SetObserver = exports.disableMapObservation = exports.enableMapObservation = exports.MapObserver = exports.synchronizeIndices = exports.applyMutationsToIndices = exports.disableArrayObservation = exports.enableArrayObservation = exports.ArrayIndexObserver = exports.ArrayObserver = exports.ParserState = exports.parse = exports.Precedence = exports.Access = exports.Char = exports.parseExpression = exports.BindingType = exports.IExpressionParser = exports.BindingMediator = exports.connectable = exports.Interpolation = exports.ForOfStatement = exports.BindingIdentifier = exports.ObjectBindingPattern = exports.ArrayBindingPattern = exports.TaggedTemplateExpression = exports.TemplateExpression = exports.ObjectLiteralExpression = exports.ArrayLiteralExpression = exports.HtmlLiteralExpression = exports.PrimitiveLiteralExpression = exports.UnaryExpression = exports.BinaryExpression = exports.CallMemberExpression = exports.CallScopeExpression = exports.AccessKeyedExpression = exports.AccessMemberExpression = exports.AccessScopeExpression = exports.AccessThisExpression = exports.ConditionalExpression = exports.AssignExpression = exports.ValueConverterExpression = exports.BindingBehaviorExpression = exports.CustomExpression = exports.CallFunctionExpression = exports.registerAliases = exports.alias = exports.ThrottleBindingBehavior = exports.SignalBindingBehavior = exports.DebounceBindingBehavior = exports.TwoWayBindingBehavior = exports.FromViewBindingBehavior = exports.ToViewBindingBehavior = exports.OneTimeBindingBehavior = exports.BindingModeBehavior = exports.TwoWayBindingBehaviorRegistration = exports.ThrottleBindingBehaviorRegistration = exports.SignalBindingBehaviorRegistration = exports.FromViewBindingBehaviorRegistration = exports.ToViewBindingBehaviorRegistration = exports.OneTimeBindingBehaviorRegistration = exports.DebounceBindingBehaviorRegistration = exports.BindableObserver = exports.BindableDefinition = exports.Bindable = exports.bindable = exports.BrowserPlatform = exports.TaskStatus = exports.TaskQueuePriority = exports.TaskAbortError = exports.Task = exports.TaskQueue = exports.Platform = void 0;
exports.CustomAttributeDefinition = exports.CustomAttribute = exports.customAttribute = exports.UpdateTriggerBindingBehavior = exports.SelfBindingBehavior = exports.AttrBindingBehavior = exports.ValueAttributeObserver = exports.NoopSVGAnalyzer = exports.SVGAnalyzer = exports.ISVGAnalyzer = exports.StyleAttributeAccessor = exports.SelectValueObserver = exports.NodeObserverLocator = exports.NodeObserverConfig = exports.EventDelegator = exports.EventSubscriber = exports.IEventDelegator = exports.DataAttributeAccessor = exports.ClassAttributeAccessor = exports.CheckedObserver = exports.AttributeNSAccessor = exports.InstructionType = exports.IInstruction = exports.isInstruction = exports.TextBindingInstruction = exports.StylePropertyBindingInstruction = exports.SetStyleAttributeInstruction = exports.SetClassAttributeInstruction = exports.SetAttributeInstruction = exports.PropertyBindingInstruction = exports.ListenerBindingInstruction = exports.AttributeBindingInstruction = exports.SetPropertyInstruction = exports.RefBindingInstruction = exports.HydrateLetElementInstruction = exports.LetBindingInstruction = exports.IteratorBindingInstruction = exports.InterpolationInstruction = exports.HydrateTemplateController = exports.HydrateElementInstruction = exports.HydrateAttributeInstruction = exports.CallBindingInstruction = exports.renderer = exports.ITemplateCompiler = exports.IRenderer = exports.RefBinding = exports.PropertyBinding = exports.LetBinding = exports.InterpolationBinding = exports.CallBinding = exports.AttributeBinding = exports.Listener = exports.IAttrSyntaxTransformer = exports.StyleBindingCommand = exports.ClassBindingCommand = exports.AttrBindingCommand = exports.CaptureBindingCommand = exports.DelegateBindingCommand = exports.TriggerBindingCommand = exports.TwoWayBindingCommand = exports.ToViewBindingCommand = exports.OneTimeBindingCommand = exports.FromViewBindingCommand = exports.ForBindingCommand = exports.DefaultBindingCommand = exports.CallBindingCommand = exports.getTarget = exports.BindingCommandDefinition = exports.BindingCommand = exports.bindingCommand = exports.RefAttributePattern = exports.DotSeparatedAttributePattern = exports.ColonPrefixedBindAttributePattern = exports.AtPrefixedTriggerAttributePattern = exports.ISyntaxInterpreter = exports.Interpretation = exports.AttributePattern = exports.IAttributePattern = exports.attributePattern = exports.IAttributeParser = exports.AttrSyntax = exports.IAppTask = exports.AppTask = exports.IAppRoot = exports.AppRoot = exports.IAurelia = exports.Aurelia = exports.createIndexMap = exports.cloneIndexMap = exports.copyIndexMap = exports.isIndexMap = exports.DelegationStrategy = exports.CollectionKind = exports.AccessorType = exports.LifecycleFlags = exports.ExpressionKind = exports.BindingMode = exports.valueConverter = exports.ValueConverterDefinition = exports.ValueConverter = void 0;
exports.IViewFactory = exports.ViewFactory = exports.isRenderContext = exports.getRenderContext = exports.IController = exports.ViewModelKind = exports.isCustomElementViewModel = exports.isCustomElementController = exports.Controller = exports.ChildrenObserver = exports.children = exports.Children = exports.ChildrenDefinition = exports.ITemplateElementFactory = exports.TemplateBinder = exports.StandardConfiguration = exports.DefaultRenderers = exports.TemplateControllerRendererRegistration = exports.SetPropertyRendererRegistration = exports.PropertyBindingRendererRegistration = exports.LetElementRendererRegistration = exports.IteratorBindingRendererRegistration = exports.InterpolationBindingRendererRegistration = exports.CustomElementRendererRegistration = exports.CustomAttributeRendererRegistration = exports.CallBindingRendererRegistration = exports.RefBindingRendererRegistration = exports.TextBindingRendererRegistration = exports.StylePropertyBindingRendererRegistration = exports.SetStyleAttributeRendererRegistration = exports.SetClassAttributeRendererRegistration = exports.SetAttributeRendererRegistration = exports.ListenerBindingRendererRegistration = exports.AttributeBindingRendererRegistration = exports.DefaultResources = exports.ComposeRegistration = exports.UpdateTriggerBindingBehaviorRegistration = exports.SelfBindingBehaviorRegistration = exports.AttrBindingBehaviorRegistration = exports.WithRegistration = exports.RepeatRegistration = exports.ElseRegistration = exports.IfRegistration = exports.SanitizeValueConverterRegistration = exports.ViewValueConverterRegistration = exports.DefaultBindingLanguage = exports.StyleBindingCommandRegistration = exports.ClassBindingCommandRegistration = exports.AttrBindingCommandRegistration = exports.CaptureBindingCommandRegistration = exports.DelegateBindingCommandRegistration = exports.TriggerBindingCommandRegistration = exports.TwoWayBindingCommandRegistration = exports.ToViewBindingCommandRegistration = exports.OneTimeBindingCommandRegistration = exports.FromViewBindingCommandRegistration = exports.RefBindingCommandRegistration = exports.ForBindingCommandRegistration = exports.DefaultBindingCommandRegistration = exports.CallBindingCommandRegistration = exports.SVGAnalyzerRegistration = exports.ShortHandBindingSyntax = exports.ColonPrefixedBindAttributePatternRegistration = exports.AtPrefixedTriggerAttributePatternRegistration = exports.DefaultBindingSyntax = exports.DotSeparatedAttributePatternRegistration = exports.RefAttributePatternRegistration = exports.DefaultComponents = exports.INodeObserverLocatorRegistration = exports.ITemplateCompilerRegistration = exports.ViewValueConverter = exports.SanitizeValueConverter = exports.ISanitizer = exports.Compose = exports.useShadowDOM = exports.CustomElementDefinition = exports.CustomElement = exports.customElement = exports.containerless = exports.ProjectionContext = exports.IProjectionProvider = exports.RegisteredProjections = exports.AuSlotContentType = exports.SlotInfo = exports.IProjections = exports.AuSlot = exports.Portal = exports.Focus = exports.BlurManager = exports.Blur = exports.DefaultCase = exports.Case = exports.Switch = exports.With = exports.Repeat = exports.Else = exports.If = exports.ObserveShallow = exports.FrequentMutations = exports.templateController = void 0;
exports.ExpressionWatcher = exports.ComputedWatcher = exports.watch = exports.Watch = exports.IShadowDOMGlobalStyles = exports.IShadowDOMStyles = exports.StyleElementStyles = exports.AdoptedStyleSheetsStyles = exports.StyleConfiguration = exports.shadowCSS = exports.IShadowDOMStyleFactory = exports.ShadowDOMRegistry = exports.cssModules = exports.CSSModulesProcessorRegistry = exports.ProjectionSymbol = exports.TextSymbol = exports.TemplateControllerSymbol = exports.SymbolFlags = exports.PlainElementSymbol = exports.PlainAttributeSymbol = exports.LetElementSymbol = exports.CustomElementSymbol = exports.CustomAttributeSymbol = exports.BindingSymbol = exports.AttrInfo = exports.ElementInfo = exports.BindableInfo = exports.IPlatform = exports.isRenderLocation = exports.convertToRenderLocation = exports.setEffectiveParentNode = exports.getEffectiveParentNode = exports.ILocation = exports.IWindow = exports.IHistory = exports.FragmentNodeSequence = exports.NodeType = exports.IRenderLocation = exports.IEventTarget = exports.INode = exports.RenderPlan = exports.createElement = exports.Views = exports.view = exports.ViewLocator = exports.IViewLocator = void 0;

var _platform = require("@aurelia/platform");

exports.Platform = _platform.Platform;
exports.TaskQueue = _platform.TaskQueue;
exports.Task = _platform.Task;
exports.TaskAbortError = _platform.TaskAbortError;
exports.TaskQueuePriority = _platform.TaskQueuePriority;
exports.TaskStatus = _platform.TaskStatus;

var _platformBrowser = require("@aurelia/platform-browser");

exports.BrowserPlatform = _platformBrowser.BrowserPlatform;

var _bindable = require("./bindable.js");

exports.bindable = _bindable.bindable;
exports.Bindable = _bindable.Bindable;
exports.BindableDefinition = _bindable.BindableDefinition;

var _bindableObserver = require("./observation/bindable-observer.js");

exports.BindableObserver = _bindableObserver.BindableObserver;

var _configuration = require("./configuration.js");

exports.DebounceBindingBehaviorRegistration = _configuration.DebounceBindingBehaviorRegistration;
exports.OneTimeBindingBehaviorRegistration = _configuration.OneTimeBindingBehaviorRegistration;
exports.ToViewBindingBehaviorRegistration = _configuration.ToViewBindingBehaviorRegistration;
exports.FromViewBindingBehaviorRegistration = _configuration.FromViewBindingBehaviorRegistration;
exports.SignalBindingBehaviorRegistration = _configuration.SignalBindingBehaviorRegistration;
exports.ThrottleBindingBehaviorRegistration = _configuration.ThrottleBindingBehaviorRegistration;
exports.TwoWayBindingBehaviorRegistration = _configuration.TwoWayBindingBehaviorRegistration;
exports.ITemplateCompilerRegistration = _configuration.ITemplateCompilerRegistration;
exports.INodeObserverLocatorRegistration = _configuration.INodeObserverLocatorRegistration;
exports.DefaultComponents = _configuration.DefaultComponents;
exports.RefAttributePatternRegistration = _configuration.RefAttributePatternRegistration;
exports.DotSeparatedAttributePatternRegistration = _configuration.DotSeparatedAttributePatternRegistration;
exports.DefaultBindingSyntax = _configuration.DefaultBindingSyntax;
exports.AtPrefixedTriggerAttributePatternRegistration = _configuration.AtPrefixedTriggerAttributePatternRegistration;
exports.ColonPrefixedBindAttributePatternRegistration = _configuration.ColonPrefixedBindAttributePatternRegistration;
exports.ShortHandBindingSyntax = _configuration.ShortHandBindingSyntax;
exports.SVGAnalyzerRegistration = _configuration.SVGAnalyzerRegistration;
exports.CallBindingCommandRegistration = _configuration.CallBindingCommandRegistration;
exports.DefaultBindingCommandRegistration = _configuration.DefaultBindingCommandRegistration;
exports.ForBindingCommandRegistration = _configuration.ForBindingCommandRegistration;
exports.RefBindingCommandRegistration = _configuration.RefBindingCommandRegistration;
exports.FromViewBindingCommandRegistration = _configuration.FromViewBindingCommandRegistration;
exports.OneTimeBindingCommandRegistration = _configuration.OneTimeBindingCommandRegistration;
exports.ToViewBindingCommandRegistration = _configuration.ToViewBindingCommandRegistration;
exports.TwoWayBindingCommandRegistration = _configuration.TwoWayBindingCommandRegistration;
exports.TriggerBindingCommandRegistration = _configuration.TriggerBindingCommandRegistration;
exports.DelegateBindingCommandRegistration = _configuration.DelegateBindingCommandRegistration;
exports.CaptureBindingCommandRegistration = _configuration.CaptureBindingCommandRegistration;
exports.AttrBindingCommandRegistration = _configuration.AttrBindingCommandRegistration;
exports.ClassBindingCommandRegistration = _configuration.ClassBindingCommandRegistration;
exports.StyleBindingCommandRegistration = _configuration.StyleBindingCommandRegistration;
exports.DefaultBindingLanguage = _configuration.DefaultBindingLanguage;
exports.ViewValueConverterRegistration = _configuration.ViewValueConverterRegistration;
exports.SanitizeValueConverterRegistration = _configuration.SanitizeValueConverterRegistration;
exports.IfRegistration = _configuration.IfRegistration;
exports.ElseRegistration = _configuration.ElseRegistration;
exports.RepeatRegistration = _configuration.RepeatRegistration;
exports.WithRegistration = _configuration.WithRegistration;
exports.AttrBindingBehaviorRegistration = _configuration.AttrBindingBehaviorRegistration;
exports.SelfBindingBehaviorRegistration = _configuration.SelfBindingBehaviorRegistration;
exports.UpdateTriggerBindingBehaviorRegistration = _configuration.UpdateTriggerBindingBehaviorRegistration;
exports.ComposeRegistration = _configuration.ComposeRegistration;
exports.DefaultResources = _configuration.DefaultResources;
exports.AttributeBindingRendererRegistration = _configuration.AttributeBindingRendererRegistration;
exports.ListenerBindingRendererRegistration = _configuration.ListenerBindingRendererRegistration;
exports.SetAttributeRendererRegistration = _configuration.SetAttributeRendererRegistration;
exports.SetClassAttributeRendererRegistration = _configuration.SetClassAttributeRendererRegistration;
exports.SetStyleAttributeRendererRegistration = _configuration.SetStyleAttributeRendererRegistration;
exports.StylePropertyBindingRendererRegistration = _configuration.StylePropertyBindingRendererRegistration;
exports.TextBindingRendererRegistration = _configuration.TextBindingRendererRegistration;
exports.RefBindingRendererRegistration = _configuration.RefBindingRendererRegistration;
exports.CallBindingRendererRegistration = _configuration.CallBindingRendererRegistration;
exports.CustomAttributeRendererRegistration = _configuration.CustomAttributeRendererRegistration;
exports.CustomElementRendererRegistration = _configuration.CustomElementRendererRegistration;
exports.InterpolationBindingRendererRegistration = _configuration.InterpolationBindingRendererRegistration;
exports.IteratorBindingRendererRegistration = _configuration.IteratorBindingRendererRegistration;
exports.LetElementRendererRegistration = _configuration.LetElementRendererRegistration;
exports.PropertyBindingRendererRegistration = _configuration.PropertyBindingRendererRegistration;
exports.SetPropertyRendererRegistration = _configuration.SetPropertyRendererRegistration;
exports.TemplateControllerRendererRegistration = _configuration.TemplateControllerRendererRegistration;
exports.DefaultRenderers = _configuration.DefaultRenderers;
exports.StandardConfiguration = _configuration.StandardConfiguration;

var _bindingMode = require("./binding-behaviors/binding-mode.js");

exports.BindingModeBehavior = _bindingMode.BindingModeBehavior;
exports.OneTimeBindingBehavior = _bindingMode.OneTimeBindingBehavior;
exports.ToViewBindingBehavior = _bindingMode.ToViewBindingBehavior;
exports.FromViewBindingBehavior = _bindingMode.FromViewBindingBehavior;
exports.TwoWayBindingBehavior = _bindingMode.TwoWayBindingBehavior;

var _debounce = require("./binding-behaviors/debounce.js");

exports.DebounceBindingBehavior = _debounce.DebounceBindingBehavior;

var _signals = require("./binding-behaviors/signals.js");

exports.SignalBindingBehavior = _signals.SignalBindingBehavior;

var _throttle = require("./binding-behaviors/throttle.js");

exports.ThrottleBindingBehavior = _throttle.ThrottleBindingBehavior;

var _runtime = require("@aurelia/runtime");

exports.alias = _runtime.alias;
exports.registerAliases = _runtime.registerAliases;
exports.CallFunctionExpression = _runtime.CallFunctionExpression;
exports.CustomExpression = _runtime.CustomExpression;
exports.BindingBehaviorExpression = _runtime.BindingBehaviorExpression;
exports.ValueConverterExpression = _runtime.ValueConverterExpression;
exports.AssignExpression = _runtime.AssignExpression;
exports.ConditionalExpression = _runtime.ConditionalExpression;
exports.AccessThisExpression = _runtime.AccessThisExpression;
exports.AccessScopeExpression = _runtime.AccessScopeExpression;
exports.AccessMemberExpression = _runtime.AccessMemberExpression;
exports.AccessKeyedExpression = _runtime.AccessKeyedExpression;
exports.CallScopeExpression = _runtime.CallScopeExpression;
exports.CallMemberExpression = _runtime.CallMemberExpression;
exports.BinaryExpression = _runtime.BinaryExpression;
exports.UnaryExpression = _runtime.UnaryExpression;
exports.PrimitiveLiteralExpression = _runtime.PrimitiveLiteralExpression;
exports.HtmlLiteralExpression = _runtime.HtmlLiteralExpression;
exports.ArrayLiteralExpression = _runtime.ArrayLiteralExpression;
exports.ObjectLiteralExpression = _runtime.ObjectLiteralExpression;
exports.TemplateExpression = _runtime.TemplateExpression;
exports.TaggedTemplateExpression = _runtime.TaggedTemplateExpression;
exports.ArrayBindingPattern = _runtime.ArrayBindingPattern;
exports.ObjectBindingPattern = _runtime.ObjectBindingPattern;
exports.BindingIdentifier = _runtime.BindingIdentifier;
exports.ForOfStatement = _runtime.ForOfStatement;
exports.Interpolation = _runtime.Interpolation;
exports.connectable = _runtime.connectable;
exports.BindingMediator = _runtime.BindingMediator;
exports.IExpressionParser = _runtime.IExpressionParser;
exports.BindingType = _runtime.BindingType;
exports.parseExpression = _runtime.parseExpression;
exports.Char = _runtime.Char;
exports.Access = _runtime.Access;
exports.Precedence = _runtime.Precedence;
exports.parse = _runtime.parse;
exports.ParserState = _runtime.ParserState;
exports.ArrayObserver = _runtime.ArrayObserver;
exports.ArrayIndexObserver = _runtime.ArrayIndexObserver;
exports.enableArrayObservation = _runtime.enableArrayObservation;
exports.disableArrayObservation = _runtime.disableArrayObservation;
exports.applyMutationsToIndices = _runtime.applyMutationsToIndices;
exports.synchronizeIndices = _runtime.synchronizeIndices;
exports.MapObserver = _runtime.MapObserver;
exports.enableMapObservation = _runtime.enableMapObservation;
exports.disableMapObservation = _runtime.disableMapObservation;
exports.SetObserver = _runtime.SetObserver;
exports.enableSetObservation = _runtime.enableSetObservation;
exports.disableSetObservation = _runtime.disableSetObservation;
exports.BindingContext = _runtime.BindingContext;
exports.Scope = _runtime.Scope;
exports.OverrideContext = _runtime.OverrideContext;
exports.CollectionLengthObserver = _runtime.CollectionLengthObserver;
exports.CollectionSizeObserver = _runtime.CollectionSizeObserver;
exports.IDirtyChecker = _runtime.IDirtyChecker;
exports.DirtyCheckProperty = _runtime.DirtyCheckProperty;
exports.DirtyCheckSettings = _runtime.DirtyCheckSettings;
exports.ComputedObserver = _runtime.ComputedObserver;
exports.observable = _runtime.observable;
exports.IObserverLocator = _runtime.IObserverLocator;
exports.INodeObserverLocator = _runtime.INodeObserverLocator;
exports.getCollectionObserver = _runtime.getCollectionObserver;
exports.ObserverLocator = _runtime.ObserverLocator;
exports.PrimitiveObserver = _runtime.PrimitiveObserver;
exports.PropertyAccessor = _runtime.PropertyAccessor;
exports.SetterObserver = _runtime.SetterObserver;
exports.ISignaler = _runtime.ISignaler;
exports.subscriberCollection = _runtime.subscriberCollection;
exports.bindingBehavior = _runtime.bindingBehavior;
exports.BindingBehavior = _runtime.BindingBehavior;
exports.BindingBehaviorDefinition = _runtime.BindingBehaviorDefinition;
exports.BindingInterceptor = _runtime.BindingInterceptor;
exports.BindingBehaviorFactory = _runtime.BindingBehaviorFactory;
exports.BindingBehaviorStrategy = _runtime.BindingBehaviorStrategy;
exports.ValueConverter = _runtime.ValueConverter;
exports.ValueConverterDefinition = _runtime.ValueConverterDefinition;
exports.valueConverter = _runtime.valueConverter;
exports.BindingMode = _runtime.BindingMode;
exports.ExpressionKind = _runtime.ExpressionKind;
exports.LifecycleFlags = _runtime.LifecycleFlags;
exports.AccessorType = _runtime.AccessorType;
exports.CollectionKind = _runtime.CollectionKind;
exports.DelegationStrategy = _runtime.DelegationStrategy;
exports.isIndexMap = _runtime.isIndexMap;
exports.copyIndexMap = _runtime.copyIndexMap;
exports.cloneIndexMap = _runtime.cloneIndexMap;
exports.createIndexMap = _runtime.createIndexMap;

var _aurelia = require("./aurelia.js");

exports.Aurelia = _aurelia.Aurelia;
exports.IAurelia = _aurelia.IAurelia;

var _appRoot = require("./app-root.js");

exports.AppRoot = _appRoot.AppRoot;
exports.IAppRoot = _appRoot.IAppRoot;

var _appTask = require("./app-task.js");

exports.AppTask = _appTask.AppTask;
exports.IAppTask = _appTask.IAppTask;

var _attributePattern = require("./resources/attribute-pattern.js");

exports.AttrSyntax = _attributePattern.AttrSyntax;
exports.IAttributeParser = _attributePattern.IAttributeParser;
exports.attributePattern = _attributePattern.attributePattern;
exports.IAttributePattern = _attributePattern.IAttributePattern;
exports.AttributePattern = _attributePattern.AttributePattern;
exports.Interpretation = _attributePattern.Interpretation;
exports.ISyntaxInterpreter = _attributePattern.ISyntaxInterpreter;
exports.AtPrefixedTriggerAttributePattern = _attributePattern.AtPrefixedTriggerAttributePattern;
exports.ColonPrefixedBindAttributePattern = _attributePattern.ColonPrefixedBindAttributePattern;
exports.DotSeparatedAttributePattern = _attributePattern.DotSeparatedAttributePattern;
exports.RefAttributePattern = _attributePattern.RefAttributePattern;

var _bindingCommand = require("./resources/binding-command.js");

exports.bindingCommand = _bindingCommand.bindingCommand;
exports.BindingCommand = _bindingCommand.BindingCommand;
exports.BindingCommandDefinition = _bindingCommand.BindingCommandDefinition;
exports.getTarget = _bindingCommand.getTarget;
exports.CallBindingCommand = _bindingCommand.CallBindingCommand;
exports.DefaultBindingCommand = _bindingCommand.DefaultBindingCommand;
exports.ForBindingCommand = _bindingCommand.ForBindingCommand;
exports.FromViewBindingCommand = _bindingCommand.FromViewBindingCommand;
exports.OneTimeBindingCommand = _bindingCommand.OneTimeBindingCommand;
exports.ToViewBindingCommand = _bindingCommand.ToViewBindingCommand;
exports.TwoWayBindingCommand = _bindingCommand.TwoWayBindingCommand;
exports.TriggerBindingCommand = _bindingCommand.TriggerBindingCommand;
exports.DelegateBindingCommand = _bindingCommand.DelegateBindingCommand;
exports.CaptureBindingCommand = _bindingCommand.CaptureBindingCommand;
exports.AttrBindingCommand = _bindingCommand.AttrBindingCommand;
exports.ClassBindingCommand = _bindingCommand.ClassBindingCommand;
exports.StyleBindingCommand = _bindingCommand.StyleBindingCommand;

var _attributeSyntaxTransformer = require("./attribute-syntax-transformer.js");

exports.IAttrSyntaxTransformer = _attributeSyntaxTransformer.IAttrSyntaxTransformer;

var _listener = require("./binding/listener.js");

exports.Listener = _listener.Listener;

var _attribute = require("./binding/attribute.js");

exports.AttributeBinding = _attribute.AttributeBinding;

var _callBinding = require("./binding/call-binding.js");

exports.CallBinding = _callBinding.CallBinding;

var _interpolationBinding = require("./binding/interpolation-binding.js");

exports.InterpolationBinding = _interpolationBinding.InterpolationBinding;

var _letBinding = require("./binding/let-binding.js");

exports.LetBinding = _letBinding.LetBinding;

var _propertyBinding = require("./binding/property-binding.js");

exports.PropertyBinding = _propertyBinding.PropertyBinding;

var _refBinding = require("./binding/ref-binding.js");

exports.RefBinding = _refBinding.RefBinding;

var _renderer = require("./renderer.js");

exports.IRenderer = _renderer.IRenderer;
exports.ITemplateCompiler = _renderer.ITemplateCompiler;
exports.renderer = _renderer.renderer;
exports.CallBindingInstruction = _renderer.CallBindingInstruction;
exports.HydrateAttributeInstruction = _renderer.HydrateAttributeInstruction;
exports.HydrateElementInstruction = _renderer.HydrateElementInstruction;
exports.HydrateTemplateController = _renderer.HydrateTemplateController;
exports.InterpolationInstruction = _renderer.InterpolationInstruction;
exports.IteratorBindingInstruction = _renderer.IteratorBindingInstruction;
exports.LetBindingInstruction = _renderer.LetBindingInstruction;
exports.HydrateLetElementInstruction = _renderer.HydrateLetElementInstruction;
exports.RefBindingInstruction = _renderer.RefBindingInstruction;
exports.SetPropertyInstruction = _renderer.SetPropertyInstruction;
exports.AttributeBindingInstruction = _renderer.AttributeBindingInstruction;
exports.ListenerBindingInstruction = _renderer.ListenerBindingInstruction;
exports.PropertyBindingInstruction = _renderer.PropertyBindingInstruction;
exports.SetAttributeInstruction = _renderer.SetAttributeInstruction;
exports.SetClassAttributeInstruction = _renderer.SetClassAttributeInstruction;
exports.SetStyleAttributeInstruction = _renderer.SetStyleAttributeInstruction;
exports.StylePropertyBindingInstruction = _renderer.StylePropertyBindingInstruction;
exports.TextBindingInstruction = _renderer.TextBindingInstruction;
exports.isInstruction = _renderer.isInstruction;
exports.IInstruction = _renderer.IInstruction;
exports.InstructionType = _renderer.InstructionType;

var _attributeNsAccessor = require("./observation/attribute-ns-accessor.js");

exports.AttributeNSAccessor = _attributeNsAccessor.AttributeNSAccessor;

var _checkedObserver = require("./observation/checked-observer.js");

exports.CheckedObserver = _checkedObserver.CheckedObserver;

var _classAttributeAccessor = require("./observation/class-attribute-accessor.js");

exports.ClassAttributeAccessor = _classAttributeAccessor.ClassAttributeAccessor;

var _dataAttributeAccessor = require("./observation/data-attribute-accessor.js");

exports.DataAttributeAccessor = _dataAttributeAccessor.DataAttributeAccessor;

var _eventDelegator = require("./observation/event-delegator.js");

exports.IEventDelegator = _eventDelegator.IEventDelegator;
exports.EventSubscriber = _eventDelegator.EventSubscriber;
exports.EventDelegator = _eventDelegator.EventDelegator;

var _observerLocator = require("./observation/observer-locator.js");

exports.NodeObserverConfig = _observerLocator.NodeObserverConfig;
exports.NodeObserverLocator = _observerLocator.NodeObserverLocator;

var _selectValueObserver = require("./observation/select-value-observer.js");

exports.SelectValueObserver = _selectValueObserver.SelectValueObserver;

var _styleAttributeAccessor = require("./observation/style-attribute-accessor.js");

exports.StyleAttributeAccessor = _styleAttributeAccessor.StyleAttributeAccessor;

var _svgAnalyzer = require("./observation/svg-analyzer.js");

exports.ISVGAnalyzer = _svgAnalyzer.ISVGAnalyzer;
exports.SVGAnalyzer = _svgAnalyzer.SVGAnalyzer;
exports.NoopSVGAnalyzer = _svgAnalyzer.NoopSVGAnalyzer;

var _valueAttributeObserver = require("./observation/value-attribute-observer.js");

exports.ValueAttributeObserver = _valueAttributeObserver.ValueAttributeObserver;

var _attr = require("./resources/binding-behaviors/attr.js");

exports.AttrBindingBehavior = _attr.AttrBindingBehavior;

var _self = require("./resources/binding-behaviors/self.js");

exports.SelfBindingBehavior = _self.SelfBindingBehavior;

var _updateTrigger = require("./resources/binding-behaviors/update-trigger.js");

exports.UpdateTriggerBindingBehavior = _updateTrigger.UpdateTriggerBindingBehavior;

var _customAttribute = require("./resources/custom-attribute.js");

exports.customAttribute = _customAttribute.customAttribute;
exports.CustomAttribute = _customAttribute.CustomAttribute;
exports.CustomAttributeDefinition = _customAttribute.CustomAttributeDefinition;
exports.templateController = _customAttribute.templateController;

var _flags = require("./resources/template-controllers/flags.js");

exports.FrequentMutations = _flags.FrequentMutations;
exports.ObserveShallow = _flags.ObserveShallow;

var _if = require("./resources/template-controllers/if.js");

exports.If = _if.If;
exports.Else = _if.Else;

var _repeat = require("./resources/template-controllers/repeat.js");

exports.Repeat = _repeat.Repeat;

var _with = require("./resources/template-controllers/with.js");

exports.With = _with.With;

var _switch = require("./resources/template-controllers/switch.js");

exports.Switch = _switch.Switch;
exports.Case = _switch.Case;
exports.DefaultCase = _switch.DefaultCase;

var _blur = require("./resources/custom-attributes/blur.js");

exports.Blur = _blur.Blur;
exports.BlurManager = _blur.BlurManager;

var _focus = require("./resources/custom-attributes/focus.js");

exports.Focus = _focus.Focus;

var _portal = require("./resources/template-controllers/portal.js");

exports.Portal = _portal.Portal;

var _auSlot = require("./resources/custom-elements/au-slot.js");

exports.AuSlot = _auSlot.AuSlot;
exports.IProjections = _auSlot.IProjections;
exports.SlotInfo = _auSlot.SlotInfo;
exports.AuSlotContentType = _auSlot.AuSlotContentType;
exports.RegisteredProjections = _auSlot.RegisteredProjections;
exports.IProjectionProvider = _auSlot.IProjectionProvider;
exports.ProjectionContext = _auSlot.ProjectionContext;

var _customElement = require("./resources/custom-element.js");

exports.containerless = _customElement.containerless;
exports.customElement = _customElement.customElement;
exports.CustomElement = _customElement.CustomElement;
exports.CustomElementDefinition = _customElement.CustomElementDefinition;
exports.useShadowDOM = _customElement.useShadowDOM;

var _compose = require("./resources/custom-elements/compose.js");

exports.Compose = _compose.Compose;

var _sanitize = require("./resources/value-converters/sanitize.js");

exports.ISanitizer = _sanitize.ISanitizer;
exports.SanitizeValueConverter = _sanitize.SanitizeValueConverter;

var _view = require("./resources/value-converters/view.js");

exports.ViewValueConverter = _view.ViewValueConverter;

var _templateBinder = require("./template-binder.js");

exports.TemplateBinder = _templateBinder.TemplateBinder;

var _templateElementFactory = require("./template-element-factory.js");

exports.ITemplateElementFactory = _templateElementFactory.ITemplateElementFactory;

var _children = require("./templating/children.js");

exports.ChildrenDefinition = _children.ChildrenDefinition;
exports.Children = _children.Children;
exports.children = _children.children;
exports.ChildrenObserver = _children.ChildrenObserver;

var _controller = require("./templating/controller.js");

exports.Controller = _controller.Controller;
exports.isCustomElementController = _controller.isCustomElementController;
exports.isCustomElementViewModel = _controller.isCustomElementViewModel;
exports.ViewModelKind = _controller.ViewModelKind;
exports.IController = _controller.IController;

var _renderContext = require("./templating/render-context.js");

exports.getRenderContext = _renderContext.getRenderContext;
exports.isRenderContext = _renderContext.isRenderContext;

var _view2 = require("./templating/view.js");

exports.ViewFactory = _view2.ViewFactory;
exports.IViewFactory = _view2.IViewFactory;
exports.IViewLocator = _view2.IViewLocator;
exports.ViewLocator = _view2.ViewLocator;
exports.view = _view2.view;
exports.Views = _view2.Views;

var _createElement = require("./create-element.js");

exports.createElement = _createElement.createElement;
exports.RenderPlan = _createElement.RenderPlan;

var _dom = require("./dom.js");

exports.INode = _dom.INode;
exports.IEventTarget = _dom.IEventTarget;
exports.IRenderLocation = _dom.IRenderLocation;
exports.NodeType = _dom.NodeType;
exports.FragmentNodeSequence = _dom.FragmentNodeSequence;
exports.IHistory = _dom.IHistory;
exports.IWindow = _dom.IWindow;
exports.ILocation = _dom.ILocation;
exports.getEffectiveParentNode = _dom.getEffectiveParentNode;
exports.setEffectiveParentNode = _dom.setEffectiveParentNode;
exports.convertToRenderLocation = _dom.convertToRenderLocation;
exports.isRenderLocation = _dom.isRenderLocation;

var _platform2 = require("./platform.js");

exports.IPlatform = _platform2.IPlatform;

var _semanticModel = require("./semantic-model.js");

exports.BindableInfo = _semanticModel.BindableInfo;
exports.ElementInfo = _semanticModel.ElementInfo;
exports.AttrInfo = _semanticModel.AttrInfo;
exports.BindingSymbol = _semanticModel.BindingSymbol;
exports.CustomAttributeSymbol = _semanticModel.CustomAttributeSymbol;
exports.CustomElementSymbol = _semanticModel.CustomElementSymbol;
exports.LetElementSymbol = _semanticModel.LetElementSymbol;
exports.PlainAttributeSymbol = _semanticModel.PlainAttributeSymbol;
exports.PlainElementSymbol = _semanticModel.PlainElementSymbol;
exports.SymbolFlags = _semanticModel.SymbolFlags;
exports.TemplateControllerSymbol = _semanticModel.TemplateControllerSymbol;
exports.TextSymbol = _semanticModel.TextSymbol;
exports.ProjectionSymbol = _semanticModel.ProjectionSymbol;

var _styles = require("./templating/styles.js");

exports.CSSModulesProcessorRegistry = _styles.CSSModulesProcessorRegistry;
exports.cssModules = _styles.cssModules;
exports.ShadowDOMRegistry = _styles.ShadowDOMRegistry;
exports.IShadowDOMStyleFactory = _styles.IShadowDOMStyleFactory;
exports.shadowCSS = _styles.shadowCSS;
exports.StyleConfiguration = _styles.StyleConfiguration;
exports.AdoptedStyleSheetsStyles = _styles.AdoptedStyleSheetsStyles;
exports.StyleElementStyles = _styles.StyleElementStyles;
exports.IShadowDOMStyles = _styles.IShadowDOMStyles;
exports.IShadowDOMGlobalStyles = _styles.IShadowDOMGlobalStyles;

var _watch = require("./watch.js");

exports.Watch = _watch.Watch;
exports.watch = _watch.watch;

var _watchers = require("./templating/watchers.js");

exports.ComputedWatcher = _watchers.ComputedWatcher;
exports.ExpressionWatcher = _watchers.ExpressionWatcher;
});

;define.alias('@aurelia/runtime-html','@aurelia/runtime-html/dist/esm/index.js');
define('@aurelia/runtime-html/dist/esm/observation/attribute-ns-accessor.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.AttributeNSAccessor = void 0;
const nsMap = Object.create(null);
/**
 * Attribute accessor in a XML document/element that can be accessed via a namespace.
 * Wraps [`getAttributeNS`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNS).
 */

class AttributeNSAccessor {
  constructor(namespace) {
    this.namespace = namespace;
    this.currentValue = null; // ObserverType.Layout is not always true, it depends on the property
    // but for simplicity, always treat as such

    this.type = 2
    /* Node */
    | 4
    /* Layout */
    ;
  }

  static forNs(ns) {
    return nsMap[ns] ?? (nsMap[ns] = new AttributeNSAccessor(ns));
  }

  getValue(obj, propertyKey) {
    return obj.getAttributeNS(this.namespace, propertyKey);
  }

  setValue(newValue, flags, obj, key) {
    if (newValue == void 0) {
      obj.removeAttributeNS(this.namespace, key);
    } else {
      obj.setAttributeNS(this.namespace, key, newValue);
    }
  }

}

exports.AttributeNSAccessor = AttributeNSAccessor;
});

;define.alias('@aurelia/runtime-html/observation/attribute-ns-accessor.js','@aurelia/runtime-html/dist/esm/observation/attribute-ns-accessor.js');
define('@aurelia/runtime-html/dist/esm/observation/bindable-observer.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.BindableObserver = void 0;

var _kernel = require("@aurelia/kernel");

var _runtime = require("@aurelia/runtime");

class BindableObserver {
  constructor(obj, propertyKey, cbName, set, $controller) {
    this.obj = obj;
    this.propertyKey = propertyKey;
    this.set = set;
    this.$controller = $controller;
    this.currentValue = void 0;
    this.oldValue = void 0;
    const cb = obj[cbName];
    const cbAll = obj.propertyChanged;
    const hasCb = this.hasCb = typeof cb === 'function';
    const hasCbAll = this.hasCbAll = typeof cbAll === 'function';
    const hasSetter = this.hasSetter = set !== _kernel.noop;
    this.cb = hasCb ? cb : _kernel.noop;
    this.cbAll = this.hasCbAll ? cbAll : _kernel.noop; // when user declare @bindable({ set })
    // it's expected to work from the start,
    // regardless where the assignment comes from: either direct view model assignment or from binding during render
    // so if either getter/setter config is present, alter the accessor straight await

    if (this.cb === void 0 && !hasCbAll && !hasSetter) {
      this.observing = false;
    } else {
      this.observing = true;
      const val = obj[propertyKey];
      this.currentValue = hasSetter && val !== void 0 ? set(val) : val;
      this.createGetterSetter();
    }
  }

  get type() {
    return 1
    /* Observer */
    ;
  }

  getValue() {
    return this.currentValue;
  }

  setValue(newValue, flags) {
    if (this.hasSetter) {
      newValue = this.set(newValue);
    }

    if (this.observing) {
      const currentValue = this.currentValue;

      if (Object.is(newValue, currentValue)) {
        return;
      }

      this.currentValue = newValue; // todo: controller (if any) state should determine the invocation instead

      if ((flags & 32
      /* fromBind */
      ) === 0 || (flags & 16
      /* updateSource */
      ) > 0) {
        if (this.hasCb) {
          this.cb.call(this.obj, newValue, currentValue, flags);
        }

        if (this.hasCbAll) {
          this.cbAll.call(this.obj, this.propertyKey, newValue, currentValue, flags);
        }
      }

      this.subs.notify(newValue, currentValue, flags);
    } else {
      // See SetterObserver.setValue for explanation
      this.obj[this.propertyKey] = newValue;
    }
  }

  subscribe(subscriber) {
    if (!this.observing === false) {
      this.observing = true;
      const currentValue = this.obj[this.propertyKey];
      this.currentValue = this.hasSetter ? this.set(currentValue) : currentValue;
      this.createGetterSetter();
    }

    this.subs.add(subscriber);
  }

  createGetterSetter() {
    Reflect.defineProperty(this.obj, this.propertyKey, {
      enumerable: true,
      configurable: true,
      get: () =>
      /* Bindable Observer */
      this.currentValue,
      set:
      /* Bindable Observer */
      value => {
        this.setValue(value, 0
        /* none */
        );
      }
    });
  }

}

exports.BindableObserver = BindableObserver;
(0, _runtime.subscriberCollection)(BindableObserver);
});

;define.alias('@aurelia/runtime-html/observation/bindable-observer.js','@aurelia/runtime-html/dist/esm/observation/bindable-observer.js');
define('@aurelia/runtime-html/dist/esm/observation/checked-observer.js',['require','exports','module','@aurelia/runtime','./observer-locator.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.CheckedObserver = void 0;

var _runtime = require("@aurelia/runtime");

var _observerLocator = require("./observer-locator.js");

function defaultMatcher(a, b) {
  return a === b;
}

class CheckedObserver {
  constructor(obj, // deepscan-disable-next-line
  _key, handler, observerLocator) {
    this.handler = handler;
    this.observerLocator = observerLocator;
    this.value = void 0;
    this.oldValue = void 0;
    this.type = 2
    /* Node */
    | 1
    /* Observer */
    | 4
    /* Layout */
    ;
    this.collectionObserver = void 0;
    this.valueObserver = void 0;
    this.obj = obj;
  }

  getValue() {
    return this.value;
  }

  setValue(newValue, flags) {
    const currentValue = this.value;

    if (newValue === currentValue) {
      return;
    }

    this.value = newValue;
    this.oldValue = currentValue;
    this.observe();
    this.synchronizeElement();
    this.subs.notify(newValue, currentValue, flags);
  }

  handleCollectionChange(indexMap, flags) {
    this.synchronizeElement();
  }

  handleChange(newValue, previousValue, flags) {
    this.synchronizeElement();
  }

  synchronizeElement() {
    const currentValue = this.value;
    const obj = this.obj;
    const elementValue = Object.prototype.hasOwnProperty.call(obj, 'model') ? obj.model : obj.value;
    const isRadio = obj.type === 'radio';
    const matcher = obj.matcher !== void 0 ? obj.matcher : defaultMatcher;

    if (isRadio) {
      obj.checked = !!matcher(currentValue, elementValue);
    } else if (currentValue === true) {
      obj.checked = true;
    } else {
      let hasMatch = false;

      if (currentValue instanceof Array) {
        hasMatch = currentValue.findIndex(item => !!matcher(item, elementValue)) !== -1;
      } else if (currentValue instanceof Set) {
        for (const v of currentValue) {
          if (matcher(v, elementValue)) {
            hasMatch = true;
            break;
          }
        }
      } else if (currentValue instanceof Map) {
        for (const pair of currentValue) {
          const existingItem = pair[0];
          const $isChecked = pair[1]; // a potential complain, when only `true` is supported
          // but it's consistent with array

          if (matcher(existingItem, elementValue) && $isChecked === true) {
            hasMatch = true;
            break;
          }
        }
      }

      obj.checked = hasMatch;
    }
  }

  handleEvent() {
    let currentValue = this.oldValue = this.value;
    const obj = this.obj;
    const elementValue = Object.prototype.hasOwnProperty.call(obj, 'model') ? obj.model : obj.value;
    const isChecked = obj.checked;
    const matcher = obj.matcher !== void 0 ? obj.matcher : defaultMatcher;

    if (obj.type === 'checkbox') {
      if (currentValue instanceof Array) {
        // Array binding steps on a change event:
        // 1. find corresponding item INDEX in the Set based on current model/value and matcher
        // 2. is the checkbox checked?
        //    2.1. Yes: is the corresponding item in the Array (index === -1)?
        //        2.1.1 No: push the current model/value to the Array
        //    2.2. No: is the corresponding item in the Array (index !== -1)?
        //        2.2.1: Yes: remove the corresponding item
        // =================================================
        const index = currentValue.findIndex(item => !!matcher(item, elementValue)); // if the checkbox is checkde, and there's no matching value in the existing array
        // add the checkbox model/value to the array

        if (isChecked && index === -1) {
          currentValue.push(elementValue);
        } else if (!isChecked && index !== -1) {
          // if the checkbox is not checked, and found a matching item in the array
          // based on the checkbox model/value
          // remove the existing item
          currentValue.splice(index, 1);
        } // when existing currentValue is an array,
        // do not invoke callback as only the array obj has changed


        return;
      } else if (currentValue instanceof Set) {
        // Set binding steps on a change event:
        // 1. find corresponding item in the Set based on current model/value and matcher
        // 2. is the checkbox checked?
        //    2.1. Yes: is the corresponding item in the Set?
        //        2.1.1 No: add the current model/value to the Set
        //    2.2. No: is the corresponding item in the Set?
        //        2.2.1: Yes: remove the corresponding item
        // =================================================
        // 1. find corresponding item
        const unset = {};
        let existingItem = unset;

        for (const value of currentValue) {
          if (matcher(value, elementValue) === true) {
            existingItem = value;
            break;
          }
        } // 2.1. Checkbox is checked, is the corresponding item in the Set?
        //
        // if checkbox is checked and there's no value in the existing Set
        // add the checkbox model/value to the Set


        if (isChecked && existingItem === unset) {
          // 2.1.1. add the current model/value to the Set
          currentValue.add(elementValue);
        } else if (!isChecked && existingItem !== unset) {
          // 2.2.1 Checkbox is unchecked, corresponding is in the Set
          //
          // if checkbox is not checked, and found a matching item in the Set
          // based on the checkbox model/value
          // remove the existing item
          currentValue.delete(existingItem);
        } // when existing value is a Set,
        // do not invoke callback as only the Set has been mutated


        return;
      } else if (currentValue instanceof Map) {
        // Map binding steps on a change event
        // 1. find corresponding item in the Map based on current model/value and matcher
        // 2. Set the value of the corresponding item in the Map based on checked state of the checkbox
        // =================================================
        // 1. find the corresponding item
        let existingItem;

        for (const pair of currentValue) {
          const currItem = pair[0];

          if (matcher(currItem, elementValue) === true) {
            existingItem = currItem;
            break;
          }
        } // 2. set the value of the corresponding item in the map
        // if checkbox is checked and there's no value in the existing Map
        // add the checkbox model/value to the Map as key,
        // and value will be checked state of the checkbox


        currentValue.set(existingItem, isChecked); // when existing value is a Map,
        // do not invoke callback as only the Map has been mutated

        return;
      }

      currentValue = isChecked;
    } else if (isChecked) {
      currentValue = elementValue;
    } else {
      // if it's a radio and it has been unchecked
      // do nothing, as the radio that was checked will fire change event and it will be handle there
      // a radio cannot be unchecked by user
      return;
    }

    this.value = currentValue;
    this.subs.notify(this.value, this.oldValue, 0
    /* none */
    );
  }

  start() {
    this.handler.subscribe(this.obj, this);
    this.observe();
  }

  stop() {
    this.handler.dispose();
    this.collectionObserver?.unsubscribe(this);
    this.collectionObserver = void 0;
    this.valueObserver?.unsubscribe(this);
  }

  subscribe(subscriber) {
    if (this.subs.add(subscriber) && this.subs.count === 1) {
      this.start();
    }
  }

  unsubscribe(subscriber) {
    if (this.subs.remove(subscriber) && this.subs.count === 0) {
      this.stop();
    }
  }

  observe() {
    const obj = this.obj;
    (this.valueObserver ?? (this.valueObserver = obj.$observers?.model ?? obj.$observers?.value))?.subscribe(this);
    this.collectionObserver?.unsubscribe(this);
    this.collectionObserver = void 0;

    if (obj.type === 'checkbox') {
      (this.collectionObserver = (0, _observerLocator.getCollectionObserver)(this.value, this.observerLocator))?.subscribe(this);
    }
  }

}

exports.CheckedObserver = CheckedObserver;
(0, _runtime.subscriberCollection)(CheckedObserver);
});

;define.alias('@aurelia/runtime-html/observation/checked-observer.js','@aurelia/runtime-html/dist/esm/observation/checked-observer.js');
define('@aurelia/runtime-html/dist/esm/observation/class-attribute-accessor.js',['require','exports','module','@aurelia/kernel'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.getClassesToAdd = getClassesToAdd;
exports.ClassAttributeAccessor = void 0;

var _kernel = require("@aurelia/kernel");

class ClassAttributeAccessor {
  constructor(obj) {
    this.obj = obj;
    this.currentValue = '';
    this.oldValue = '';
    this.doNotCache = true;
    this.nameIndex = {};
    this.version = 0;
    this.hasChanges = false;
    this.isActive = false;
    this.type = 2
    /* Node */
    | 4
    /* Layout */
    ;
  }

  getValue() {
    // is it safe to assume the observer has the latest value?
    // todo: ability to turn on/off cache based on type
    return this.currentValue;
  }

  setValue(newValue, flags) {
    this.currentValue = newValue;
    this.hasChanges = newValue !== this.oldValue;

    if ((flags & 4096
    /* noFlush */
    ) === 0) {
      this.flushChanges(flags);
    }
  }

  flushChanges(flags) {
    if (this.hasChanges) {
      this.hasChanges = false;
      const currentValue = this.currentValue;
      const nameIndex = this.nameIndex;
      let version = this.version;
      this.oldValue = currentValue;
      const classesToAdd = getClassesToAdd(currentValue); // Get strings split on a space not including empties

      if (classesToAdd.length > 0) {
        this.addClassesAndUpdateIndex(classesToAdd);
      }

      this.version += 1; // First call to setValue?  We're done.

      if (version === 0) {
        return;
      } // Remove classes from previous version.


      version -= 1;

      for (const name in nameIndex) {
        if (!Object.prototype.hasOwnProperty.call(nameIndex, name) || nameIndex[name] !== version) {
          continue;
        } // TODO: this has the side-effect that classes already present which are added again,
        // will be removed if they're not present in the next update.
        // Better would be do have some configurability for this behavior, allowing the user to
        // decide whether initial classes always need to be kept, always removed, or something in between


        this.obj.classList.remove(name);
      }
    }
  }

  addClassesAndUpdateIndex(classes) {
    const node = this.obj;

    for (let i = 0, ii = classes.length; i < ii; i++) {
      const className = classes[i];

      if (className.length === 0) {
        continue;
      }

      this.nameIndex[className] = this.version;
      node.classList.add(className);
    }
  }

}

exports.ClassAttributeAccessor = ClassAttributeAccessor;

function getClassesToAdd(object) {
  if (typeof object === 'string') {
    return splitClassString(object);
  }

  if (typeof object !== 'object') {
    return _kernel.emptyArray;
  }

  if (object instanceof Array) {
    const len = object.length;

    if (len > 0) {
      const classes = [];

      for (let i = 0; i < len; ++i) {
        classes.push(...getClassesToAdd(object[i]));
      }

      return classes;
    } else {
      return _kernel.emptyArray;
    }
  }

  const classes = [];

  for (const property in object) {
    // Let non typical values also evaluate true so disable bool check
    if (Boolean(object[property])) {
      // We must do this in case object property has a space in the name which results in two classes
      if (property.includes(' ')) {
        classes.push(...splitClassString(property));
      } else {
        classes.push(property);
      }
    }
  }

  return classes;
}

function splitClassString(classString) {
  const matches = classString.match(/\S+/g);

  if (matches === null) {
    return _kernel.emptyArray;
  }

  return matches;
}
});

;define.alias('@aurelia/runtime-html/observation/class-attribute-accessor.js','@aurelia/runtime-html/dist/esm/observation/class-attribute-accessor.js');
define('@aurelia/runtime-html/dist/esm/observation/data-attribute-accessor.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.attrAccessor = exports.DataAttributeAccessor = void 0;

/**
 * Attribute accessor for HTML elements.
 * Note that Aurelia works with properties, so in all case it will try to assign to property instead of attributes.
 * Unless the property falls into a special set, then it will use attribute for it.
 *
 * @see ElementPropertyAccessor
 */
class DataAttributeAccessor {
  constructor() {
    this.propertyKey = '';
    this.currentValue = null; // ObserverType.Layout is not always true, it depends on the property
    // but for simplicity, always treat as such

    this.type = 2
    /* Node */
    | 4
    /* Layout */
    ;
  }

  getValue(obj, key) {
    return obj.getAttribute(key);
  }

  setValue(newValue, flags, obj, key) {
    if (newValue == void 0) {
      obj.removeAttribute(key);
    } else {
      obj.setAttribute(key, newValue);
    }
  }

}

exports.DataAttributeAccessor = DataAttributeAccessor;
const attrAccessor = new DataAttributeAccessor();
exports.attrAccessor = attrAccessor;
});

;define.alias('@aurelia/runtime-html/observation/data-attribute-accessor.js','@aurelia/runtime-html/dist/esm/observation/data-attribute-accessor.js');
define('@aurelia/runtime-html/dist/esm/observation/element-attribute-observer.js',['require','exports','module','@aurelia/runtime'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.AttributeObserver = void 0;

var _runtime = require("@aurelia/runtime");

/**
 * Observer for handling two-way binding with attributes
 * Has different strategy for class/style and normal attributes
 * TODO: handle SVG/attributes with namespace
 */
class AttributeObserver {
  constructor(platform, observerLocator, obj, propertyKey, targetAttribute) {
    this.platform = platform;
    this.observerLocator = observerLocator;
    this.obj = obj;
    this.propertyKey = propertyKey;
    this.targetAttribute = targetAttribute;
    this.currentValue = null;
    this.oldValue = null;
    this.hasChanges = false; // layout is not certain, depends on the attribute being flushed to owner element
    // but for simple start, always treat as such

    this.type = 2
    /* Node */
    | 1
    /* Observer */
    | 4
    /* Layout */
    ;
  }

  getValue() {
    // is it safe to assume the observer has the latest value?
    // todo: ability to turn on/off cache based on type
    return this.currentValue;
  }

  setValue(newValue, flags) {
    this.currentValue = newValue;
    this.hasChanges = newValue !== this.oldValue;

    if ((flags & 4096
    /* noFlush */
    ) === 0) {
      this.flushChanges(flags);
    }
  }

  flushChanges(flags) {
    if (this.hasChanges) {
      this.hasChanges = false;
      const currentValue = this.currentValue;
      this.oldValue = currentValue;

      switch (this.targetAttribute) {
        case 'class':
          {
            // Why does class attribute observer setValue look different with class attribute accessor?
            // ==============
            // For class list
            // newValue is simply checked if truthy or falsy
            // and toggle the class accordingly
            // -- the rule of this is quite different to normal attribute
            //
            // for class attribute, observer is different in a way that it only observes one class at a time
            // this also comes from syntax, where it would typically be my-class.class="someProperty"
            //
            // so there is no need for separating class by space and add all of them like class accessor
            //
            // note: not using .toggle API so that environment with broken impl (IE11) won't need to polfyfill by default
            if (!!currentValue) {
              this.obj.classList.add(this.propertyKey);
            } else {
              this.obj.classList.remove(this.propertyKey);
            }

            break;
          }

        case 'style':
          {
            let priority = '';
            let newValue = currentValue;

            if (typeof newValue === 'string' && newValue.includes('!important')) {
              priority = 'important';
              newValue = newValue.replace('!important', '');
            }

            this.obj.style.setProperty(this.propertyKey, newValue, priority);
          }
      }
    }
  }

  handleMutation(mutationRecords) {
    let shouldProcess = false;

    for (let i = 0, ii = mutationRecords.length; ii > i; ++i) {
      const record = mutationRecords[i];

      if (record.type === 'attributes' && record.attributeName === this.propertyKey) {
        shouldProcess = true;
        break;
      }
    }

    if (shouldProcess) {
      let newValue;

      switch (this.targetAttribute) {
        case 'class':
          newValue = this.obj.classList.contains(this.propertyKey);
          break;

        case 'style':
          newValue = this.obj.style.getPropertyValue(this.propertyKey);
          break;

        default:
          throw new Error(`Unsupported targetAttribute: ${this.targetAttribute}`);
      }

      if (newValue !== this.currentValue) {
        const {
          currentValue
        } = this;
        this.currentValue = this.oldValue = newValue;
        this.hasChanges = false;
        this.subs.notify(newValue, currentValue, 0
        /* none */
        );
      }
    }
  }

  subscribe(subscriber) {
    if (this.subs.add(subscriber) && this.subs.count === 1) {
      this.currentValue = this.oldValue = this.obj.getAttribute(this.propertyKey);
      startObservation(this.obj.ownerDocument.defaultView.MutationObserver, this.obj, this);
    }
  }

  unsubscribe(subscriber) {
    if (this.subs.remove(subscriber) && this.subs.count === 0) {
      stopObservation(this.obj, this);
    }
  }

}

exports.AttributeObserver = AttributeObserver;
(0, _runtime.subscriberCollection)(AttributeObserver);

const startObservation = ($MutationObserver, element, subscription) => {
  if (element.$eMObservers === undefined) {
    element.$eMObservers = new Set();
  }

  if (element.$mObserver === undefined) {
    (element.$mObserver = new $MutationObserver(handleMutation)).observe(element, {
      attributes: true
    });
  }

  element.$eMObservers.add(subscription);
};

const stopObservation = (element, subscription) => {
  const $eMObservers = element.$eMObservers;

  if ($eMObservers && $eMObservers.delete(subscription)) {
    if ($eMObservers.size === 0) {
      element.$mObserver.disconnect();
      element.$mObserver = undefined;
    }

    return true;
  }

  return false;
};

const handleMutation = mutationRecords => {
  mutationRecords[0].target.$eMObservers.forEach(invokeHandleMutation, mutationRecords);
};

function invokeHandleMutation(s) {
  s.handleMutation(this);
}
});

;define.alias('@aurelia/runtime-html/observation/element-attribute-observer.js','@aurelia/runtime-html/dist/esm/observation/element-attribute-observer.js');
define('@aurelia/runtime-html/dist/esm/observation/event-delegator.js',['require','exports','module','@aurelia/kernel'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.EventDelegator = exports.IEventDelegator = exports.EventSubscriber = exports.DelegateSubscription = void 0;

var _kernel = require("@aurelia/kernel");

const defaultOptions = {
  capture: false
};

class ListenerTracker {
  constructor(publisher, eventName, options = defaultOptions) {
    this.publisher = publisher;
    this.eventName = eventName;
    this.options = options;
    this.count = 0;
    this.captureLookups = new Map();
    this.bubbleLookups = new Map();
  }

  increment() {
    if (++this.count === 1) {
      this.publisher.addEventListener(this.eventName, this, this.options);
    }
  }

  decrement() {
    if (--this.count === 0) {
      this.publisher.removeEventListener(this.eventName, this, this.options);
    }
  }

  dispose() {
    if (this.count > 0) {
      this.count = 0;
      this.publisher.removeEventListener(this.eventName, this, this.options);
    }

    this.captureLookups.clear();
    this.bubbleLookups.clear();
  }
  /** @internal */


  getLookup(target) {
    const lookups = this.options.capture === true ? this.captureLookups : this.bubbleLookups;
    let lookup = lookups.get(target);

    if (lookup === void 0) {
      lookups.set(target, lookup = Object.create(null));
    }

    return lookup;
  }
  /** @internal */


  handleEvent(event) {
    const lookups = this.options.capture === true ? this.captureLookups : this.bubbleLookups;
    const path = event.composedPath();

    if (this.options.capture === true) {
      path.reverse();
    }

    for (const target of path) {
      const lookup = lookups.get(target);

      if (lookup === void 0) {
        continue;
      }

      const listener = lookup[this.eventName];

      if (listener === void 0) {
        continue;
      }

      if (typeof listener === 'function') {
        listener(event);
      } else {
        listener.handleEvent(event);
      }

      if (event.cancelBubble === true) {
        return;
      }
    }
  }

}
/**
 * Enable dispose() pattern for `delegate` & `capture` commands
 */


class DelegateSubscription {
  constructor(tracker, lookup, eventName, callback) {
    this.tracker = tracker;
    this.lookup = lookup;
    this.eventName = eventName;
    tracker.increment();
    lookup[eventName] = callback;
  }

  dispose() {
    this.tracker.decrement();
    this.lookup[this.eventName] = void 0;
  }

}

exports.DelegateSubscription = DelegateSubscription;

class EventSubscriber {
  constructor(config) {
    this.config = config;
    this.target = null;
    this.handler = null;
  }

  subscribe(node, callbackOrListener) {
    this.target = node;
    this.handler = callbackOrListener;

    for (const event of this.config.events) {
      node.addEventListener(event, callbackOrListener);
    }
  }

  dispose() {
    const {
      target,
      handler
    } = this;

    if (target !== null && handler !== null) {
      for (const event of this.config.events) {
        target.removeEventListener(event, handler);
      }
    }

    this.target = this.handler = null;
  }

}

exports.EventSubscriber = EventSubscriber;

const IEventDelegator = _kernel.DI.createInterface('IEventDelegator', x => x.singleton(EventDelegator));

exports.IEventDelegator = IEventDelegator;

class EventDelegator {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    this.trackerMaps = Object.create(null);
  }

  addEventListener(publisher, target, eventName, listener, options) {
    var _a;

    const trackerMap = (_a = this.trackerMaps)[eventName] ?? (_a[eventName] = new Map());
    let tracker = trackerMap.get(publisher);

    if (tracker === void 0) {
      trackerMap.set(publisher, tracker = new ListenerTracker(publisher, eventName, options));
    }

    return new DelegateSubscription(tracker, tracker.getLookup(target), eventName, listener);
  }

  dispose() {
    for (const eventName in this.trackerMaps) {
      const trackerMap = this.trackerMaps[eventName];

      for (const tracker of trackerMap.values()) {
        tracker.dispose();
      }

      trackerMap.clear();
    }
  }

}

exports.EventDelegator = EventDelegator;
});

;define.alias('@aurelia/runtime-html/observation/event-delegator.js','@aurelia/runtime-html/dist/esm/observation/event-delegator.js');
define('@aurelia/runtime-html/dist/esm/observation/observer-locator.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime','../platform.js','./attribute-ns-accessor.js','./checked-observer.js','./class-attribute-accessor.js','./data-attribute-accessor.js','./event-delegator.js','./select-value-observer.js','./style-attribute-accessor.js','./svg-analyzer.js','./value-attribute-observer.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.getCollectionObserver = getCollectionObserver;
exports.NodeObserverLocator = exports.NodeObserverConfig = void 0;

var _kernel = require("@aurelia/kernel");

var _runtime = require("@aurelia/runtime");

var _platform = require("../platform.js");

var _attributeNsAccessor = require("./attribute-ns-accessor.js");

var _checkedObserver = require("./checked-observer.js");

var _classAttributeAccessor = require("./class-attribute-accessor.js");

var _dataAttributeAccessor = require("./data-attribute-accessor.js");

var _eventDelegator = require("./event-delegator.js");

var _selectValueObserver = require("./select-value-observer.js");

var _styleAttributeAccessor = require("./style-attribute-accessor.js");

var _svgAnalyzer = require("./svg-analyzer.js");

var _valueAttributeObserver = require("./value-attribute-observer.js");

// https://infra.spec.whatwg.org/#namespaces
const htmlNS = 'http://www.w3.org/1999/xhtml';
const mathmlNS = 'http://www.w3.org/1998/Math/MathML';
const svgNS = 'http://www.w3.org/2000/svg';
const xlinkNS = 'http://www.w3.org/1999/xlink';
const xmlNS = 'http://www.w3.org/XML/1998/namespace';
const xmlnsNS = 'http://www.w3.org/2000/xmlns/'; // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2

const nsAttributes = Object.assign(createLookup(), {
  'xlink:actuate': ['actuate', xlinkNS],
  'xlink:arcrole': ['arcrole', xlinkNS],
  'xlink:href': ['href', xlinkNS],
  'xlink:role': ['role', xlinkNS],
  'xlink:show': ['show', xlinkNS],
  'xlink:title': ['title', xlinkNS],
  'xlink:type': ['type', xlinkNS],
  'xml:lang': ['lang', xmlNS],
  'xml:space': ['space', xmlNS],
  'xmlns': ['xmlns', xmlnsNS],
  'xmlns:xlink': ['xlink', xmlnsNS]
});
const elementPropertyAccessor = new _runtime.PropertyAccessor();
elementPropertyAccessor.type = 2
/* Node */
| 4
/* Layout */
;

class NodeObserverConfig {
  constructor(config) {
    this.type = config.type ?? _valueAttributeObserver.ValueAttributeObserver;
    this.events = config.events;
    this.readonly = config.readonly;
    this.default = config.default;
  }

}

exports.NodeObserverConfig = NodeObserverConfig;

class NodeObserverLocator {
  constructor(locator, platform, dirtyChecker, svgAnalyzer) {
    this.locator = locator;
    this.platform = platform;
    this.dirtyChecker = dirtyChecker;
    this.svgAnalyzer = svgAnalyzer;
    this.allowDirtyCheck = true;
    this.events = createLookup();
    this.globalEvents = createLookup();
    this.overrides = createLookup();
    this.globalOverrides = createLookup(); // todo: atm, platform is required to be resolved too eagerly for the `.handles()` check
    // also a lot of tests assume default availability of observation
    // those 2 assumptions make it not the right time to extract the following line into a
    // default configuration for NodeObserverLocator yet
    // but in the future, they should be, so apps that don't use check box/select, or implement a different
    // observer don't have to pay the of the default implementation

    const inputEvents = ['change', 'input'];
    const inputEventsConfig = {
      events: inputEvents,
      default: ''
    };
    this.useConfig({
      INPUT: {
        value: inputEventsConfig,
        checked: {
          type: _checkedObserver.CheckedObserver,
          events: inputEvents
        },
        files: {
          events: inputEvents,
          readonly: true
        }
      },
      SELECT: {
        value: {
          type: _selectValueObserver.SelectValueObserver,
          events: ['change'],
          default: ''
        }
      },
      TEXTAREA: {
        value: inputEventsConfig
      }
    });
    const contentEventsConfig = {
      events: ['change', 'input', 'blur', 'keyup', 'paste'],
      default: ''
    };
    const scrollEventsConfig = {
      events: ['scroll'],
      default: 0
    };
    this.useConfigGlobal({
      scrollTop: scrollEventsConfig,
      scrollLeft: scrollEventsConfig,
      textContent: contentEventsConfig,
      innerHTML: contentEventsConfig
    });
    this.overrideAccessorGlobal('css', 'style', 'class');
    this.overrideAccessor({
      INPUT: ['value', 'checked', 'model'],
      SELECT: ['value'],
      TEXTAREA: ['value']
    });
  }

  static register(container) {
    _kernel.Registration.aliasTo(_runtime.INodeObserverLocator, NodeObserverLocator).register(container);

    _kernel.Registration.singleton(_runtime.INodeObserverLocator, NodeObserverLocator).register(container);
  } // deepscan-disable-next-line


  handles(obj, _key) {
    return obj instanceof this.platform.Node;
  }

  useConfig(nodeNameOrConfig, key, eventsConfig) {
    const lookup = this.events;
    let existingMapping;

    if (typeof nodeNameOrConfig === 'string') {
      existingMapping = lookup[nodeNameOrConfig] ?? (lookup[nodeNameOrConfig] = createLookup());

      if (existingMapping[key] == null) {
        existingMapping[key] = new NodeObserverConfig(eventsConfig);
      } else {
        throwMappingExisted(nodeNameOrConfig, key);
      }
    } else {
      for (const nodeName in nodeNameOrConfig) {
        existingMapping = lookup[nodeName] ?? (lookup[nodeName] = createLookup());
        const newMapping = nodeNameOrConfig[nodeName];

        for (key in newMapping) {
          if (existingMapping[key] == null) {
            existingMapping[key] = new NodeObserverConfig(newMapping[key]);
          } else {
            throwMappingExisted(nodeName, key);
          }
        }
      }
    }
  }

  useConfigGlobal(configOrKey, eventsConfig) {
    const lookup = this.globalEvents;

    if (typeof configOrKey === 'object') {
      for (const key in configOrKey) {
        if (lookup[key] == null) {
          lookup[key] = new NodeObserverConfig(configOrKey[key]);
        } else {
          throwMappingExisted('*', key);
        }
      }
    } else {
      if (lookup[configOrKey] == null) {
        lookup[configOrKey] = new NodeObserverConfig(eventsConfig);
      } else {
        throwMappingExisted('*', configOrKey);
      }
    }
  } // deepscan-disable-nextline


  getAccessor(obj, key, requestor) {
    if (key in this.globalOverrides || key in (this.overrides[obj.tagName] ?? _kernel.emptyObject)) {
      return this.getObserver(obj, key, requestor);
    }

    switch (key) {
      // class / style / css attribute will be observed using .getObserver() per overrides
      //
      // TODO: there are (many) more situation where we want to default to DataAttributeAccessor,
      // but for now stick to what vCurrent does
      case 'src':
      case 'href': // https://html.spec.whatwg.org/multipage/dom.html#wai-aria

      case 'role':
        return _dataAttributeAccessor.attrAccessor;

      default:
        {
          const nsProps = nsAttributes[key];

          if (nsProps !== undefined) {
            return _attributeNsAccessor.AttributeNSAccessor.forNs(nsProps[1]);
          }

          if (isDataAttribute(obj, key, this.svgAnalyzer)) {
            return _dataAttributeAccessor.attrAccessor;
          }

          return elementPropertyAccessor;
        }
    }
  }

  overrideAccessor(tagNameOrOverrides, key) {
    var _a, _b;

    let existingTagOverride;

    if (typeof tagNameOrOverrides === 'string') {
      existingTagOverride = (_a = this.overrides)[tagNameOrOverrides] ?? (_a[tagNameOrOverrides] = createLookup());
      existingTagOverride[key] = true;
    } else {
      for (const tagName in tagNameOrOverrides) {
        for (const key of tagNameOrOverrides[tagName]) {
          existingTagOverride = (_b = this.overrides)[tagName] ?? (_b[tagName] = createLookup());
          existingTagOverride[key] = true;
        }
      }
    }
  }
  /**
   * For all elements:
   * compose a list of properties,
   * to indicate that an overser should be returned instead of an accessor in `.getAccessor()`
   */


  overrideAccessorGlobal(...keys) {
    for (const key of keys) {
      this.globalOverrides[key] = true;
    }
  }

  getObserver(el, key, requestor) {
    switch (key) {
      case 'role':
        return _dataAttributeAccessor.attrAccessor;

      case 'class':
        return new _classAttributeAccessor.ClassAttributeAccessor(el);

      case 'css':
      case 'style':
        return new _styleAttributeAccessor.StyleAttributeAccessor(el);
    }

    const eventsConfig = this.events[el.tagName]?.[key] ?? this.globalEvents[key];

    if (eventsConfig != null) {
      return new eventsConfig.type(el, key, new _eventDelegator.EventSubscriber(eventsConfig), requestor, this.locator);
    }

    const nsProps = nsAttributes[key];

    if (nsProps !== undefined) {
      return _attributeNsAccessor.AttributeNSAccessor.forNs(nsProps[1]);
    }

    if (isDataAttribute(el, key, this.svgAnalyzer)) {
      // todo: should observe
      return _dataAttributeAccessor.attrAccessor;
    }

    if (key in el.constructor.prototype) {
      if (this.allowDirtyCheck) {
        return this.dirtyChecker.createProperty(el, key);
      } // consider:
      // - maybe add a adapter API to handle unknown obj/key combo


      throw new Error(`Unable to observe property ${String(key)}. Register observation mapping with .useConfig().`);
    } else {
      // todo: probably still needs to get the property descriptor via getOwnPropertyDescriptor
      // but let's start with simplest scenario
      return new _runtime.SetterObserver(el, key);
    }
  }

}

exports.NodeObserverLocator = NodeObserverLocator;
NodeObserverLocator.inject = [_kernel.IServiceLocator, _platform.IPlatform, _runtime.IDirtyChecker, _svgAnalyzer.ISVGAnalyzer];

function getCollectionObserver(collection, observerLocator) {
  if (collection instanceof Array) {
    return observerLocator.getArrayObserver(collection);
  }

  if (collection instanceof Map) {
    return observerLocator.getMapObserver(collection);
  }

  if (collection instanceof Set) {
    return observerLocator.getSetObserver(collection);
  }
}

function throwMappingExisted(nodeName, key) {
  throw new Error(`Mapping for property ${String(key)} of <${nodeName} /> already exists`);
}

const IsDataAttribute = createLookup();

function isDataAttribute(obj, key, svgAnalyzer) {
  if (IsDataAttribute[key] === true) {
    return true;
  }

  if (typeof key !== 'string') {
    return false;
  }

  const prefix = key.slice(0, 5); // https://html.spec.whatwg.org/multipage/dom.html#wai-aria
  // https://html.spec.whatwg.org/multipage/dom.html#custom-data-attribute

  return IsDataAttribute[key] = prefix === 'aria-' || prefix === 'data-' || svgAnalyzer.isStandardSvgAttribute(obj, key);
}

function createLookup() {
  return Object.create(null);
}
});

;define.alias('@aurelia/runtime-html/observation/observer-locator.js','@aurelia/runtime-html/dist/esm/observation/observer-locator.js');
define('@aurelia/runtime-html/dist/esm/observation/select-value-observer.js',['require','exports','module','@aurelia/runtime'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.SelectValueObserver = void 0;

var _runtime = require("@aurelia/runtime");

const hasOwn = Object.prototype.hasOwnProperty;
const childObserverOptions = {
  childList: true,
  subtree: true,
  characterData: true
};

function defaultMatcher(a, b) {
  return a === b;
}

class SelectValueObserver {
  constructor(obj, // deepscan-disable-next-line
  _key, handler, observerLocator) {
    this.handler = handler;
    this.observerLocator = observerLocator;
    this.currentValue = void 0;
    this.oldValue = void 0;
    this.hasChanges = false; // ObserverType.Layout is not always true
    // but for simplicity, always treat as such

    this.type = 2
    /* Node */
    | 1
    /* Observer */
    | 4
    /* Layout */
    ;
    this.arrayObserver = void 0;
    this.nodeObserver = void 0;
    this.observing = false;
    this.obj = obj;
  }

  getValue() {
    // is it safe to assume the observer has the latest value?
    // todo: ability to turn on/off cache based on type
    return this.observing ? this.currentValue : this.obj.multiple ? Array.from(this.obj.options).map(o => o.value) : this.obj.value;
  }

  setValue(newValue, flags) {
    this.currentValue = newValue;
    this.hasChanges = newValue !== this.oldValue;
    this.observeArray(newValue instanceof Array ? newValue : null);

    if ((flags & 4096
    /* noFlush */
    ) === 0) {
      this.flushChanges(flags);
    }
  }

  flushChanges(flags) {
    if (this.hasChanges) {
      this.hasChanges = false;
      this.synchronizeOptions();
    }
  }

  handleCollectionChange() {
    // always sync "selected" property of <options/>
    // immediately whenever the array notifies its mutation
    this.synchronizeOptions();
  }

  notify(flags) {
    if ((flags & 32
    /* fromBind */
    ) > 0) {
      return;
    }

    const oldValue = this.oldValue;
    const newValue = this.currentValue;

    if (newValue === oldValue) {
      return;
    }

    this.subs.notify(newValue, oldValue, flags);
  }

  handleEvent() {
    const shouldNotify = this.synchronizeValue();

    if (shouldNotify) {
      this.subs.notify(this.currentValue, this.oldValue, 0
      /* none */
      );
    }
  }

  synchronizeOptions(indexMap) {
    const {
      currentValue,
      obj
    } = this;
    const isArray = Array.isArray(currentValue);
    const matcher = obj.matcher !== void 0 ? obj.matcher : defaultMatcher;
    const options = obj.options;
    let i = options.length;

    while (i-- > 0) {
      const option = options[i];
      const optionValue = hasOwn.call(option, 'model') ? option.model : option.value;

      if (isArray) {
        option.selected = currentValue.findIndex(item => !!matcher(optionValue, item)) !== -1;
        continue;
      }

      option.selected = !!matcher(optionValue, currentValue);
    }
  }

  synchronizeValue() {
    // Spec for synchronizing value from `<select/>`  to `SelectObserver`
    // When synchronizing value to observed <select/> element, do the following steps:
    // A. If `<select/>` is multiple
    //    1. Check if current value, called `currentValue` is an array
    //      a. If not an array, return true to signal value has changed
    //      b. If is an array:
    //        i. gather all current selected <option/>, in to array called `values`
    //        ii. loop through the `currentValue` array and remove items that are nolonger selected based on matcher
    //        iii. loop through the `values` array and add items that are selected based on matcher
    //        iv. Return false to signal value hasn't changed
    // B. If the select is single
    //    1. Let `value` equal the first selected option, if no option selected, then `value` is `null`
    //    2. assign `this.currentValue` to `this.oldValue`
    //    3. assign `value` to `this.currentValue`
    //    4. return `true` to signal value has changed
    const obj = this.obj;
    const options = obj.options;
    const len = options.length;
    const currentValue = this.currentValue;
    let i = 0;

    if (obj.multiple) {
      // A.
      if (!(currentValue instanceof Array)) {
        // A.1.a
        return true;
      } // A.1.b
      // multi select


      let option;
      const matcher = obj.matcher || defaultMatcher; // A.1.b.i

      const values = [];

      while (i < len) {
        option = options[i];

        if (option.selected) {
          values.push(hasOwn.call(option, 'model') ? option.model : option.value);
        }

        ++i;
      } // A.1.b.ii


      i = 0;

      while (i < currentValue.length) {
        const a = currentValue[i]; // Todo: remove arrow fn

        if (values.findIndex(b => !!matcher(a, b)) === -1) {
          currentValue.splice(i, 1);
        } else {
          ++i;
        }
      } // A.1.b.iii


      i = 0;

      while (i < values.length) {
        const a = values[i]; // Todo: remove arrow fn

        if (currentValue.findIndex(b => !!matcher(a, b)) === -1) {
          currentValue.push(a);
        }

        ++i;
      } // A.1.b.iv


      return false;
    } // B. single select
    // B.1


    let value = null;

    while (i < len) {
      const option = options[i];

      if (option.selected) {
        value = hasOwn.call(option, 'model') ? option.model : option.value;
        break;
      }

      ++i;
    } // B.2


    this.oldValue = this.currentValue; // B.3

    this.currentValue = value; // B.4

    return true;
  }

  start() {
    (this.nodeObserver = new this.obj.ownerDocument.defaultView.MutationObserver(this.handleNodeChange.bind(this))).observe(this.obj, childObserverOptions);
    this.observeArray(this.currentValue instanceof Array ? this.currentValue : null);
    this.observing = true;
  }

  stop() {
    this.nodeObserver.disconnect();
    this.arrayObserver?.unsubscribe(this);
    this.nodeObserver = this.arrayObserver = void 0;
    this.observing = false;
  } // todo: observe all kind of collection


  observeArray(array) {
    this.arrayObserver?.unsubscribe(this);
    this.arrayObserver = void 0;

    if (array != null) {
      if (!this.obj.multiple) {
        throw new Error('Only null or Array instances can be bound to a multi-select.');
      }

      (this.arrayObserver = this.observerLocator.getArrayObserver(array)).subscribe(this);
    }
  }

  handleNodeChange() {
    this.synchronizeOptions();
    const shouldNotify = this.synchronizeValue();

    if (shouldNotify) {
      this.notify(0
      /* none */
      );
    }
  }

  subscribe(subscriber) {
    if (this.subs.add(subscriber) && this.subs.count === 1) {
      this.handler.subscribe(this.obj, this);
      this.start();
    }
  }

  unsubscribe(subscriber) {
    if (this.subs.remove(subscriber) && this.subs.count === 0) {
      this.handler.dispose();
      this.stop();
    }
  }

}

exports.SelectValueObserver = SelectValueObserver;
(0, _runtime.subscriberCollection)(SelectValueObserver);
});

;define.alias('@aurelia/runtime-html/observation/select-value-observer.js','@aurelia/runtime-html/dist/esm/observation/select-value-observer.js');
define('@aurelia/runtime-html/dist/esm/observation/style-attribute-accessor.js',['require','exports','module','@aurelia/kernel'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.StyleAttributeAccessor = void 0;

var _kernel = require("@aurelia/kernel");

const customPropertyPrefix = '--';

class StyleAttributeAccessor {
  constructor(obj) {
    this.obj = obj;
    this.currentValue = '';
    this.oldValue = '';
    this.styles = {};
    this.version = 0;
    this.hasChanges = false;
    this.type = 2
    /* Node */
    | 4
    /* Layout */
    ;
  }

  getValue() {
    return this.obj.style.cssText;
  }

  setValue(newValue, flags) {
    this.currentValue = newValue;
    this.hasChanges = newValue !== this.oldValue;

    if ((flags & 4096
    /* noFlush */
    ) === 0) {
      this.flushChanges(flags);
    }
  }

  getStyleTuplesFromString(currentValue) {
    const styleTuples = [];
    const urlRegexTester = /url\([^)]+$/;
    let offset = 0;
    let currentChunk = '';
    let nextSplit;
    let indexOfColon;
    let attribute;
    let value;

    while (offset < currentValue.length) {
      nextSplit = currentValue.indexOf(';', offset);

      if (nextSplit === -1) {
        nextSplit = currentValue.length;
      }

      currentChunk += currentValue.substring(offset, nextSplit);
      offset = nextSplit + 1; // Make sure we never split a url so advance to next

      if (urlRegexTester.test(currentChunk)) {
        currentChunk += ';';
        continue;
      }

      indexOfColon = currentChunk.indexOf(':');
      attribute = currentChunk.substring(0, indexOfColon).trim();
      value = currentChunk.substring(indexOfColon + 1).trim();
      styleTuples.push([attribute, value]);
      currentChunk = '';
    }

    return styleTuples;
  }

  getStyleTuplesFromObject(currentValue) {
    let value;
    const styles = [];

    for (const property in currentValue) {
      value = currentValue[property];

      if (value == null) {
        continue;
      }

      if (typeof value === 'string') {
        // Custom properties should not be tampered with
        if (property.startsWith(customPropertyPrefix)) {
          styles.push([property, value]);
          continue;
        }

        styles.push([(0, _kernel.kebabCase)(property), value]);
        continue;
      }

      styles.push(...this.getStyleTuples(value));
    }

    return styles;
  }

  getStyleTuplesFromArray(currentValue) {
    const len = currentValue.length;

    if (len > 0) {
      const styles = [];

      for (let i = 0; i < len; ++i) {
        styles.push(...this.getStyleTuples(currentValue[i]));
      }

      return styles;
    }

    return _kernel.emptyArray;
  }

  getStyleTuples(currentValue) {
    if (typeof currentValue === 'string') {
      return this.getStyleTuplesFromString(currentValue);
    }

    if (currentValue instanceof Array) {
      return this.getStyleTuplesFromArray(currentValue);
    }

    if (currentValue instanceof Object) {
      return this.getStyleTuplesFromObject(currentValue);
    }

    return _kernel.emptyArray;
  }

  flushChanges(flags) {
    if (this.hasChanges) {
      this.hasChanges = false;
      const currentValue = this.currentValue;
      const styles = this.styles;
      const styleTuples = this.getStyleTuples(currentValue);
      let style;
      let version = this.version;
      this.oldValue = currentValue;
      let tuple;
      let name;
      let value;
      const len = styleTuples.length;

      for (let i = 0; i < len; ++i) {
        tuple = styleTuples[i];
        name = tuple[0];
        value = tuple[1];
        this.setProperty(name, value);
        styles[name] = version;
      }

      this.styles = styles;
      this.version += 1;

      if (version === 0) {
        return;
      }

      version -= 1;

      for (style in styles) {
        if (!Object.prototype.hasOwnProperty.call(styles, style) || styles[style] !== version) {
          continue;
        }

        this.obj.style.removeProperty(style);
      }
    }
  }

  setProperty(style, value) {
    let priority = '';

    if (value != null && typeof value.indexOf === 'function' && value.includes('!important')) {
      priority = 'important';
      value = value.replace('!important', '');
    }

    this.obj.style.setProperty(style, value, priority);
  }

  bind(flags) {
    this.currentValue = this.oldValue = this.obj.style.cssText;
  }

}

exports.StyleAttributeAccessor = StyleAttributeAccessor;
});

;define.alias('@aurelia/runtime-html/observation/style-attribute-accessor.js','@aurelia/runtime-html/dist/esm/observation/style-attribute-accessor.js');
define('@aurelia/runtime-html/dist/esm/observation/svg-analyzer.js',['require','exports','module','@aurelia/kernel','../platform.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.SVGAnalyzer = exports.NoopSVGAnalyzer = exports.ISVGAnalyzer = void 0;

var _kernel = require("@aurelia/kernel");

var _platform = require("../platform.js");

const ISVGAnalyzer = _kernel.DI.createInterface('ISVGAnalyzer', x => x.singleton(NoopSVGAnalyzer));

exports.ISVGAnalyzer = ISVGAnalyzer;

class NoopSVGAnalyzer {
  isStandardSvgAttribute(node, attributeName) {
    return false;
  }

}

exports.NoopSVGAnalyzer = NoopSVGAnalyzer;

function o(keys) {
  const lookup = Object.create(null);

  for (const key of keys) {
    lookup[key] = true;
  }

  return lookup;
}

class SVGAnalyzer {
  constructor(platform) {
    this.svgElements = Object.assign(Object.create(null), {
      'a': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'target', 'transform', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
      'altGlyph': o(['class', 'dx', 'dy', 'externalResourcesRequired', 'format', 'glyphRef', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'altglyph': Object.create(null),
      'altGlyphDef': o(['id', 'xml:base', 'xml:lang', 'xml:space']),
      'altglyphdef': Object.create(null),
      'altGlyphItem': o(['id', 'xml:base', 'xml:lang', 'xml:space']),
      'altglyphitem': Object.create(null),
      'animate': o(['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
      'animateColor': o(['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
      'animateMotion': o(['accumulate', 'additive', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keyPoints', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'origin', 'path', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'rotate', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
      'animateTransform': o(['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'type', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
      'circle': o(['class', 'cx', 'cy', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'r', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
      'clipPath': o(['class', 'clipPathUnits', 'externalResourcesRequired', 'id', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
      'color-profile': o(['id', 'local', 'name', 'rendering-intent', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
      'cursor': o(['externalResourcesRequired', 'id', 'requiredExtensions', 'requiredFeatures', 'systemLanguage', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'defs': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
      'desc': o(['class', 'id', 'style', 'xml:base', 'xml:lang', 'xml:space']),
      'ellipse': o(['class', 'cx', 'cy', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rx', 'ry', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
      'feBlend': o(['class', 'height', 'id', 'in', 'in2', 'mode', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'feColorMatrix': o(['class', 'height', 'id', 'in', 'result', 'style', 'type', 'values', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'feComponentTransfer': o(['class', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'feComposite': o(['class', 'height', 'id', 'in', 'in2', 'k1', 'k2', 'k3', 'k4', 'operator', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'feConvolveMatrix': o(['bias', 'class', 'divisor', 'edgeMode', 'height', 'id', 'in', 'kernelMatrix', 'kernelUnitLength', 'order', 'preserveAlpha', 'result', 'style', 'targetX', 'targetY', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'feDiffuseLighting': o(['class', 'diffuseConstant', 'height', 'id', 'in', 'kernelUnitLength', 'result', 'style', 'surfaceScale', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'feDisplacementMap': o(['class', 'height', 'id', 'in', 'in2', 'result', 'scale', 'style', 'width', 'x', 'xChannelSelector', 'xml:base', 'xml:lang', 'xml:space', 'y', 'yChannelSelector']),
      'feDistantLight': o(['azimuth', 'elevation', 'id', 'xml:base', 'xml:lang', 'xml:space']),
      'feFlood': o(['class', 'height', 'id', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'feFuncA': o(['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space']),
      'feFuncB': o(['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space']),
      'feFuncG': o(['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space']),
      'feFuncR': o(['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space']),
      'feGaussianBlur': o(['class', 'height', 'id', 'in', 'result', 'stdDeviation', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'feImage': o(['class', 'externalResourcesRequired', 'height', 'id', 'preserveAspectRatio', 'result', 'style', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'feMerge': o(['class', 'height', 'id', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'feMergeNode': o(['id', 'xml:base', 'xml:lang', 'xml:space']),
      'feMorphology': o(['class', 'height', 'id', 'in', 'operator', 'radius', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'feOffset': o(['class', 'dx', 'dy', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'fePointLight': o(['id', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'z']),
      'feSpecularLighting': o(['class', 'height', 'id', 'in', 'kernelUnitLength', 'result', 'specularConstant', 'specularExponent', 'style', 'surfaceScale', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'feSpotLight': o(['id', 'limitingConeAngle', 'pointsAtX', 'pointsAtY', 'pointsAtZ', 'specularExponent', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'z']),
      'feTile': o(['class', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'feTurbulence': o(['baseFrequency', 'class', 'height', 'id', 'numOctaves', 'result', 'seed', 'stitchTiles', 'style', 'type', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'filter': o(['class', 'externalResourcesRequired', 'filterRes', 'filterUnits', 'height', 'id', 'primitiveUnits', 'style', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'font': o(['class', 'externalResourcesRequired', 'horiz-adv-x', 'horiz-origin-x', 'horiz-origin-y', 'id', 'style', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space']),
      'font-face': o(['accent-height', 'alphabetic', 'ascent', 'bbox', 'cap-height', 'descent', 'font-family', 'font-size', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'hanging', 'id', 'ideographic', 'mathematical', 'overline-position', 'overline-thickness', 'panose-1', 'slope', 'stemh', 'stemv', 'strikethrough-position', 'strikethrough-thickness', 'underline-position', 'underline-thickness', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'widths', 'x-height', 'xml:base', 'xml:lang', 'xml:space']),
      'font-face-format': o(['id', 'string', 'xml:base', 'xml:lang', 'xml:space']),
      'font-face-name': o(['id', 'name', 'xml:base', 'xml:lang', 'xml:space']),
      'font-face-src': o(['id', 'xml:base', 'xml:lang', 'xml:space']),
      'font-face-uri': o(['id', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
      'foreignObject': o(['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'g': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
      'glyph': o(['arabic-form', 'class', 'd', 'glyph-name', 'horiz-adv-x', 'id', 'lang', 'orientation', 'style', 'unicode', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space']),
      'glyphRef': o(['class', 'dx', 'dy', 'format', 'glyphRef', 'id', 'style', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'glyphref': Object.create(null),
      'hkern': o(['g1', 'g2', 'id', 'k', 'u1', 'u2', 'xml:base', 'xml:lang', 'xml:space']),
      'image': o(['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'line': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'x1', 'x2', 'xml:base', 'xml:lang', 'xml:space', 'y1', 'y2']),
      'linearGradient': o(['class', 'externalResourcesRequired', 'gradientTransform', 'gradientUnits', 'id', 'spreadMethod', 'style', 'x1', 'x2', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y1', 'y2']),
      'marker': o(['class', 'externalResourcesRequired', 'id', 'markerHeight', 'markerUnits', 'markerWidth', 'orient', 'preserveAspectRatio', 'refX', 'refY', 'style', 'viewBox', 'xml:base', 'xml:lang', 'xml:space']),
      'mask': o(['class', 'externalResourcesRequired', 'height', 'id', 'maskContentUnits', 'maskUnits', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'metadata': o(['id', 'xml:base', 'xml:lang', 'xml:space']),
      'missing-glyph': o(['class', 'd', 'horiz-adv-x', 'id', 'style', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space']),
      'mpath': o(['externalResourcesRequired', 'id', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
      'path': o(['class', 'd', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'pathLength', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
      'pattern': o(['class', 'externalResourcesRequired', 'height', 'id', 'patternContentUnits', 'patternTransform', 'patternUnits', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'viewBox', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'polygon': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'points', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
      'polyline': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'points', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
      'radialGradient': o(['class', 'cx', 'cy', 'externalResourcesRequired', 'fx', 'fy', 'gradientTransform', 'gradientUnits', 'id', 'r', 'spreadMethod', 'style', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
      'rect': o(['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rx', 'ry', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'script': o(['externalResourcesRequired', 'id', 'type', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
      'set': o(['attributeName', 'attributeType', 'begin', 'dur', 'end', 'externalResourcesRequired', 'fill', 'id', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
      'stop': o(['class', 'id', 'offset', 'style', 'xml:base', 'xml:lang', 'xml:space']),
      'style': o(['id', 'media', 'title', 'type', 'xml:base', 'xml:lang', 'xml:space']),
      'svg': o(['baseProfile', 'class', 'contentScriptType', 'contentStyleType', 'externalResourcesRequired', 'height', 'id', 'onabort', 'onactivate', 'onclick', 'onerror', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onresize', 'onscroll', 'onunload', 'onzoom', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'version', 'viewBox', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'zoomAndPan']),
      'switch': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
      'symbol': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'preserveAspectRatio', 'style', 'viewBox', 'xml:base', 'xml:lang', 'xml:space']),
      'text': o(['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'transform', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'textPath': o(['class', 'externalResourcesRequired', 'id', 'lengthAdjust', 'method', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'spacing', 'startOffset', 'style', 'systemLanguage', 'textLength', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
      'title': o(['class', 'id', 'style', 'xml:base', 'xml:lang', 'xml:space']),
      'tref': o(['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'x', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'tspan': o(['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'use': o(['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
      'view': o(['externalResourcesRequired', 'id', 'preserveAspectRatio', 'viewBox', 'viewTarget', 'xml:base', 'xml:lang', 'xml:space', 'zoomAndPan']),
      'vkern': o(['g1', 'g2', 'id', 'k', 'u1', 'u2', 'xml:base', 'xml:lang', 'xml:space'])
    });
    this.svgPresentationElements = o(['a', 'altGlyph', 'animate', 'animateColor', 'circle', 'clipPath', 'defs', 'ellipse', 'feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feFlood', 'feGaussianBlur', 'feImage', 'feMerge', 'feMorphology', 'feOffset', 'feSpecularLighting', 'feTile', 'feTurbulence', 'filter', 'font', 'foreignObject', 'g', 'glyph', 'glyphRef', 'image', 'line', 'linearGradient', 'marker', 'mask', 'missing-glyph', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'switch', 'symbol', 'text', 'textPath', 'tref', 'tspan', 'use']);
    this.svgPresentationAttributes = o(['alignment-baseline', 'baseline-shift', 'clip-path', 'clip-rule', 'clip', 'color-interpolation-filters', 'color-interpolation', 'color-profile', 'color-rendering', 'color', 'cursor', 'direction', 'display', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'fill', 'filter', 'flood-color', 'flood-opacity', 'font-family', 'font-size-adjust', 'font-size', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'image-rendering', 'kerning', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'mask', 'opacity', 'overflow', 'pointer-events', 'shape-rendering', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'stroke', 'text-anchor', 'text-decoration', 'text-rendering', 'unicode-bidi', 'visibility', 'word-spacing', 'writing-mode']);
    this.SVGElement = platform.globalThis.SVGElement;
    const div = platform.document.createElement('div');
    div.innerHTML = '<svg><altGlyph /></svg>';

    if (div.firstElementChild.nodeName === 'altglyph') {
      // handle chrome casing inconsistencies.
      const svg = this.svgElements;
      let tmp = svg.altGlyph;
      svg.altGlyph = svg.altglyph;
      svg.altglyph = tmp;
      tmp = svg.altGlyphDef;
      svg.altGlyphDef = svg.altglyphdef;
      svg.altglyphdef = tmp;
      tmp = svg.altGlyphItem;
      svg.altGlyphItem = svg.altglyphitem;
      svg.altglyphitem = tmp;
      tmp = svg.glyphRef;
      svg.glyphRef = svg.glyphref;
      svg.glyphref = tmp;
    }
  }

  static register(container) {
    return _kernel.Registration.singleton(ISVGAnalyzer, this).register(container);
  }

  isStandardSvgAttribute(node, attributeName) {
    if (!(node instanceof this.SVGElement)) {
      return false;
    }

    return this.svgPresentationElements[node.nodeName] === true && this.svgPresentationAttributes[attributeName] === true || this.svgElements[node.nodeName]?.[attributeName] === true;
  }

}
/**
 * @internal
 */


exports.SVGAnalyzer = SVGAnalyzer;
SVGAnalyzer.inject = [_platform.IPlatform];
});

;define.alias('@aurelia/runtime-html/observation/svg-analyzer.js','@aurelia/runtime-html/dist/esm/observation/svg-analyzer.js');
define('@aurelia/runtime-html/dist/esm/observation/value-attribute-observer.js',['require','exports','module','@aurelia/runtime'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.ValueAttributeObserver = void 0;

var _runtime = require("@aurelia/runtime");

/**
 * Observer for non-radio, non-checkbox input.
 */
class ValueAttributeObserver {
  constructor(obj, propertyKey, handler) {
    this.propertyKey = propertyKey;
    this.handler = handler;
    this.currentValue = '';
    this.oldValue = '';
    this.hasChanges = false; // ObserverType.Layout is not always true, it depends on the element & property combo
    // but for simplicity, always treat as such

    this.type = 2
    /* Node */
    | 1
    /* Observer */
    | 4
    /* Layout */
    ;
    this.obj = obj;
  }

  getValue() {
    // is it safe to assume the observer has the latest value?
    // todo: ability to turn on/off cache based on type
    return this.currentValue;
  }

  setValue(newValue, flags) {
    this.currentValue = newValue;
    this.hasChanges = newValue !== this.oldValue;

    if (!this.handler.config.readonly && (flags & 4096
    /* noFlush */
    ) === 0) {
      this.flushChanges(flags);
    }
  }

  flushChanges(flags) {
    if (this.hasChanges) {
      this.hasChanges = false;
      const currentValue = this.currentValue;
      const oldValue = this.oldValue;
      this.oldValue = currentValue;
      this.obj[this.propertyKey] = currentValue ?? this.handler.config.default;

      if ((flags & 32
      /* fromBind */
      ) === 0) {
        this.subs.notify(currentValue, oldValue, flags);
      }
    }
  }

  handleEvent() {
    const oldValue = this.oldValue = this.currentValue;
    const currentValue = this.currentValue = this.obj[this.propertyKey];

    if (oldValue !== currentValue) {
      this.oldValue = currentValue;
      this.subs.notify(currentValue, oldValue, 0
      /* none */
      );
    }
  }

  subscribe(subscriber) {
    if (this.subs.add(subscriber) && this.subs.count === 1) {
      this.handler.subscribe(this.obj, this);
      this.currentValue = this.oldValue = this.obj[this.propertyKey];
    }
  }

  unsubscribe(subscriber) {
    if (this.subs.remove(subscriber) && this.subs.count === 0) {
      this.handler.dispose();
    }
  }

}

exports.ValueAttributeObserver = ValueAttributeObserver;
(0, _runtime.subscriberCollection)(ValueAttributeObserver);
});

;define.alias('@aurelia/runtime-html/observation/value-attribute-observer.js','@aurelia/runtime-html/dist/esm/observation/value-attribute-observer.js');
define('@aurelia/runtime-html/dist/esm/platform.js',['require','exports','module','@aurelia/kernel'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.IPlatform = void 0;

var _kernel = require("@aurelia/kernel");

const IPlatform = _kernel.IPlatform;
exports.IPlatform = IPlatform;
});

;define.alias('@aurelia/runtime-html/platform.js','@aurelia/runtime-html/dist/esm/platform.js');
define('@aurelia/runtime-html/dist/esm/renderer.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime','./binding/call-binding.js','./binding/attribute.js','./binding/interpolation-binding.js','./binding/let-binding.js','./binding/property-binding.js','./binding/ref-binding.js','./binding/listener.js','./observation/event-delegator.js','./resources/custom-element.js','./templating/render-context.js','./resources/custom-attribute.js','./dom.js','./templating/controller.js','./platform.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.isInstruction = isInstruction;
exports.renderer = renderer;
exports.applyBindingBehavior = applyBindingBehavior;
exports.AttributeBindingRenderer = exports.StylePropertyBindingRenderer = exports.SetStyleAttributeRenderer = exports.SetClassAttributeRenderer = exports.SetAttributeRenderer = exports.ListenerBindingRenderer = exports.TextBindingRenderer = exports.IteratorBindingRenderer = exports.PropertyBindingRenderer = exports.InterpolationBindingRenderer = exports.RefBindingRenderer = exports.CallBindingRenderer = exports.LetElementRenderer = exports.TemplateControllerRenderer = exports.CustomAttributeRenderer = exports.CustomElementRenderer = exports.SetPropertyRenderer = exports.IRenderer = exports.ITemplateCompiler = exports.AttributeBindingInstruction = exports.SetStyleAttributeInstruction = exports.SetClassAttributeInstruction = exports.SetAttributeInstruction = exports.StylePropertyBindingInstruction = exports.ListenerBindingInstruction = exports.TextBindingInstruction = exports.LetBindingInstruction = exports.HydrateLetElementInstruction = exports.HydrateTemplateController = exports.HydrateAttributeInstruction = exports.HydrateElementInstruction = exports.SetPropertyInstruction = exports.RefBindingInstruction = exports.CallBindingInstruction = exports.IteratorBindingInstruction = exports.PropertyBindingInstruction = exports.InterpolationInstruction = exports.IInstruction = exports.InstructionType = void 0;

var _kernel = require("@aurelia/kernel");

var _runtime = require("@aurelia/runtime");

var _callBinding = require("./binding/call-binding.js");

var _attribute = require("./binding/attribute.js");

var _interpolationBinding = require("./binding/interpolation-binding.js");

var _letBinding = require("./binding/let-binding.js");

var _propertyBinding = require("./binding/property-binding.js");

var _refBinding = require("./binding/ref-binding.js");

var _listener = require("./binding/listener.js");

var _eventDelegator = require("./observation/event-delegator.js");

var _customElement = require("./resources/custom-element.js");

var _renderContext = require("./templating/render-context.js");

var _customAttribute = require("./resources/custom-attribute.js");

var _dom = require("./dom.js");

var _controller = require("./templating/controller.js");

var _platform = require("./platform.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

var InstructionType;
exports.InstructionType = InstructionType;

(function (InstructionType) {
  InstructionType["hydrateElement"] = "ra";
  InstructionType["hydrateAttribute"] = "rb";
  InstructionType["hydrateTemplateController"] = "rc";
  InstructionType["hydrateLetElement"] = "rd";
  InstructionType["setProperty"] = "re";
  InstructionType["interpolation"] = "rf";
  InstructionType["propertyBinding"] = "rg";
  InstructionType["callBinding"] = "rh";
  InstructionType["letBinding"] = "ri";
  InstructionType["refBinding"] = "rj";
  InstructionType["iteratorBinding"] = "rk";
  InstructionType["textBinding"] = "ha";
  InstructionType["listenerBinding"] = "hb";
  InstructionType["attributeBinding"] = "hc";
  InstructionType["stylePropertyBinding"] = "hd";
  InstructionType["setAttribute"] = "he";
  InstructionType["setClassAttribute"] = "hf";
  InstructionType["setStyleAttribute"] = "hg";
})(InstructionType || (exports.InstructionType = InstructionType = {}));

const IInstruction = _kernel.DI.createInterface('Instruction');

exports.IInstruction = IInstruction;

function isInstruction(value) {
  const type = value.type;
  return typeof type === 'string' && type.length === 2;
}

class InterpolationInstruction {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }

  get type() {
    return "rf"
    /* interpolation */
    ;
  }

}

exports.InterpolationInstruction = InterpolationInstruction;

class PropertyBindingInstruction {
  constructor(from, to, mode) {
    this.from = from;
    this.to = to;
    this.mode = mode;
  }

  get type() {
    return "rg"
    /* propertyBinding */
    ;
  }

}

exports.PropertyBindingInstruction = PropertyBindingInstruction;

class IteratorBindingInstruction {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }

  get type() {
    return "rk"
    /* iteratorBinding */
    ;
  }

}

exports.IteratorBindingInstruction = IteratorBindingInstruction;

class CallBindingInstruction {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }

  get type() {
    return "rh"
    /* callBinding */
    ;
  }

}

exports.CallBindingInstruction = CallBindingInstruction;

class RefBindingInstruction {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }

  get type() {
    return "rj"
    /* refBinding */
    ;
  }

}

exports.RefBindingInstruction = RefBindingInstruction;

class SetPropertyInstruction {
  constructor(value, to) {
    this.value = value;
    this.to = to;
  }

  get type() {
    return "re"
    /* setProperty */
    ;
  }

}

exports.SetPropertyInstruction = SetPropertyInstruction;

class HydrateElementInstruction {
  constructor(res, alias, instructions, slotInfo) {
    this.res = res;
    this.alias = alias;
    this.instructions = instructions;
    this.slotInfo = slotInfo;
  }

  get type() {
    return "ra"
    /* hydrateElement */
    ;
  }

}

exports.HydrateElementInstruction = HydrateElementInstruction;

class HydrateAttributeInstruction {
  constructor(res, alias, instructions) {
    this.res = res;
    this.alias = alias;
    this.instructions = instructions;
  }

  get type() {
    return "rb"
    /* hydrateAttribute */
    ;
  }

}

exports.HydrateAttributeInstruction = HydrateAttributeInstruction;

class HydrateTemplateController {
  constructor(def, res, alias, instructions) {
    this.def = def;
    this.res = res;
    this.alias = alias;
    this.instructions = instructions;
  }

  get type() {
    return "rc"
    /* hydrateTemplateController */
    ;
  }

}

exports.HydrateTemplateController = HydrateTemplateController;

class HydrateLetElementInstruction {
  constructor(instructions, toBindingContext) {
    this.instructions = instructions;
    this.toBindingContext = toBindingContext;
  }

  get type() {
    return "rd"
    /* hydrateLetElement */
    ;
  }

}

exports.HydrateLetElementInstruction = HydrateLetElementInstruction;

class LetBindingInstruction {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }

  get type() {
    return "ri"
    /* letBinding */
    ;
  }

}

exports.LetBindingInstruction = LetBindingInstruction;

class TextBindingInstruction {
  constructor(from) {
    this.from = from;
  }

  get type() {
    return "ha"
    /* textBinding */
    ;
  }

}

exports.TextBindingInstruction = TextBindingInstruction;

class ListenerBindingInstruction {
  constructor(from, to, preventDefault, strategy) {
    this.from = from;
    this.to = to;
    this.preventDefault = preventDefault;
    this.strategy = strategy;
  }

  get type() {
    return "hb"
    /* listenerBinding */
    ;
  }

}

exports.ListenerBindingInstruction = ListenerBindingInstruction;

class StylePropertyBindingInstruction {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }

  get type() {
    return "hd"
    /* stylePropertyBinding */
    ;
  }

}

exports.StylePropertyBindingInstruction = StylePropertyBindingInstruction;

class SetAttributeInstruction {
  constructor(value, to) {
    this.value = value;
    this.to = to;
  }

  get type() {
    return "he"
    /* setAttribute */
    ;
  }

}

exports.SetAttributeInstruction = SetAttributeInstruction;

class SetClassAttributeInstruction {
  constructor(value) {
    this.value = value;
    this.type = "hf"
    /* setClassAttribute */
    ;
  }

}

exports.SetClassAttributeInstruction = SetClassAttributeInstruction;

class SetStyleAttributeInstruction {
  constructor(value) {
    this.value = value;
    this.type = "hg"
    /* setStyleAttribute */
    ;
  }

}

exports.SetStyleAttributeInstruction = SetStyleAttributeInstruction;

class AttributeBindingInstruction {
  constructor(
  /**
   * `attr` and `to` have the same value on a normal attribute
   * Will be different on `class` and `style`
   * on `class`: attr = `class` (from binding command), to = attribute name
   * on `style`: attr = `style` (from binding command), to = attribute name
   */
  attr, from, to) {
    this.attr = attr;
    this.from = from;
    this.to = to;
  }

  get type() {
    return "hc"
    /* attributeBinding */
    ;
  }

}

exports.AttributeBindingInstruction = AttributeBindingInstruction;

const ITemplateCompiler = _kernel.DI.createInterface('ITemplateCompiler');

exports.ITemplateCompiler = ITemplateCompiler;

const IRenderer = _kernel.DI.createInterface('IRenderer');

exports.IRenderer = IRenderer;

function renderer(instructionType) {
  return function decorator(target) {
    // wrap the constructor to set the instructionType to the instance (for better performance than when set on the prototype)
    const decoratedTarget = function (...args) {
      const instance = new target(...args);
      instance.instructionType = instructionType;
      return instance;
    }; // make sure we register the decorated constructor with DI


    decoratedTarget.register = function register(container) {
      _kernel.Registration.singleton(IRenderer, decoratedTarget).register(container);
    }; // copy over any metadata such as annotations (set by preceding decorators) as well as static properties set by the user
    // also copy the name, to be less confusing to users (so they can still use constructor.name for whatever reason)
    // the length (number of ctor arguments) is copied for the same reason


    const metadataKeys = _kernel.Metadata.getOwnKeys(target);

    for (const key of metadataKeys) {
      _kernel.Metadata.define(key, _kernel.Metadata.getOwn(key, target), decoratedTarget);
    }

    const ownProperties = Object.getOwnPropertyDescriptors(target);
    Object.keys(ownProperties).filter(prop => prop !== 'prototype').forEach(prop => {
      Reflect.defineProperty(decoratedTarget, prop, ownProperties[prop]);
    });
    return decoratedTarget;
  };
}

function ensureExpression(parser, srcOrExpr, bindingType) {
  if (typeof srcOrExpr === 'string') {
    return parser.parse(srcOrExpr, bindingType);
  }

  return srcOrExpr;
}

function getTarget(potentialTarget) {
  if (potentialTarget.viewModel != null) {
    return potentialTarget.viewModel;
  }

  return potentialTarget;
}

function getRefTarget(refHost, refTargetName) {
  if (refTargetName === 'element') {
    return refHost;
  }

  switch (refTargetName) {
    case 'controller':
      // this means it supports returning undefined
      return _customElement.CustomElement.for(refHost);

    case 'view':
      // todo: returns node sequences for fun?
      throw new Error('Not supported API');

    case 'view-model':
      // this means it supports returning undefined
      return _customElement.CustomElement.for(refHost).viewModel;

    default:
      {
        const caController = _customAttribute.CustomAttribute.for(refHost, refTargetName);

        if (caController !== void 0) {
          return caController.viewModel;
        }

        const ceController = _customElement.CustomElement.for(refHost, {
          name: refTargetName
        });

        if (ceController === void 0) {
          throw new Error(`Attempted to reference "${refTargetName}", but it was not found amongst the target's API.`);
        }

        return ceController.viewModel;
      }
  }
}

let SetPropertyRenderer =
/** @internal */
class SetPropertyRenderer {
  render(flags, context, controller, target, instruction) {
    const obj = getTarget(target);

    if (obj.$observers !== void 0 && obj.$observers[instruction.to] !== void 0) {
      obj.$observers[instruction.to].setValue(instruction.value, 32
      /* fromBind */
      );
    } else {
      obj[instruction.to] = instruction.value;
    }
  }

};
exports.SetPropertyRenderer = SetPropertyRenderer;
exports.SetPropertyRenderer = SetPropertyRenderer = __decorate([renderer("re"
/* setProperty */
)
/** @internal */
], SetPropertyRenderer);
let CustomElementRenderer =
/** @internal */
class CustomElementRenderer {
  render(flags, context, controller, target, instruction) {
    let viewFactory;
    const slotInfo = instruction.slotInfo;

    if (slotInfo !== null) {
      const projectionCtx = slotInfo.projectionContext;
      viewFactory = (0, _renderContext.getRenderContext)(projectionCtx.content, context).getViewFactory(void 0, slotInfo.type, projectionCtx.scope);
    }

    const factory = context.getComponentFactory(
    /* parentController */
    controller,
    /* host             */
    target,
    /* instruction      */
    instruction,
    /* viewFactory      */
    viewFactory,
    /* location         */
    target);

    const key = _customElement.CustomElement.keyFrom(instruction.res);

    const component = factory.createComponent(key);

    const childController = _controller.Controller.forCustomElement(
    /* root                */
    controller.root,
    /* container           */
    context,
    /* viewModel           */
    component,
    /* host                */
    target,
    /* targetedProjections */
    context.getProjectionFor(instruction),
    /* flags               */
    flags);

    flags = childController.flags;

    _kernel.Metadata.define(key, childController, target);

    context.renderChildren(
    /* flags        */
    flags,
    /* instructions */
    instruction.instructions,
    /* controller   */
    controller,
    /* target       */
    childController);
    controller.addController(childController);
    factory.dispose();
  }

};
exports.CustomElementRenderer = CustomElementRenderer;
exports.CustomElementRenderer = CustomElementRenderer = __decorate([renderer("ra"
/* hydrateElement */
)
/** @internal */
], CustomElementRenderer);
let CustomAttributeRenderer =
/** @internal */
class CustomAttributeRenderer {
  render(flags, context, controller, target, instruction) {
    const factory = context.getComponentFactory(
    /* parentController */
    controller,
    /* host             */
    target,
    /* instruction      */
    instruction,
    /* viewFactory      */
    void 0,
    /* location         */
    void 0);

    const key = _customAttribute.CustomAttribute.keyFrom(instruction.res);

    const component = factory.createComponent(key);

    const childController = _controller.Controller.forCustomAttribute(
    /* root      */
    controller.root,
    /* container */
    context,
    /* viewModel */
    component,
    /* host      */
    target,
    /* flags     */
    flags);

    _kernel.Metadata.define(key, childController, target);

    context.renderChildren(
    /* flags        */
    flags,
    /* instructions */
    instruction.instructions,
    /* controller   */
    controller,
    /* target       */
    childController);
    controller.addController(childController);
    factory.dispose();
  }

};
exports.CustomAttributeRenderer = CustomAttributeRenderer;
exports.CustomAttributeRenderer = CustomAttributeRenderer = __decorate([renderer("rb"
/* hydrateAttribute */
)
/** @internal */
], CustomAttributeRenderer);
let TemplateControllerRenderer =
/** @internal */
class TemplateControllerRenderer {
  render(flags, context, controller, target, instruction) {
    const viewFactory = (0, _renderContext.getRenderContext)(instruction.def, context).getViewFactory();
    const renderLocation = (0, _dom.convertToRenderLocation)(target);
    const componentFactory = context.getComponentFactory(
    /* parentController */
    controller,
    /* host             */
    target,
    /* instruction      */
    instruction,
    /* viewFactory      */
    viewFactory,
    /* location         */
    renderLocation);

    const key = _customAttribute.CustomAttribute.keyFrom(instruction.res);

    const component = componentFactory.createComponent(key);

    const childController = _controller.Controller.forCustomAttribute(
    /* root      */
    controller.root,
    /* container */
    context,
    /* viewModel */
    component,
    /* host      */
    target,
    /* flags     */
    flags);

    _kernel.Metadata.define(key, childController, renderLocation);

    component.link?.(flags, context, controller, childController, target, instruction);
    context.renderChildren(
    /* flags        */
    flags,
    /* instructions */
    instruction.instructions,
    /* controller   */
    controller,
    /* target       */
    childController);
    controller.addController(childController);
    componentFactory.dispose();
  }

};
exports.TemplateControllerRenderer = TemplateControllerRenderer;
exports.TemplateControllerRenderer = TemplateControllerRenderer = __decorate([renderer("rc"
/* hydrateTemplateController */
)
/** @internal */
], TemplateControllerRenderer);
let LetElementRenderer =
/** @internal */
class LetElementRenderer {
  constructor(parser, observerLocator) {
    this.parser = parser;
    this.observerLocator = observerLocator;
  }

  render(flags, context, controller, target, instruction) {
    target.remove();
    const childInstructions = instruction.instructions;
    const toBindingContext = instruction.toBindingContext;
    let childInstruction;
    let expr;
    let binding;

    for (let i = 0, ii = childInstructions.length; i < ii; ++i) {
      childInstruction = childInstructions[i];
      expr = ensureExpression(this.parser, childInstruction.from, 48
      /* IsPropertyCommand */
      );
      binding = applyBindingBehavior(new _letBinding.LetBinding(expr, childInstruction.to, this.observerLocator, context, toBindingContext), expr, context);
      controller.addBinding(binding);
    }
  }

};
exports.LetElementRenderer = LetElementRenderer;
exports.LetElementRenderer = LetElementRenderer = __decorate([renderer("rd"
/* hydrateLetElement */
)
/** @internal */
, __param(0, _runtime.IExpressionParser), __param(1, _runtime.IObserverLocator)], LetElementRenderer);
let CallBindingRenderer =
/** @internal */
class CallBindingRenderer {
  constructor(parser, observerLocator) {
    this.parser = parser;
    this.observerLocator = observerLocator;
  }

  render(flags, context, controller, target, instruction) {
    const expr = ensureExpression(this.parser, instruction.from, 153
    /* CallCommand */
    );
    const binding = applyBindingBehavior(new _callBinding.CallBinding(expr, getTarget(target), instruction.to, this.observerLocator, context), expr, context);
    controller.addBinding(binding);
  }

};
exports.CallBindingRenderer = CallBindingRenderer;
exports.CallBindingRenderer = CallBindingRenderer = __decorate([renderer("rh"
/* callBinding */
)
/** @internal */
, __param(0, _runtime.IExpressionParser), __param(1, _runtime.IObserverLocator)], CallBindingRenderer);
let RefBindingRenderer =
/** @internal */
class RefBindingRenderer {
  constructor(parser) {
    this.parser = parser;
  }

  render(flags, context, controller, target, instruction) {
    const expr = ensureExpression(this.parser, instruction.from, 5376
    /* IsRef */
    );
    const binding = applyBindingBehavior(new _refBinding.RefBinding(expr, getRefTarget(target, instruction.to), context), expr, context);
    controller.addBinding(binding);
  }

};
exports.RefBindingRenderer = RefBindingRenderer;
exports.RefBindingRenderer = RefBindingRenderer = __decorate([renderer("rj"
/* refBinding */
)
/** @internal */
, __param(0, _runtime.IExpressionParser)], RefBindingRenderer);
let InterpolationBindingRenderer =
/** @internal */
class InterpolationBindingRenderer {
  constructor(parser, observerLocator, platform) {
    this.parser = parser;
    this.observerLocator = observerLocator;
    this.platform = platform;
  }

  render(flags, context, controller, target, instruction) {
    const expr = ensureExpression(this.parser, instruction.from, 2048
    /* Interpolation */
    );
    const binding = new _interpolationBinding.InterpolationBinding(this.observerLocator, expr, getTarget(target), instruction.to, _runtime.BindingMode.toView, context, this.platform.domWriteQueue);
    const partBindings = binding.partBindings;
    let partBinding;

    for (let i = 0, ii = partBindings.length; ii > i; ++i) {
      partBinding = partBindings[i];
      partBindings[i] = applyBindingBehavior(partBinding, partBinding.sourceExpression, context);
    }

    controller.addBinding(binding);
  }

};
exports.InterpolationBindingRenderer = InterpolationBindingRenderer;
exports.InterpolationBindingRenderer = InterpolationBindingRenderer = __decorate([renderer("rf"
/* interpolation */
)
/** @internal */
, __param(0, _runtime.IExpressionParser), __param(1, _runtime.IObserverLocator), __param(2, _platform.IPlatform)], InterpolationBindingRenderer);
let PropertyBindingRenderer =
/** @internal */
class PropertyBindingRenderer {
  constructor(parser, observerLocator, platform) {
    this.parser = parser;
    this.observerLocator = observerLocator;
    this.platform = platform;
  }

  render(flags, context, controller, target, instruction) {
    const expr = ensureExpression(this.parser, instruction.from, 48
    /* IsPropertyCommand */
    | instruction.mode);
    const binding = applyBindingBehavior(new _propertyBinding.PropertyBinding(expr, getTarget(target), instruction.to, instruction.mode, this.observerLocator, context, this.platform.domWriteQueue), expr, context);
    controller.addBinding(binding);
  }

};
exports.PropertyBindingRenderer = PropertyBindingRenderer;
exports.PropertyBindingRenderer = PropertyBindingRenderer = __decorate([renderer("rg"
/* propertyBinding */
)
/** @internal */
, __param(0, _runtime.IExpressionParser), __param(1, _runtime.IObserverLocator), __param(2, _platform.IPlatform)], PropertyBindingRenderer);
let IteratorBindingRenderer =
/** @internal */
class IteratorBindingRenderer {
  constructor(parser, observerLocator, platform) {
    this.parser = parser;
    this.observerLocator = observerLocator;
    this.platform = platform;
  }

  render(flags, context, controller, target, instruction) {
    const expr = ensureExpression(this.parser, instruction.from, 539
    /* ForCommand */
    );
    const binding = applyBindingBehavior(new _propertyBinding.PropertyBinding(expr, getTarget(target), instruction.to, _runtime.BindingMode.toView, this.observerLocator, context, this.platform.domWriteQueue), expr, context);
    controller.addBinding(binding);
  }

};
exports.IteratorBindingRenderer = IteratorBindingRenderer;
exports.IteratorBindingRenderer = IteratorBindingRenderer = __decorate([renderer("rk"
/* iteratorBinding */
)
/** @internal */
, __param(0, _runtime.IExpressionParser), __param(1, _runtime.IObserverLocator), __param(2, _platform.IPlatform)], IteratorBindingRenderer);
let behaviorExpressionIndex = 0;
const behaviorExpressions = [];

function applyBindingBehavior(binding, expression, locator) {
  while (expression instanceof _runtime.BindingBehaviorExpression) {
    behaviorExpressions[behaviorExpressionIndex++] = expression;
    expression = expression.expression;
  }

  while (behaviorExpressionIndex > 0) {
    const behaviorExpression = behaviorExpressions[--behaviorExpressionIndex];
    const behaviorOrFactory = locator.get(behaviorExpression.behaviorKey);

    if (behaviorOrFactory instanceof _runtime.BindingBehaviorFactory) {
      binding = behaviorOrFactory.construct(binding, behaviorExpression);
    }
  }

  behaviorExpressions.length = 0;
  return binding;
}

let TextBindingRenderer =
/** @internal */
class TextBindingRenderer {
  constructor(parser, observerLocator, platform) {
    this.parser = parser;
    this.observerLocator = observerLocator;
    this.platform = platform;
  }

  render(flags, context, controller, target, instruction) {
    const next = target.nextSibling;

    if (target.nodeName === 'AU-M') {
      target.remove();
    }

    const expr = ensureExpression(this.parser, instruction.from, 2048
    /* Interpolation */
    );
    const binding = new _interpolationBinding.InterpolationBinding(this.observerLocator, expr, next, 'textContent', _runtime.BindingMode.toView, context, this.platform.domWriteQueue);
    const partBindings = binding.partBindings;
    let partBinding;

    for (let i = 0, ii = partBindings.length; ii > i; ++i) {
      partBinding = partBindings[i];
      partBindings[i] = applyBindingBehavior(partBinding, partBinding.sourceExpression, context);
    }

    controller.addBinding(binding);
  }

};
exports.TextBindingRenderer = TextBindingRenderer;
exports.TextBindingRenderer = TextBindingRenderer = __decorate([renderer("ha"
/* textBinding */
)
/** @internal */
, __param(0, _runtime.IExpressionParser), __param(1, _runtime.IObserverLocator), __param(2, _platform.IPlatform)], TextBindingRenderer);
let ListenerBindingRenderer =
/** @internal */
class ListenerBindingRenderer {
  constructor(parser, eventDelegator) {
    this.parser = parser;
    this.eventDelegator = eventDelegator;
  }

  render(flags, context, controller, target, instruction) {
    const expr = ensureExpression(this.parser, instruction.from, 80
    /* IsEventCommand */
    | instruction.strategy + 6
    /* DelegationStrategyDelta */
    );
    const binding = applyBindingBehavior(new _listener.Listener(context.platform, instruction.to, instruction.strategy, expr, target, instruction.preventDefault, this.eventDelegator, context), expr, context);
    controller.addBinding(binding);
  }

};
exports.ListenerBindingRenderer = ListenerBindingRenderer;
exports.ListenerBindingRenderer = ListenerBindingRenderer = __decorate([renderer("hb"
/* listenerBinding */
)
/** @internal */
, __param(0, _runtime.IExpressionParser), __param(1, _eventDelegator.IEventDelegator)], ListenerBindingRenderer);
let SetAttributeRenderer =
/** @internal */
class SetAttributeRenderer {
  render(flags, context, controller, target, instruction) {
    target.setAttribute(instruction.to, instruction.value);
  }

};
exports.SetAttributeRenderer = SetAttributeRenderer;
exports.SetAttributeRenderer = SetAttributeRenderer = __decorate([renderer("he"
/* setAttribute */
)
/** @internal */
], SetAttributeRenderer);
let SetClassAttributeRenderer = class SetClassAttributeRenderer {
  render(flags, context, controller, target, instruction) {
    addClasses(target.classList, instruction.value);
  }

};
exports.SetClassAttributeRenderer = SetClassAttributeRenderer;
exports.SetClassAttributeRenderer = SetClassAttributeRenderer = __decorate([renderer("hf"
/* setClassAttribute */
)], SetClassAttributeRenderer);
let SetStyleAttributeRenderer = class SetStyleAttributeRenderer {
  render(flags, context, controller, target, instruction) {
    target.style.cssText += instruction.value;
  }

};
exports.SetStyleAttributeRenderer = SetStyleAttributeRenderer;
exports.SetStyleAttributeRenderer = SetStyleAttributeRenderer = __decorate([renderer("hg"
/* setStyleAttribute */
)], SetStyleAttributeRenderer);
let StylePropertyBindingRenderer =
/** @internal */
class StylePropertyBindingRenderer {
  constructor(parser, observerLocator, platform) {
    this.parser = parser;
    this.observerLocator = observerLocator;
    this.platform = platform;
  }

  render(flags, context, controller, target, instruction) {
    const expr = ensureExpression(this.parser, instruction.from, 48
    /* IsPropertyCommand */
    | _runtime.BindingMode.toView);
    const binding = applyBindingBehavior(new _propertyBinding.PropertyBinding(expr, target.style, instruction.to, _runtime.BindingMode.toView, this.observerLocator, context, this.platform.domWriteQueue), expr, context);
    controller.addBinding(binding);
  }

};
exports.StylePropertyBindingRenderer = StylePropertyBindingRenderer;
exports.StylePropertyBindingRenderer = StylePropertyBindingRenderer = __decorate([renderer("hd"
/* stylePropertyBinding */
)
/** @internal */
, __param(0, _runtime.IExpressionParser), __param(1, _runtime.IObserverLocator), __param(2, _platform.IPlatform)], StylePropertyBindingRenderer);
let AttributeBindingRenderer =
/** @internal */
class AttributeBindingRenderer {
  constructor(parser, observerLocator) {
    this.parser = parser;
    this.observerLocator = observerLocator;
  }

  render(flags, context, controller, target, instruction) {
    const expr = ensureExpression(this.parser, instruction.from, 48
    /* IsPropertyCommand */
    | _runtime.BindingMode.toView);
    const binding = applyBindingBehavior(new _attribute.AttributeBinding(expr, target, instruction.attr
    /* targetAttribute */
    , instruction.to
    /* targetKey */
    , _runtime.BindingMode.toView, this.observerLocator, context), expr, context);
    controller.addBinding(binding);
  }

};
exports.AttributeBindingRenderer = AttributeBindingRenderer;
exports.AttributeBindingRenderer = AttributeBindingRenderer = __decorate([renderer("hc"
/* attributeBinding */
)
/** @internal */
, __param(0, _runtime.IExpressionParser), __param(1, _runtime.IObserverLocator)], AttributeBindingRenderer);

// http://jsben.ch/7n5Kt
function addClasses(classList, className) {
  const len = className.length;
  let start = 0;

  for (let i = 0; i < len; ++i) {
    if (className.charCodeAt(i) === 0x20) {
      if (i !== start) {
        classList.add(className.slice(start, i));
      }

      start = i + 1;
    } else if (i + 1 === len) {
      classList.add(className.slice(start));
    }
  }
}
});

;define.alias('@aurelia/runtime-html/renderer.js','@aurelia/runtime-html/dist/esm/renderer.js');
define('@aurelia/runtime-html/dist/esm/resources/attribute-pattern.js',['require','exports','module','@aurelia/kernel'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.attributePattern = attributePattern;
exports.AtPrefixedTriggerAttributePattern = exports.ColonPrefixedBindAttributePattern = exports.RefAttributePattern = exports.DotSeparatedAttributePattern = exports.AttributePattern = exports.AttributePatternResourceDefinition = exports.AttributeParser = exports.IAttributeParser = exports.IAttributePattern = exports.AttrSyntax = exports.SyntaxInterpreter = exports.ISyntaxInterpreter = exports.SegmentTypes = exports.SymbolSegment = exports.DynamicSegment = exports.StaticSegment = exports.State = exports.Interpretation = exports.CharSpec = void 0;

var _kernel = require("@aurelia/kernel");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

/** @internal */
class CharSpec {
  constructor(chars, repeat, isSymbol, isInverted) {
    this.chars = chars;
    this.repeat = repeat;
    this.isSymbol = isSymbol;
    this.isInverted = isInverted;

    if (isInverted) {
      switch (chars.length) {
        case 0:
          this.has = this.hasOfNoneInverse;
          break;

        case 1:
          this.has = this.hasOfSingleInverse;
          break;

        default:
          this.has = this.hasOfMultipleInverse;
      }
    } else {
      switch (chars.length) {
        case 0:
          this.has = this.hasOfNone;
          break;

        case 1:
          this.has = this.hasOfSingle;
          break;

        default:
          this.has = this.hasOfMultiple;
      }
    }
  }

  equals(other) {
    return this.chars === other.chars && this.repeat === other.repeat && this.isSymbol === other.isSymbol && this.isInverted === other.isInverted;
  }

  hasOfMultiple(char) {
    return this.chars.includes(char);
  }

  hasOfSingle(char) {
    return this.chars === char;
  }

  hasOfNone(char) {
    return false;
  }

  hasOfMultipleInverse(char) {
    return !this.chars.includes(char);
  }

  hasOfSingleInverse(char) {
    return this.chars !== char;
  }

  hasOfNoneInverse(char) {
    return true;
  }

}

exports.CharSpec = CharSpec;

class Interpretation {
  constructor() {
    this.parts = _kernel.emptyArray;
    this._pattern = '';
    this.currentRecord = {};
    this.partsRecord = {};
  }

  get pattern() {
    const value = this._pattern;

    if (value === '') {
      return null;
    } else {
      return value;
    }
  }

  set pattern(value) {
    if (value == null) {
      this._pattern = '';
      this.parts = _kernel.emptyArray;
    } else {
      this._pattern = value;
      this.parts = this.partsRecord[value];
    }
  }

  append(pattern, ch) {
    const {
      currentRecord
    } = this;

    if (currentRecord[pattern] === undefined) {
      currentRecord[pattern] = ch;
    } else {
      currentRecord[pattern] += ch;
    }
  }

  next(pattern) {
    const {
      currentRecord
    } = this;

    if (currentRecord[pattern] !== undefined) {
      const {
        partsRecord
      } = this;

      if (partsRecord[pattern] === undefined) {
        partsRecord[pattern] = [currentRecord[pattern]];
      } else {
        partsRecord[pattern].push(currentRecord[pattern]);
      }

      currentRecord[pattern] = undefined;
    }
  }

}
/** @internal */


exports.Interpretation = Interpretation;

class State {
  constructor(charSpec, ...patterns) {
    this.charSpec = charSpec;
    this.nextStates = [];
    this.types = null;
    this.isEndpoint = false;
    this.patterns = patterns;
  }

  get pattern() {
    return this.isEndpoint ? this.patterns[0] : null;
  }

  findChild(charSpec) {
    const nextStates = this.nextStates;
    const len = nextStates.length;
    let child = null;

    for (let i = 0; i < len; ++i) {
      child = nextStates[i];

      if (charSpec.equals(child.charSpec)) {
        return child;
      }
    }

    return null;
  }

  append(charSpec, pattern) {
    const {
      patterns
    } = this;

    if (!patterns.includes(pattern)) {
      patterns.push(pattern);
    }

    let state = this.findChild(charSpec);

    if (state == null) {
      state = new State(charSpec, pattern);
      this.nextStates.push(state);

      if (charSpec.repeat) {
        state.nextStates.push(state);
      }
    }

    return state;
  }

  findMatches(ch, interpretation) {
    // TODO: reuse preallocated arrays
    const results = [];
    const nextStates = this.nextStates;
    const len = nextStates.length;
    let childLen = 0;
    let child = null;
    let i = 0;
    let j = 0;

    for (; i < len; ++i) {
      child = nextStates[i];

      if (child.charSpec.has(ch)) {
        results.push(child);
        childLen = child.patterns.length;
        j = 0;

        if (child.charSpec.isSymbol) {
          for (; j < childLen; ++j) {
            interpretation.next(child.patterns[j]);
          }
        } else {
          for (; j < childLen; ++j) {
            interpretation.append(child.patterns[j], ch);
          }
        }
      }
    }

    return results;
  }

}
/** @internal */


exports.State = State;

class StaticSegment {
  constructor(text) {
    this.text = text;
    const len = this.len = text.length;
    const specs = this.specs = [];

    for (let i = 0; i < len; ++i) {
      specs.push(new CharSpec(text[i], false, false, false));
    }
  }

  eachChar(callback) {
    const {
      len,
      specs
    } = this;

    for (let i = 0; i < len; ++i) {
      callback(specs[i]);
    }
  }

}
/** @internal */


exports.StaticSegment = StaticSegment;

class DynamicSegment {
  constructor(symbols) {
    this.text = 'PART';
    this.spec = new CharSpec(symbols, true, false, true);
  }

  eachChar(callback) {
    callback(this.spec);
  }

}
/** @internal */


exports.DynamicSegment = DynamicSegment;

class SymbolSegment {
  constructor(text) {
    this.text = text;
    this.spec = new CharSpec(text, false, true, false);
  }

  eachChar(callback) {
    callback(this.spec);
  }

}
/** @internal */


exports.SymbolSegment = SymbolSegment;

class SegmentTypes {
  constructor() {
    this.statics = 0;
    this.dynamics = 0;
    this.symbols = 0;
  }

}

exports.SegmentTypes = SegmentTypes;

const ISyntaxInterpreter = _kernel.DI.createInterface('ISyntaxInterpreter', x => x.singleton(SyntaxInterpreter));

exports.ISyntaxInterpreter = ISyntaxInterpreter;

class SyntaxInterpreter {
  constructor() {
    this.rootState = new State(null);
    this.initialStates = [this.rootState];
  }

  add(defOrDefs) {
    let i = 0;

    if (Array.isArray(defOrDefs)) {
      const ii = defOrDefs.length;

      for (; i < ii; ++i) {
        this.add(defOrDefs[i]);
      }

      return;
    }

    let currentState = this.rootState;
    const def = defOrDefs;
    const pattern = def.pattern;
    const types = new SegmentTypes();
    const segments = this.parse(def, types);
    const len = segments.length;

    const callback = ch => {
      currentState = currentState.append(ch, pattern);
    };

    for (i = 0; i < len; ++i) {
      segments[i].eachChar(callback);
    }

    currentState.types = types;
    currentState.isEndpoint = true;
  }

  interpret(name) {
    const interpretation = new Interpretation();
    let states = this.initialStates;
    const len = name.length;

    for (let i = 0; i < len; ++i) {
      states = this.getNextStates(states, name.charAt(i), interpretation);

      if (states.length === 0) {
        break;
      }
    }

    states.sort((a, b) => {
      if (a.isEndpoint) {
        if (!b.isEndpoint) {
          return -1;
        }
      } else if (b.isEndpoint) {
        return 1;
      } else {
        return 0;
      }

      const aTypes = a.types;
      const bTypes = b.types;

      if (aTypes.statics !== bTypes.statics) {
        return bTypes.statics - aTypes.statics;
      }

      if (aTypes.dynamics !== bTypes.dynamics) {
        return bTypes.dynamics - aTypes.dynamics;
      }

      if (aTypes.symbols !== bTypes.symbols) {
        return bTypes.symbols - aTypes.symbols;
      }

      return 0;
    });

    if (states.length > 0) {
      const state = states[0];

      if (!state.charSpec.isSymbol) {
        interpretation.next(state.pattern);
      }

      interpretation.pattern = state.pattern;
    }

    return interpretation;
  }

  getNextStates(states, ch, interpretation) {
    // TODO: reuse preallocated arrays
    const nextStates = [];
    let state = null;
    const len = states.length;

    for (let i = 0; i < len; ++i) {
      state = states[i];
      nextStates.push(...state.findMatches(ch, interpretation));
    }

    return nextStates;
  }

  parse(def, types) {
    const result = [];
    const pattern = def.pattern;
    const len = pattern.length;
    let i = 0;
    let start = 0;
    let c = '';

    while (i < len) {
      c = pattern.charAt(i);

      if (!def.symbols.includes(c)) {
        if (i === start) {
          if (c === 'P' && pattern.slice(i, i + 4) === 'PART') {
            start = i = i + 4;
            result.push(new DynamicSegment(def.symbols));
            ++types.dynamics;
          } else {
            ++i;
          }
        } else {
          ++i;
        }
      } else if (i !== start) {
        result.push(new StaticSegment(pattern.slice(start, i)));
        ++types.statics;
        start = i;
      } else {
        result.push(new SymbolSegment(pattern.slice(start, i + 1)));
        ++types.symbols;
        start = ++i;
      }
    }

    if (start !== i) {
      result.push(new StaticSegment(pattern.slice(start, i)));
      ++types.statics;
    }

    return result;
  }

}

exports.SyntaxInterpreter = SyntaxInterpreter;

class AttrSyntax {
  constructor(rawName, rawValue, target, command) {
    this.rawName = rawName;
    this.rawValue = rawValue;
    this.target = target;
    this.command = command;
  }

}

exports.AttrSyntax = AttrSyntax;

const IAttributePattern = _kernel.DI.createInterface('IAttributePattern');

exports.IAttributePattern = IAttributePattern;

const IAttributeParser = _kernel.DI.createInterface('IAttributeParser', x => x.singleton(AttributeParser));

exports.IAttributeParser = IAttributeParser;
let AttributeParser = class AttributeParser {
  constructor(interpreter, attrPatterns) {
    this.interpreter = interpreter;
    this.cache = {};
    const patterns = this.patterns = {};
    attrPatterns.forEach(attrPattern => {
      const defs = AttributePattern.getPatternDefinitions(attrPattern.constructor);
      interpreter.add(defs);
      defs.forEach(def => {
        patterns[def.pattern] = attrPattern;
      });
    });
  }

  parse(name, value) {
    let interpretation = this.cache[name];

    if (interpretation == null) {
      interpretation = this.cache[name] = this.interpreter.interpret(name);
    }

    const pattern = interpretation.pattern;

    if (pattern == null) {
      return new AttrSyntax(name, value, name, null);
    } else {
      return this.patterns[pattern][pattern](name, value, interpretation.parts);
    }
  }

};
exports.AttributeParser = AttributeParser;
exports.AttributeParser = AttributeParser = __decorate([__param(0, ISyntaxInterpreter), __param(1, (0, _kernel.all)(IAttributePattern))], AttributeParser);

function attributePattern(...patternDefs) {
  return function decorator(target) {
    return AttributePattern.define(patternDefs, target);
  };
}

class AttributePatternResourceDefinition {
  constructor(Type) {
    this.Type = Type;
    this.name = void 0;
  }

  register(container) {
    _kernel.Registration.singleton(IAttributePattern, this.Type).register(container);
  }

}

exports.AttributePatternResourceDefinition = AttributePatternResourceDefinition;
const AttributePattern = Object.freeze({
  name: _kernel.Protocol.resource.keyFor('attribute-pattern'),
  definitionAnnotationKey: 'attribute-pattern-definitions',

  define(patternDefs, Type) {
    const definition = new AttributePatternResourceDefinition(Type);
    const {
      name,
      definitionAnnotationKey
    } = AttributePattern;

    _kernel.Metadata.define(name, definition, Type);

    _kernel.Protocol.resource.appendTo(Type, name);

    _kernel.Protocol.annotation.set(Type, definitionAnnotationKey, patternDefs);

    _kernel.Protocol.annotation.appendTo(Type, definitionAnnotationKey);

    return Type;
  },

  getPatternDefinitions(Type) {
    return _kernel.Protocol.annotation.get(Type, AttributePattern.definitionAnnotationKey);
  }

});
exports.AttributePattern = AttributePattern;
let DotSeparatedAttributePattern = class DotSeparatedAttributePattern {
  'PART.PART'(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, parts[0], parts[1]);
  }

  'PART.PART.PART'(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, parts[0], parts[2]);
  }

};
exports.DotSeparatedAttributePattern = DotSeparatedAttributePattern;
exports.DotSeparatedAttributePattern = DotSeparatedAttributePattern = __decorate([attributePattern({
  pattern: 'PART.PART',
  symbols: '.'
}, {
  pattern: 'PART.PART.PART',
  symbols: '.'
})], DotSeparatedAttributePattern);
let RefAttributePattern = class RefAttributePattern {
  'ref'(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, 'element', 'ref');
  }

  'PART.ref'(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, parts[0], 'ref');
  }

};
exports.RefAttributePattern = RefAttributePattern;
exports.RefAttributePattern = RefAttributePattern = __decorate([attributePattern({
  pattern: 'ref',
  symbols: ''
}, {
  pattern: 'PART.ref',
  symbols: '.'
})], RefAttributePattern);
let ColonPrefixedBindAttributePattern = class ColonPrefixedBindAttributePattern {
  ':PART'(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, parts[0], 'bind');
  }

};
exports.ColonPrefixedBindAttributePattern = ColonPrefixedBindAttributePattern;
exports.ColonPrefixedBindAttributePattern = ColonPrefixedBindAttributePattern = __decorate([attributePattern({
  pattern: ':PART',
  symbols: ':'
})], ColonPrefixedBindAttributePattern);
let AtPrefixedTriggerAttributePattern = class AtPrefixedTriggerAttributePattern {
  '@PART'(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, parts[0], 'trigger');
  }

};
exports.AtPrefixedTriggerAttributePattern = AtPrefixedTriggerAttributePattern;
exports.AtPrefixedTriggerAttributePattern = AtPrefixedTriggerAttributePattern = __decorate([attributePattern({
  pattern: '@PART',
  symbols: '@'
})], AtPrefixedTriggerAttributePattern);
});

;define.alias('@aurelia/runtime-html/resources/attribute-pattern.js','@aurelia/runtime-html/dist/esm/resources/attribute-pattern.js');
define('@aurelia/runtime-html/dist/esm/resources/binding-behaviors/attr.js',['require','exports','module','@aurelia/runtime','../../observation/data-attribute-accessor.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.AttrBindingBehavior = void 0;

var _runtime = require("@aurelia/runtime");

var _dataAttributeAccessor = require("../../observation/data-attribute-accessor.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

let AttrBindingBehavior = class AttrBindingBehavior {
  bind(flags, _scope, _hostScope, binding) {
    binding.targetObserver = _dataAttributeAccessor.attrAccessor;
  }

  unbind(flags, _scope, _hostScope, binding) {
    return;
  }

};
exports.AttrBindingBehavior = AttrBindingBehavior;
exports.AttrBindingBehavior = AttrBindingBehavior = __decorate([(0, _runtime.bindingBehavior)('attr')], AttrBindingBehavior);
});

;define.alias('@aurelia/runtime-html/resources/binding-behaviors/attr.js','@aurelia/runtime-html/dist/esm/resources/binding-behaviors/attr.js');
define('@aurelia/runtime-html/dist/esm/resources/binding-behaviors/self.js',['require','exports','module','@aurelia/runtime'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.handleSelfEvent = handleSelfEvent;
exports.SelfBindingBehavior = void 0;

var _runtime = require("@aurelia/runtime");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/** @internal */
function handleSelfEvent(event) {
  const target = event.composedPath()[0];

  if (this.target !== target) {
    return;
  }

  return this.selfEventCallSource(event);
}

let SelfBindingBehavior = class SelfBindingBehavior {
  bind(flags, _scope, _hostScope, binding) {
    if (!binding.callSource || !binding.targetEvent) {
      throw new Error('Self binding behavior only supports events.');
    }

    binding.selfEventCallSource = binding.callSource;
    binding.callSource = handleSelfEvent;
  }

  unbind(flags, _scope, _hostScope, binding) {
    binding.callSource = binding.selfEventCallSource;
    binding.selfEventCallSource = null;
  }

};
exports.SelfBindingBehavior = SelfBindingBehavior;
exports.SelfBindingBehavior = SelfBindingBehavior = __decorate([(0, _runtime.bindingBehavior)('self')], SelfBindingBehavior);
});

;define.alias('@aurelia/runtime-html/resources/binding-behaviors/self.js','@aurelia/runtime-html/dist/esm/resources/binding-behaviors/self.js');
define('@aurelia/runtime-html/dist/esm/resources/binding-behaviors/update-trigger.js',['require','exports','module','@aurelia/runtime','../../observation/event-delegator.js','../../observation/observer-locator.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.UpdateTriggerBindingBehavior = void 0;

var _runtime = require("@aurelia/runtime");

var _eventDelegator = require("../../observation/event-delegator.js");

var _observerLocator = require("../../observation/observer-locator.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

let UpdateTriggerBindingBehavior = class UpdateTriggerBindingBehavior {
  constructor(observerLocator) {
    this.observerLocator = observerLocator;
  }

  bind(flags, _scope, _hostScope, binding, ...events) {
    if (events.length === 0) {
      throw new Error('The updateTrigger binding behavior requires at least one event name argument: eg <input value.bind="firstName & updateTrigger:\'blur\'">');
    }

    if (binding.mode !== _runtime.BindingMode.twoWay && binding.mode !== _runtime.BindingMode.fromView) {
      throw new Error('The updateTrigger binding behavior can only be applied to two-way/ from-view bindings on input/select elements.');
    } // ensure the binding's target observer has been set.


    const targetObserver = this.observerLocator.getObserver(binding.target, binding.targetProperty);

    if (!targetObserver.handler) {
      throw new Error('The updateTrigger binding behavior can only be applied to two-way/ from-view bindings on input/select elements.');
    }

    binding.targetObserver = targetObserver; // stash the original element subscribe function.

    const originalHandler = targetObserver.handler;
    targetObserver.originalHandler = originalHandler; // replace the element subscribe function with one that uses the correct events.

    targetObserver.handler = new _eventDelegator.EventSubscriber(new _observerLocator.NodeObserverConfig({
      default: originalHandler.config.default,
      events,
      readonly: originalHandler.config.readonly
    }));
  }

  unbind(flags, _scope, _hostScope, binding) {
    // restore the state of the binding.
    binding.targetObserver.handler.dispose();
    binding.targetObserver.handler = binding.targetObserver.originalHandler;
    binding.targetObserver.originalHandler = null;
  }

};
exports.UpdateTriggerBindingBehavior = UpdateTriggerBindingBehavior;
exports.UpdateTriggerBindingBehavior = UpdateTriggerBindingBehavior = __decorate([(0, _runtime.bindingBehavior)('updateTrigger'), __param(0, _runtime.IObserverLocator)], UpdateTriggerBindingBehavior);
});

;define.alias('@aurelia/runtime-html/resources/binding-behaviors/update-trigger.js','@aurelia/runtime-html/dist/esm/resources/binding-behaviors/update-trigger.js');
define('@aurelia/runtime-html/dist/esm/resources/binding-command.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime','../renderer.js','../semantic-model.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.bindingCommand = bindingCommand;
exports.getTarget = getTarget;
exports.RefBindingCommand = exports.ClassBindingCommand = exports.StyleBindingCommand = exports.AttrBindingCommand = exports.CaptureBindingCommand = exports.DelegateBindingCommand = exports.TriggerBindingCommand = exports.ForBindingCommand = exports.CallBindingCommand = exports.DefaultBindingCommand = exports.TwoWayBindingCommand = exports.FromViewBindingCommand = exports.ToViewBindingCommand = exports.OneTimeBindingCommand = exports.BindingCommand = exports.BindingCommandDefinition = void 0;

var _kernel = require("@aurelia/kernel");

var _runtime = require("@aurelia/runtime");

var _renderer = require("../renderer.js");

var _semanticModel = require("../semantic-model.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

function bindingCommand(nameOrDefinition) {
  return function (target) {
    return BindingCommand.define(nameOrDefinition, target);
  };
}

class BindingCommandDefinition {
  constructor(Type, name, aliases, key, type) {
    this.Type = Type;
    this.name = name;
    this.aliases = aliases;
    this.key = key;
    this.type = type;
  }

  static create(nameOrDef, Type) {
    let name;
    let def;

    if (typeof nameOrDef === 'string') {
      name = nameOrDef;
      def = {
        name
      };
    } else {
      name = nameOrDef.name;
      def = nameOrDef;
    }

    return new BindingCommandDefinition(Type, (0, _kernel.firstDefined)(BindingCommand.getAnnotation(Type, 'name'), name), (0, _kernel.mergeArrays)(BindingCommand.getAnnotation(Type, 'aliases'), def.aliases, Type.aliases), BindingCommand.keyFrom(name), (0, _kernel.firstDefined)(BindingCommand.getAnnotation(Type, 'type'), def.type, Type.type, null));
  }

  register(container) {
    const {
      Type,
      key,
      aliases
    } = this;

    _kernel.Registration.singleton(key, Type).register(container);

    _kernel.Registration.aliasTo(key, Type).register(container);

    (0, _runtime.registerAliases)(aliases, BindingCommand, key, container);
  }

}

exports.BindingCommandDefinition = BindingCommandDefinition;
const BindingCommand = {
  name: _kernel.Protocol.resource.keyFor('binding-command'),

  keyFrom(name) {
    return `${BindingCommand.name}:${name}`;
  },

  isType(value) {
    return typeof value === 'function' && _kernel.Metadata.hasOwn(BindingCommand.name, value);
  },

  define(nameOrDef, Type) {
    const definition = BindingCommandDefinition.create(nameOrDef, Type);

    _kernel.Metadata.define(BindingCommand.name, definition, definition.Type);

    _kernel.Metadata.define(BindingCommand.name, definition, definition);

    _kernel.Protocol.resource.appendTo(Type, BindingCommand.name);

    return definition.Type;
  },

  getDefinition(Type) {
    const def = _kernel.Metadata.getOwn(BindingCommand.name, Type);

    if (def === void 0) {
      throw new Error(`No definition found for type ${Type.name}`);
    }

    return def;
  },

  annotate(Type, prop, value) {
    _kernel.Metadata.define(_kernel.Protocol.annotation.keyFor(prop), value, Type);
  },

  getAnnotation(Type, prop) {
    return _kernel.Metadata.getOwn(_kernel.Protocol.annotation.keyFor(prop), Type);
  }

};
exports.BindingCommand = BindingCommand;

function getTarget(binding, makeCamelCase) {
  if (binding.flags & 256
  /* isBinding */
  ) {
      return binding.bindable.propName;
    } else if (makeCamelCase) {
    return (0, _kernel.camelCase)(binding.syntax.target);
  } else {
    return binding.syntax.target;
  }
}

let OneTimeBindingCommand = class OneTimeBindingCommand {
  constructor() {
    this.bindingType = 49
    /* OneTimeCommand */
    ;
  }

  compile(binding) {
    return new _renderer.PropertyBindingInstruction(binding.expression, getTarget(binding, false), _runtime.BindingMode.oneTime);
  }

};
exports.OneTimeBindingCommand = OneTimeBindingCommand;
exports.OneTimeBindingCommand = OneTimeBindingCommand = __decorate([bindingCommand('one-time')], OneTimeBindingCommand);
let ToViewBindingCommand = class ToViewBindingCommand {
  constructor() {
    this.bindingType = 50
    /* ToViewCommand */
    ;
  }

  compile(binding) {
    return new _renderer.PropertyBindingInstruction(binding.expression, getTarget(binding, false), _runtime.BindingMode.toView);
  }

};
exports.ToViewBindingCommand = ToViewBindingCommand;
exports.ToViewBindingCommand = ToViewBindingCommand = __decorate([bindingCommand('to-view')], ToViewBindingCommand);
let FromViewBindingCommand = class FromViewBindingCommand {
  constructor() {
    this.bindingType = 51
    /* FromViewCommand */
    ;
  }

  compile(binding) {
    return new _renderer.PropertyBindingInstruction(binding.expression, getTarget(binding, false), _runtime.BindingMode.fromView);
  }

};
exports.FromViewBindingCommand = FromViewBindingCommand;
exports.FromViewBindingCommand = FromViewBindingCommand = __decorate([bindingCommand('from-view')], FromViewBindingCommand);
let TwoWayBindingCommand = class TwoWayBindingCommand {
  constructor() {
    this.bindingType = 52
    /* TwoWayCommand */
    ;
  }

  compile(binding) {
    return new _renderer.PropertyBindingInstruction(binding.expression, getTarget(binding, false), _runtime.BindingMode.twoWay);
  }

};
exports.TwoWayBindingCommand = TwoWayBindingCommand;
exports.TwoWayBindingCommand = TwoWayBindingCommand = __decorate([bindingCommand('two-way')], TwoWayBindingCommand);
let DefaultBindingCommand = class DefaultBindingCommand {
  constructor() {
    this.bindingType = 53
    /* BindCommand */
    ;
  }

  compile(binding) {
    let mode = _runtime.BindingMode.default;

    if (binding instanceof _semanticModel.BindingSymbol) {
      mode = binding.bindable.mode;
    } else {
      const command = binding.syntax.command;

      switch (command) {
        case 'bind':
        case 'to-view':
          mode = _runtime.BindingMode.toView;
          break;

        case 'one-time':
          mode = _runtime.BindingMode.oneTime;
          break;

        case 'from-view':
          mode = _runtime.BindingMode.fromView;
          break;

        case 'two-way':
          mode = _runtime.BindingMode.twoWay;
          break;
      }
    }

    return new _renderer.PropertyBindingInstruction(binding.expression, getTarget(binding, false), mode === _runtime.BindingMode.default ? _runtime.BindingMode.toView : mode);
  }

};
exports.DefaultBindingCommand = DefaultBindingCommand;
exports.DefaultBindingCommand = DefaultBindingCommand = __decorate([bindingCommand('bind')], DefaultBindingCommand);
let CallBindingCommand = class CallBindingCommand {
  constructor() {
    this.bindingType = 153
    /* CallCommand */
    ;
  }

  compile(binding) {
    return new _renderer.CallBindingInstruction(binding.expression, getTarget(binding, true));
  }

};
exports.CallBindingCommand = CallBindingCommand;
exports.CallBindingCommand = CallBindingCommand = __decorate([bindingCommand('call')], CallBindingCommand);
let ForBindingCommand = class ForBindingCommand {
  constructor() {
    this.bindingType = 539
    /* ForCommand */
    ;
  }

  compile(binding) {
    return new _renderer.IteratorBindingInstruction(binding.expression, getTarget(binding, false));
  }

};
exports.ForBindingCommand = ForBindingCommand;
exports.ForBindingCommand = ForBindingCommand = __decorate([bindingCommand('for')], ForBindingCommand);
let TriggerBindingCommand = class TriggerBindingCommand {
  constructor() {
    this.bindingType = 4182
    /* TriggerCommand */
    ;
  }

  compile(binding) {
    return new _renderer.ListenerBindingInstruction(binding.expression, getTarget(binding, false), true, _runtime.DelegationStrategy.none);
  }

};
exports.TriggerBindingCommand = TriggerBindingCommand;
exports.TriggerBindingCommand = TriggerBindingCommand = __decorate([bindingCommand('trigger')], TriggerBindingCommand);
let DelegateBindingCommand = class DelegateBindingCommand {
  constructor() {
    this.bindingType = 4184
    /* DelegateCommand */
    ;
  }

  compile(binding) {
    return new _renderer.ListenerBindingInstruction(binding.expression, getTarget(binding, false), false, _runtime.DelegationStrategy.bubbling);
  }

};
exports.DelegateBindingCommand = DelegateBindingCommand;
exports.DelegateBindingCommand = DelegateBindingCommand = __decorate([bindingCommand('delegate')], DelegateBindingCommand);
let CaptureBindingCommand = class CaptureBindingCommand {
  constructor() {
    this.bindingType = 4183
    /* CaptureCommand */
    ;
  }

  compile(binding) {
    return new _renderer.ListenerBindingInstruction(binding.expression, getTarget(binding, false), false, _runtime.DelegationStrategy.capturing);
  }

};
exports.CaptureBindingCommand = CaptureBindingCommand;
exports.CaptureBindingCommand = CaptureBindingCommand = __decorate([bindingCommand('capture')], CaptureBindingCommand);

/**
 * Attr binding command. Compile attr with binding symbol with command `attr` to `AttributeBindingInstruction`
 */
let AttrBindingCommand = class AttrBindingCommand {
  constructor() {
    this.bindingType = 32
    /* IsProperty */
    ;
  }

  compile(binding) {
    const target = getTarget(binding, false);
    return new _renderer.AttributeBindingInstruction(target, binding.expression, target);
  }

};
exports.AttrBindingCommand = AttrBindingCommand;
exports.AttrBindingCommand = AttrBindingCommand = __decorate([bindingCommand('attr')], AttrBindingCommand);

/**
 * Style binding command. Compile attr with binding symbol with command `style` to `AttributeBindingInstruction`
 */
let StyleBindingCommand = class StyleBindingCommand {
  constructor() {
    this.bindingType = 32
    /* IsProperty */
    ;
  }

  compile(binding) {
    return new _renderer.AttributeBindingInstruction('style', binding.expression, getTarget(binding, false));
  }

};
exports.StyleBindingCommand = StyleBindingCommand;
exports.StyleBindingCommand = StyleBindingCommand = __decorate([bindingCommand('style')], StyleBindingCommand);

/**
 * Class binding command. Compile attr with binding symbol with command `class` to `AttributeBindingInstruction`
 */
let ClassBindingCommand = class ClassBindingCommand {
  constructor() {
    this.bindingType = 32
    /* IsProperty */
    ;
  }

  compile(binding) {
    return new _renderer.AttributeBindingInstruction('class', binding.expression, getTarget(binding, false));
  }

};
exports.ClassBindingCommand = ClassBindingCommand;
exports.ClassBindingCommand = ClassBindingCommand = __decorate([bindingCommand('class')], ClassBindingCommand);

/**
 * Binding command to refer different targets (element, custom element/attribute view models, controller) attached to an element
 */
let RefBindingCommand = class RefBindingCommand {
  constructor() {
    this.bindingType = 32
    /* IsProperty */
    | 4096
    /* IgnoreCustomAttr */
    ;
  }

  compile(binding) {
    return new _renderer.RefBindingInstruction(binding.expression, getTarget(binding, false));
  }

};
exports.RefBindingCommand = RefBindingCommand;
exports.RefBindingCommand = RefBindingCommand = __decorate([bindingCommand('ref')], RefBindingCommand);
});

;define.alias('@aurelia/runtime-html/resources/binding-command.js','@aurelia/runtime-html/dist/esm/resources/binding-command.js');
define('@aurelia/runtime-html/dist/esm/resources/custom-attribute.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime','../bindable.js','../watch.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.customAttribute = customAttribute;
exports.templateController = templateController;
exports.CustomAttribute = exports.CustomAttributeDefinition = void 0;

var _kernel = require("@aurelia/kernel");

var _runtime = require("@aurelia/runtime");

var _bindable = require("../bindable.js");

var _watch = require("../watch.js");

function customAttribute(nameOrDef) {
  return function (target) {
    return CustomAttribute.define(nameOrDef, target);
  };
}

function templateController(nameOrDef) {
  return function (target) {
    return CustomAttribute.define(typeof nameOrDef === 'string' ? {
      isTemplateController: true,
      name: nameOrDef
    } : {
      isTemplateController: true,
      ...nameOrDef
    }, target);
  };
}

class CustomAttributeDefinition {
  constructor(Type, name, aliases, key, defaultBindingMode, isTemplateController, bindables, noMultiBindings, watches) {
    this.Type = Type;
    this.name = name;
    this.aliases = aliases;
    this.key = key;
    this.defaultBindingMode = defaultBindingMode;
    this.isTemplateController = isTemplateController;
    this.bindables = bindables;
    this.noMultiBindings = noMultiBindings;
    this.watches = watches;
  }

  static create(nameOrDef, Type) {
    let name;
    let def;

    if (typeof nameOrDef === 'string') {
      name = nameOrDef;
      def = {
        name
      };
    } else {
      name = nameOrDef.name;
      def = nameOrDef;
    }

    return new CustomAttributeDefinition(Type, (0, _kernel.firstDefined)(CustomAttribute.getAnnotation(Type, 'name'), name), (0, _kernel.mergeArrays)(CustomAttribute.getAnnotation(Type, 'aliases'), def.aliases, Type.aliases), CustomAttribute.keyFrom(name), (0, _kernel.firstDefined)(CustomAttribute.getAnnotation(Type, 'defaultBindingMode'), def.defaultBindingMode, Type.defaultBindingMode, _runtime.BindingMode.toView), (0, _kernel.firstDefined)(CustomAttribute.getAnnotation(Type, 'isTemplateController'), def.isTemplateController, Type.isTemplateController, false), _bindable.Bindable.from(..._bindable.Bindable.getAll(Type), CustomAttribute.getAnnotation(Type, 'bindables'), Type.bindables, def.bindables), (0, _kernel.firstDefined)(CustomAttribute.getAnnotation(Type, 'noMultiBindings'), def.noMultiBindings, Type.noMultiBindings, false), (0, _kernel.mergeArrays)(_watch.Watch.getAnnotation(Type), Type.watches));
  }

  register(container) {
    const {
      Type,
      key,
      aliases
    } = this;

    _kernel.Registration.transient(key, Type).register(container);

    _kernel.Registration.aliasTo(key, Type).register(container);

    (0, _runtime.registerAliases)(aliases, CustomAttribute, key, container);
  }

}

exports.CustomAttributeDefinition = CustomAttributeDefinition;
const CustomAttribute = {
  name: _kernel.Protocol.resource.keyFor('custom-attribute'),

  keyFrom(name) {
    return `${CustomAttribute.name}:${name}`;
  },

  isType(value) {
    return typeof value === 'function' && _kernel.Metadata.hasOwn(CustomAttribute.name, value);
  },

  for(node, name) {
    return _kernel.Metadata.getOwn(CustomAttribute.keyFrom(name), node);
  },

  define(nameOrDef, Type) {
    const definition = CustomAttributeDefinition.create(nameOrDef, Type);

    _kernel.Metadata.define(CustomAttribute.name, definition, definition.Type);

    _kernel.Metadata.define(CustomAttribute.name, definition, definition);

    _kernel.Protocol.resource.appendTo(Type, CustomAttribute.name);

    return definition.Type;
  },

  getDefinition(Type) {
    const def = _kernel.Metadata.getOwn(CustomAttribute.name, Type);

    if (def === void 0) {
      throw new Error(`No definition found for type ${Type.name}`);
    }

    return def;
  },

  annotate(Type, prop, value) {
    _kernel.Metadata.define(_kernel.Protocol.annotation.keyFor(prop), value, Type);
  },

  getAnnotation(Type, prop) {
    return _kernel.Metadata.getOwn(_kernel.Protocol.annotation.keyFor(prop), Type);
  }

};
exports.CustomAttribute = CustomAttribute;
});

;define.alias('@aurelia/runtime-html/resources/custom-attribute.js','@aurelia/runtime-html/dist/esm/resources/custom-attribute.js');
define('@aurelia/runtime-html/dist/esm/resources/custom-attributes/blur.js',['require','exports','module','@aurelia/kernel','../../dom.js','../../platform.js','../custom-attribute.js','../../bindable.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.Blur = exports.BlurManager = void 0;

var _kernel = require("@aurelia/kernel");

var _dom = require("../../dom.js");

var _platform = require("../../platform.js");

var _customAttribute = require("../custom-attribute.js");

var _bindable = require("../../bindable.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

const unset = Symbol(); // Using passive to help with performance

const defaultCaptureEventInit = {
  passive: true,
  capture: true
}; // Using passive to help with performance

const defaultBubbleEventInit = {
  passive: true
}; // weakly connect a document to a blur manager
// to avoid polluting the document properties

const blurDocMap = new WeakMap();

class BlurManager {
  constructor(platform) {
    this.platform = platform;
    this.blurs = [];
    blurDocMap.set(platform.document, this);
    this.handler = createHandler(this, this.blurs);
  }

  static createFor(platform) {
    return blurDocMap.get(platform.document) || new BlurManager(platform);
  }

  register(blur) {
    const blurs = this.blurs;

    if (!blurs.includes(blur) && blurs.push(blur) === 1) {
      this.addListeners();
    }
  }

  unregister(blur) {
    const blurs = this.blurs;
    const index = blurs.indexOf(blur);

    if (index > -1) {
      blurs.splice(index, 1);
    }

    if (blurs.length === 0) {
      this.removeListeners();
    }
  }

  addListeners() {
    const p = this.platform;
    const doc = p.document;
    const win = p.window;
    const handler = this.handler;

    if (win.navigator.pointerEnabled) {
      doc.addEventListener('pointerdown', handler, defaultCaptureEventInit);
    }

    doc.addEventListener('touchstart', handler, defaultCaptureEventInit);
    doc.addEventListener('mousedown', handler, defaultCaptureEventInit);
    doc.addEventListener('focus', handler, defaultCaptureEventInit);
    win.addEventListener('blur', handler, defaultBubbleEventInit);
  }

  removeListeners() {
    const p = this.platform;
    const doc = p.document;
    const win = p.window;
    const handler = this.handler;

    if (win.navigator.pointerEnabled) {
      doc.removeEventListener('pointerdown', handler, defaultCaptureEventInit);
    }

    doc.removeEventListener('touchstart', handler, defaultCaptureEventInit);
    doc.removeEventListener('mousedown', handler, defaultCaptureEventInit);
    doc.removeEventListener('focus', handler, defaultCaptureEventInit);
    win.removeEventListener('blur', handler, defaultBubbleEventInit);
  }

}

exports.BlurManager = BlurManager;
let Blur = class Blur {
  constructor(element, p) {
    this.element = element;
    this.p = p;
    /**
     * By default, the behavior should be least surprise possible, that:
     *
     * it searches for anything from root context,
     * and root context is document body
     */

    this.linkedMultiple = true;
    this.searchSubTree = true;
    this.linkingContext = null;
    this.value = unset;
    this.manager = BlurManager.createFor(p);
  }

  attached() {
    this.manager.register(this);
  }

  detaching() {
    this.manager.unregister(this);
  }

  handleEventTarget(target) {
    if (this.value === false) {
      return;
    }

    const p = this.p;

    if (target === p.window || target === p.document || !this.contains(target)) {
      this.triggerBlur();
    }
  }

  contains(target) {
    if (!this.value) {
      return false;
    }

    let els;
    let i;
    let j, jj;
    let link;
    const element = this.element;

    if (containsElementOrShadowRoot(element, target)) {
      return true;
    }

    if (!this.linkedWith) {
      return false;
    }

    const doc = this.p.document;
    const linkedWith = this.linkedWith;
    const linkingContext = this.linkingContext;
    const searchSubTree = this.searchSubTree;
    const linkedMultiple = this.linkedMultiple;
    const links = Array.isArray(linkedWith) ? linkedWith : [linkedWith];
    const contextNode = (typeof linkingContext === 'string' ? doc.querySelector(linkingContext) : linkingContext) || doc.body;
    const ii = links.length;

    for (i = 0; ii > i; ++i) {
      link = links[i]; // When user specify to link with something by a string, it acts as a CSS selector
      // We need to do some querying stuff to determine if target above is contained.

      if (typeof link === 'string') {
        // Default behavior, search the whole tree, from context that user specified, which default to document body
        if (searchSubTree) {
          // todo: are there too many knobs?? Consider remove "linkedMultiple"??
          if (!linkedMultiple) {
            const el = contextNode.querySelector(link);
            els = el !== null ? [el] : _kernel.emptyArray;
          } else {
            els = contextNode.querySelectorAll(link);
          }

          jj = els.length;

          for (j = 0; jj > j; ++j) {
            if (els[j].contains(target)) {
              return true;
            }
          }
        } else {
          // default to document body, if user didn't define a linking context, and wanted to ignore subtree.
          // This is specifically performant and useful for dialogs, plugins
          // that usually generate contents to document body
          els = contextNode.children;
          jj = els.length;

          for (j = 0; jj > j; ++j) {
            if (els[j].matches(link)) {
              return true;
            }
          }
        }
      } else {
        // When user passed in something that is not a string,
        // simply check if has method `contains` (allow duck typing)
        // and call it against target.
        // This enables flexible usages
        if (link && link.contains(target)) {
          return true;
        }
      }
    }

    return false;
  }

  triggerBlur() {
    this.value = false;

    if (typeof this.onBlur === 'function') {
      this.onBlur.call(null);
    }
  }

};
exports.Blur = Blur;

__decorate([(0, _bindable.bindable)()], Blur.prototype, "value", void 0);

__decorate([(0, _bindable.bindable)()], Blur.prototype, "onBlur", void 0);

__decorate([(0, _bindable.bindable)()], Blur.prototype, "linkedWith", void 0);

__decorate([(0, _bindable.bindable)()], Blur.prototype, "linkedMultiple", void 0);

__decorate([(0, _bindable.bindable)()], Blur.prototype, "searchSubTree", void 0);

__decorate([(0, _bindable.bindable)()], Blur.prototype, "linkingContext", void 0);

exports.Blur = Blur = __decorate([(0, _customAttribute.customAttribute)('blur'), __param(0, _dom.INode), __param(1, _platform.IPlatform)], Blur);

const containsElementOrShadowRoot = (container, target) => {
  if (container.contains(target)) {
    return true;
  }

  let parentNode = null;

  while (target != null) {
    if (target === container) {
      return true;
    }

    parentNode = target.parentNode;

    if (parentNode === null && target.nodeType === 11
    /* DocumentFragment */
    ) {
        target = target.host;
        continue;
      }

    target = parentNode;
  }

  return false;
};

const createHandler = (manager, checkTargets) => {
  // *******************************
  // EVENTS ORDER
  // -----------------------------
  // pointerdown
  // touchstart
  // pointerup
  // touchend
  // mousedown
  // --------------
  // BLUR
  // FOCUS
  // --------------
  // mouseup
  // click
  //
  // ******************************
  //
  // There are cases focus happens without mouse interaction (keyboard)
  // So it needs to capture both mouse / focus movement
  //
  // ******************************
  let hasChecked = false;

  const revertCheckage = () => {
    hasChecked = false;
  };

  const markChecked = () => {
    hasChecked = true;
    manager.platform.domWriteQueue.queueTask(revertCheckage, {
      preempt: true
    });
  };

  const handleMousedown = e => {
    if (!hasChecked) {
      handleEvent(e);
      markChecked();
    }
  };
  /**
   * Handle globally captured focus event
   * This can happen via a few way:
   * User clicks on a focusable element
   * User uses keyboard to navigate to a focusable element
   * User goes back to the window from another browser tab
   * User clicks on a non-focusable element
   * User clicks on the window, outside of the document
   */


  const handleFocus = e => {
    if (hasChecked) {
      return;
    } // there are two way a focus gets captured on window
    // when the windows itself got focus
    // and when an element in the document gets focus
    // when the window itself got focus, reacting to it is quite unnecessary
    // as it doesn't really affect element inside the document
    // Do a simple check and bail immediately


    const isWindow = e.target === manager.platform.window;

    if (isWindow) {
      for (let i = 0, ii = checkTargets.length; ii > i; ++i) {
        checkTargets[i].triggerBlur();
      }
    } else {
      handleEvent(e);
    }

    markChecked();
  };

  const handleWindowBlur = () => {
    hasChecked = false;

    for (let i = 0, ii = checkTargets.length; i < ii; ++i) {
      checkTargets[i].triggerBlur();
    }
  };

  const handleEvent = e => {
    const target = e.composed ? e.composedPath()[0] : e.target;

    if (target === null) {
      return;
    }

    for (let i = 0, ii = checkTargets.length; i < ii; ++i) {
      checkTargets[i].handleEventTarget(target);
    }
  };

  return {
    onpointerdown: handleMousedown,
    ontouchstart: handleMousedown,
    onmousedown: handleMousedown,
    onfocus: handleFocus,
    onblur: handleWindowBlur,

    handleEvent(e) {
      this[`on${e.type}`](e);
    }

  };
};
});

;define.alias('@aurelia/runtime-html/resources/custom-attributes/blur.js','@aurelia/runtime-html/dist/esm/resources/custom-attributes/blur.js');
define('@aurelia/runtime-html/dist/esm/resources/custom-attributes/focus.js',['require','exports','module','@aurelia/runtime','../../dom.js','../../platform.js','../custom-attribute.js','../../bindable.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.Focus = void 0;

var _runtime = require("@aurelia/runtime");

var _dom = require("../../dom.js");

var _platform = require("../../platform.js");

var _customAttribute = require("../custom-attribute.js");

var _bindable = require("../../bindable.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

/**
 * Focus attribute for element focus binding
 */
let Focus = class Focus {
  constructor(element, p) {
    this.element = element;
    this.p = p;
    /**
     * Indicates whether `apply` should be called when `attached` callback is invoked
     */

    this.needsApply = false;
  }

  binding() {
    this.valueChanged();
  }
  /**
   * Invoked everytime the bound value changes.
   *
   * @param newValue - The new value.
   */


  valueChanged() {
    // In theory, we could/should react immediately
    // but focus state of an element cannot be achieved
    // while it's disconnected from the document
    // thus, there neesd to be a check if it's currently connected or not
    // before applying the value to the element
    if (this.$controller.isActive) {
      this.apply();
    } else {
      // If the element is not currently connect
      // toggle the flag to add pending work for later
      // in attached lifecycle
      this.needsApply = true;
    }
  }
  /**
   * Invoked when the attribute is attached to the DOM.
   */


  attached() {
    if (this.needsApply) {
      this.needsApply = false;
      this.apply();
    }

    const el = this.element;
    el.addEventListener('focus', this);
    el.addEventListener('blur', this);
  }
  /**
   * Invoked when the attribute is afterDetachChildren from the DOM.
   */


  afterDetachChildren() {
    const el = this.element;
    el.removeEventListener('focus', this);
    el.removeEventListener('blur', this);
  }
  /**
   * EventTarget interface handler for better memory usage
   */


  handleEvent(e) {
    // there are only two event listened to
    // if the even is focus, it menans the element is focused
    // only need to switch the value to true
    if (e.type === 'focus') {
      this.value = true;
    } else if (!this.isElFocused) {
      // else, it's blur event
      // when a blur event happens, there are two situations
      // 1. the element itself lost the focus
      // 2. window lost the focus
      // To handle both (1) and (2), only need to check if
      // current active element is still the same element of this focus custom attribute
      // If it's not, it's a blur event happened on Window because the browser tab lost focus
      this.value = false;
    }
  }
  /**
   * Focus/blur based on current value
   */


  apply() {
    const el = this.element;
    const isFocused = this.isElFocused;
    const shouldFocus = this.value;

    if (shouldFocus && !isFocused) {
      el.focus();
    } else if (!shouldFocus && isFocused) {
      el.blur();
    }
  }

  get isElFocused() {
    return this.element === this.p.document.activeElement;
  }

};
exports.Focus = Focus;

__decorate([(0, _bindable.bindable)({
  mode: _runtime.BindingMode.twoWay
})], Focus.prototype, "value", void 0);

exports.Focus = Focus = __decorate([(0, _customAttribute.customAttribute)('focus'), __param(0, _dom.INode), __param(1, _platform.IPlatform)], Focus);
});

;define.alias('@aurelia/runtime-html/resources/custom-attributes/focus.js','@aurelia/runtime-html/dist/esm/resources/custom-attributes/focus.js');
define('@aurelia/runtime-html/dist/esm/resources/custom-attributes/show.js',['require','exports','module','@aurelia/runtime','../../dom.js','../../platform.js','../custom-attribute.js','../../bindable.js','../../renderer.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.Show = void 0;

var _runtime = require("@aurelia/runtime");

var _dom = require("../../dom.js");

var _platform = require("../../platform.js");

var _customAttribute = require("../custom-attribute.js");

var _bindable = require("../../bindable.js");

var _renderer = require("../../renderer.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

let Show = class Show {
  constructor(el, p, instr) {
    this.el = el;
    this.p = p;
    this.isActive = false;
    this.task = null;
    this.$val = '';
    this.$prio = '';

    this.update = () => {
      this.task = null; // Only compare at the synchronous moment when we're about to update, because the value might have changed since the update was queued.

      if (Boolean(this.value) !== this.isToggled) {
        if (this.isToggled === this.base) {
          this.isToggled = !this.base; // Note: in v1 we used the 'au-hide' class, but in v2 it's so trivial to conditionally apply classes (e.g. 'hide.class="someCondition"'),
          // that it's probably better to avoid the CSS inject infra involvement and keep this CA as simple as possible.
          // Instead, just store and restore the property values (with each mutation, to account for in-between updates), to cover the common cases, until there is convincing feedback to do otherwise.

          this.$val = this.el.style.getPropertyValue('display');
          this.$prio = this.el.style.getPropertyPriority('display');
          this.el.style.setProperty('display', 'none', 'important');
        } else {
          this.isToggled = this.base;
          this.el.style.setProperty('display', this.$val, this.$prio); // If the style attribute is now empty, remove it.

          if (this.el.getAttribute('style') === '') {
            this.el.removeAttribute('style');
          }
        }
      }
    }; // if this is declared as a 'hide' attribute, then this.base will be false, inverting everything.


    this.isToggled = this.base = instr.alias !== 'hide';
  }

  binding() {
    this.isActive = true;
    this.update();
  }

  detaching() {
    this.isActive = false;
    this.task?.cancel();
    this.task = null;
  }

  valueChanged() {
    if (this.isActive && this.task === null) {
      this.task = this.p.domWriteQueue.queueTask(this.update);
    }
  }

};
exports.Show = Show;

__decorate([_bindable.bindable], Show.prototype, "value", void 0);

exports.Show = Show = __decorate([(0, _customAttribute.customAttribute)('show'), (0, _runtime.alias)('hide'), __param(0, _dom.INode), __param(1, _platform.IPlatform), __param(2, _renderer.IInstruction)], Show);
});

;define.alias('@aurelia/runtime-html/resources/custom-attributes/show.js','@aurelia/runtime-html/dist/esm/resources/custom-attributes/show.js');
define('@aurelia/runtime-html/dist/esm/resources/custom-element.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime','../bindable.js','../dom.js','../templating/children.js','../watch.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.customElement = customElement;
exports.useShadowDOM = useShadowDOM;
exports.containerless = containerless;
exports.strict = strict;
exports.CustomElement = exports.CustomElementDefinition = void 0;

var _kernel = require("@aurelia/kernel");

var _runtime = require("@aurelia/runtime");

var _bindable = require("../bindable.js");

var _dom = require("../dom.js");

var _children = require("../templating/children.js");

var _watch = require("../watch.js");

function customElement(nameOrDef) {
  return function (target) {
    return CustomElement.define(nameOrDef, target);
  };
}

function useShadowDOM(targetOrOptions) {
  if (targetOrOptions === void 0) {
    return function ($target) {
      CustomElement.annotate($target, 'shadowOptions', {
        mode: 'open'
      });
    };
  }

  if (typeof targetOrOptions !== 'function') {
    return function ($target) {
      CustomElement.annotate($target, 'shadowOptions', targetOrOptions);
    };
  }

  CustomElement.annotate(targetOrOptions, 'shadowOptions', {
    mode: 'open'
  });
}

function containerless(target) {
  if (target === void 0) {
    return function ($target) {
      CustomElement.annotate($target, 'containerless', true);
    };
  }

  CustomElement.annotate(target, 'containerless', true);
}

function strict(target) {
  if (target === void 0) {
    return function ($target) {
      CustomElement.annotate($target, 'isStrictBinding', true);
    };
  }

  CustomElement.annotate(target, 'isStrictBinding', true);
}

const definitionLookup = new WeakMap();

class CustomElementDefinition {
  constructor(Type, name, aliases, key, cache, template, instructions, dependencies, injectable, needsCompile, surrogates, bindables, childrenObservers, containerless, isStrictBinding, shadowOptions, hasSlots, enhance, projectionsMap, watches) {
    this.Type = Type;
    this.name = name;
    this.aliases = aliases;
    this.key = key;
    this.cache = cache;
    this.template = template;
    this.instructions = instructions;
    this.dependencies = dependencies;
    this.injectable = injectable;
    this.needsCompile = needsCompile;
    this.surrogates = surrogates;
    this.bindables = bindables;
    this.childrenObservers = childrenObservers;
    this.containerless = containerless;
    this.isStrictBinding = isStrictBinding;
    this.shadowOptions = shadowOptions;
    this.hasSlots = hasSlots;
    this.enhance = enhance;
    this.projectionsMap = projectionsMap;
    this.watches = watches;
  }

  static create(nameOrDef, Type = null) {
    if (Type === null) {
      const def = nameOrDef;

      if (typeof def === 'string') {
        throw new Error(`Cannot create a custom element definition with only a name and no type: ${nameOrDef}`);
      }

      const name = (0, _kernel.fromDefinitionOrDefault)('name', def, CustomElement.generateName);

      if (typeof def.Type === 'function') {
        // This needs to be a clone (it will usually be the compiler calling this signature)
        // TODO: we need to make sure it's documented that passing in the type via the definition (while passing in null
        // as the "Type" parameter) effectively skips type analysis, so it should only be used this way for cloning purposes.
        Type = def.Type;
      } else {
        Type = CustomElement.generateType((0, _kernel.pascalCase)(name));
      }

      return new CustomElementDefinition(Type, name, (0, _kernel.mergeArrays)(def.aliases), (0, _kernel.fromDefinitionOrDefault)('key', def, () => CustomElement.keyFrom(name)), (0, _kernel.fromDefinitionOrDefault)('cache', def, () => 0), (0, _kernel.fromDefinitionOrDefault)('template', def, () => null), (0, _kernel.mergeArrays)(def.instructions), (0, _kernel.mergeArrays)(def.dependencies), (0, _kernel.fromDefinitionOrDefault)('injectable', def, () => null), (0, _kernel.fromDefinitionOrDefault)('needsCompile', def, () => true), (0, _kernel.mergeArrays)(def.surrogates), _bindable.Bindable.from(def.bindables), _children.Children.from(def.childrenObservers), (0, _kernel.fromDefinitionOrDefault)('containerless', def, () => false), (0, _kernel.fromDefinitionOrDefault)('isStrictBinding', def, () => false), (0, _kernel.fromDefinitionOrDefault)('shadowOptions', def, () => null), (0, _kernel.fromDefinitionOrDefault)('hasSlots', def, () => false), (0, _kernel.fromDefinitionOrDefault)('enhance', def, () => false), (0, _kernel.fromDefinitionOrDefault)('projectionsMap', def, () => new Map()), (0, _kernel.fromDefinitionOrDefault)('watches', def, () => _kernel.emptyArray));
    } // If a type is passed in, we ignore the Type property on the definition if it exists.
    // TODO: document this behavior


    if (typeof nameOrDef === 'string') {
      return new CustomElementDefinition(Type, nameOrDef, (0, _kernel.mergeArrays)(CustomElement.getAnnotation(Type, 'aliases'), Type.aliases), CustomElement.keyFrom(nameOrDef), (0, _kernel.fromAnnotationOrTypeOrDefault)('cache', Type, () => 0), (0, _kernel.fromAnnotationOrTypeOrDefault)('template', Type, () => null), (0, _kernel.mergeArrays)(CustomElement.getAnnotation(Type, 'instructions'), Type.instructions), (0, _kernel.mergeArrays)(CustomElement.getAnnotation(Type, 'dependencies'), Type.dependencies), (0, _kernel.fromAnnotationOrTypeOrDefault)('injectable', Type, () => null), (0, _kernel.fromAnnotationOrTypeOrDefault)('needsCompile', Type, () => true), (0, _kernel.mergeArrays)(CustomElement.getAnnotation(Type, 'surrogates'), Type.surrogates), _bindable.Bindable.from(..._bindable.Bindable.getAll(Type), CustomElement.getAnnotation(Type, 'bindables'), Type.bindables), _children.Children.from(..._children.Children.getAll(Type), CustomElement.getAnnotation(Type, 'childrenObservers'), Type.childrenObservers), (0, _kernel.fromAnnotationOrTypeOrDefault)('containerless', Type, () => false), (0, _kernel.fromAnnotationOrTypeOrDefault)('isStrictBinding', Type, () => false), (0, _kernel.fromAnnotationOrTypeOrDefault)('shadowOptions', Type, () => null), (0, _kernel.fromAnnotationOrTypeOrDefault)('hasSlots', Type, () => false), (0, _kernel.fromAnnotationOrTypeOrDefault)('enhance', Type, () => false), (0, _kernel.fromAnnotationOrTypeOrDefault)('projectionsMap', Type, () => new Map()), (0, _kernel.mergeArrays)(_watch.Watch.getAnnotation(Type), Type.watches));
    } // This is the typical default behavior, e.g. from regular CustomElement.define invocations or from @customElement deco
    // The ViewValueConverter also uses this signature and passes in a definition where everything except for the 'hooks'
    // property needs to be copied. So we have that exception for 'hooks', but we may need to revisit that default behavior
    // if this turns out to be too opinionated.


    const name = (0, _kernel.fromDefinitionOrDefault)('name', nameOrDef, CustomElement.generateName);
    return new CustomElementDefinition(Type, name, (0, _kernel.mergeArrays)(CustomElement.getAnnotation(Type, 'aliases'), nameOrDef.aliases, Type.aliases), CustomElement.keyFrom(name), (0, _kernel.fromAnnotationOrDefinitionOrTypeOrDefault)('cache', nameOrDef, Type, () => 0), (0, _kernel.fromAnnotationOrDefinitionOrTypeOrDefault)('template', nameOrDef, Type, () => null), (0, _kernel.mergeArrays)(CustomElement.getAnnotation(Type, 'instructions'), nameOrDef.instructions, Type.instructions), (0, _kernel.mergeArrays)(CustomElement.getAnnotation(Type, 'dependencies'), nameOrDef.dependencies, Type.dependencies), (0, _kernel.fromAnnotationOrDefinitionOrTypeOrDefault)('injectable', nameOrDef, Type, () => null), (0, _kernel.fromAnnotationOrDefinitionOrTypeOrDefault)('needsCompile', nameOrDef, Type, () => true), (0, _kernel.mergeArrays)(CustomElement.getAnnotation(Type, 'surrogates'), nameOrDef.surrogates, Type.surrogates), _bindable.Bindable.from(..._bindable.Bindable.getAll(Type), CustomElement.getAnnotation(Type, 'bindables'), Type.bindables, nameOrDef.bindables), _children.Children.from(..._children.Children.getAll(Type), CustomElement.getAnnotation(Type, 'childrenObservers'), Type.childrenObservers, nameOrDef.childrenObservers), (0, _kernel.fromAnnotationOrDefinitionOrTypeOrDefault)('containerless', nameOrDef, Type, () => false), (0, _kernel.fromAnnotationOrDefinitionOrTypeOrDefault)('isStrictBinding', nameOrDef, Type, () => false), (0, _kernel.fromAnnotationOrDefinitionOrTypeOrDefault)('shadowOptions', nameOrDef, Type, () => null), (0, _kernel.fromAnnotationOrDefinitionOrTypeOrDefault)('hasSlots', nameOrDef, Type, () => false), (0, _kernel.fromAnnotationOrDefinitionOrTypeOrDefault)('enhance', nameOrDef, Type, () => false), (0, _kernel.fromAnnotationOrDefinitionOrTypeOrDefault)('projectionsMap', nameOrDef, Type, () => new Map()), (0, _kernel.mergeArrays)(nameOrDef.watches, _watch.Watch.getAnnotation(Type), Type.watches));
  }

  static getOrCreate(partialDefinition) {
    if (partialDefinition instanceof CustomElementDefinition) {
      return partialDefinition;
    }

    if (definitionLookup.has(partialDefinition)) {
      return definitionLookup.get(partialDefinition);
    }

    const definition = CustomElementDefinition.create(partialDefinition);
    definitionLookup.set(partialDefinition, definition); // Make sure the full definition can be retrieved from dynamically created classes as well

    _kernel.Metadata.define(CustomElement.name, definition, definition.Type);

    return definition;
  }

  register(container) {
    const {
      Type,
      key,
      aliases
    } = this;

    _kernel.Registration.transient(key, Type).register(container);

    _kernel.Registration.aliasTo(key, Type).register(container);

    (0, _runtime.registerAliases)(aliases, CustomElement, key, container);
  }

}

exports.CustomElementDefinition = CustomElementDefinition;
const defaultForOpts = {
  name: undefined,
  searchParents: false,
  optional: false
};
const CustomElement = {
  name: _kernel.Protocol.resource.keyFor('custom-element'),

  keyFrom(name) {
    return `${CustomElement.name}:${name}`;
  },

  isType(value) {
    return typeof value === 'function' && _kernel.Metadata.hasOwn(CustomElement.name, value);
  },

  for(node, opts = defaultForOpts) {
    if (opts.name === void 0 && opts.searchParents !== true) {
      const controller = _kernel.Metadata.getOwn(CustomElement.name, node);

      if (controller === void 0) {
        if (opts.optional === true) {
          return null;
        }

        throw new Error(`The provided node is not a custom element or containerless host.`);
      }

      return controller;
    }

    if (opts.name !== void 0) {
      if (opts.searchParents !== true) {
        const controller = _kernel.Metadata.getOwn(CustomElement.name, node);

        if (controller === void 0) {
          throw new Error(`The provided node is not a custom element or containerless host.`);
        }

        if (controller.is(opts.name)) {
          return controller;
        }

        return void 0;
      }

      let cur = node;
      let foundAController = false;

      while (cur !== null) {
        const controller = _kernel.Metadata.getOwn(CustomElement.name, cur);

        if (controller !== void 0) {
          foundAController = true;

          if (controller.is(opts.name)) {
            return controller;
          }
        }

        cur = (0, _dom.getEffectiveParentNode)(cur);
      }

      if (foundAController) {
        return void 0;
      }

      throw new Error(`The provided node does does not appear to be part of an Aurelia app DOM tree, or it was added to the DOM in a way that Aurelia cannot properly resolve its position in the component tree.`);
    }

    let cur = node;

    while (cur !== null) {
      const controller = _kernel.Metadata.getOwn(CustomElement.name, cur);

      if (controller !== void 0) {
        return controller;
      }

      cur = (0, _dom.getEffectiveParentNode)(cur);
    }

    throw new Error(`The provided node does does not appear to be part of an Aurelia app DOM tree, or it was added to the DOM in a way that Aurelia cannot properly resolve its position in the component tree.`);
  },

  define(nameOrDef, Type) {
    const definition = CustomElementDefinition.create(nameOrDef, Type);

    _kernel.Metadata.define(CustomElement.name, definition, definition.Type);

    _kernel.Metadata.define(CustomElement.name, definition, definition);

    _kernel.Protocol.resource.appendTo(definition.Type, CustomElement.name);

    return definition.Type;
  },

  getDefinition(Type) {
    const def = _kernel.Metadata.getOwn(CustomElement.name, Type);

    if (def === void 0) {
      throw new Error(`No definition found for type ${Type.name}`);
    }

    return def;
  },

  annotate(Type, prop, value) {
    _kernel.Metadata.define(_kernel.Protocol.annotation.keyFor(prop), value, Type);
  },

  getAnnotation(Type, prop) {
    return _kernel.Metadata.getOwn(_kernel.Protocol.annotation.keyFor(prop), Type);
  },

  generateName: function () {
    let id = 0;
    return function () {
      return `unnamed-${++id}`;
    };
  }(),

  createInjectable() {
    const $injectable = function (target, property, index) {
      const annotationParamtypes = _kernel.DI.getOrCreateAnnotationParamTypes(target);

      annotationParamtypes[index] = $injectable;
      return target;
    };

    $injectable.register = function (container) {
      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
      return {
        resolve(container, requestor) {
          if (requestor.has($injectable, true)) {
            return requestor.get($injectable);
          } else {
            return null;
          }
        }

      };
    };

    return $injectable;
  },

  generateType: function () {
    const nameDescriptor = {
      value: '',
      writable: false,
      enumerable: false,
      configurable: true
    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any

    const defaultProto = {};
    return function (name, proto = defaultProto) {
      // Anonymous class ensures that minification cannot cause unintended side-effects, and keeps the class
      // looking similarly from the outside (when inspected via debugger, etc).
      const Type = class {}; // Define the name property so that Type.name can be used by end users / plugin authors if they really need to,
      // even when minified.

      nameDescriptor.value = name;
      Reflect.defineProperty(Type, 'name', nameDescriptor); // Assign anything from the prototype that was passed in

      if (proto !== defaultProto) {
        Object.assign(Type.prototype, proto);
      }

      return Type;
    };
  }()
};
exports.CustomElement = CustomElement;
});

;define.alias('@aurelia/runtime-html/resources/custom-element.js','@aurelia/runtime-html/dist/esm/resources/custom-element.js');
define('@aurelia/runtime-html/dist/esm/resources/custom-elements/au-slot.js',['require','exports','module','@aurelia/kernel','../../dom.js','../custom-element.js','../../templating/view.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.AuSlot = exports.ProjectionProvider = exports.IProjectionProvider = exports.RegisteredProjections = exports.ProjectionContext = exports.SlotInfo = exports.AuSlotContentType = exports.IProjections = void 0;

var _kernel = require("@aurelia/kernel");

var _dom = require("../../dom.js");

var _customElement = require("../custom-element.js");

var _view = require("../../templating/view.js");

const IProjections = _kernel.DI.createInterface("IProjections");

exports.IProjections = IProjections;
var AuSlotContentType;
exports.AuSlotContentType = AuSlotContentType;

(function (AuSlotContentType) {
  AuSlotContentType[AuSlotContentType["Projection"] = 0] = "Projection";
  AuSlotContentType[AuSlotContentType["Fallback"] = 1] = "Fallback";
})(AuSlotContentType || (exports.AuSlotContentType = AuSlotContentType = {}));

class SlotInfo {
  constructor(name, type, projectionContext) {
    this.name = name;
    this.type = type;
    this.projectionContext = projectionContext;
  }

}

exports.SlotInfo = SlotInfo;

class ProjectionContext {
  constructor(content, scope = null) {
    this.content = content;
    this.scope = scope;
  }

}

exports.ProjectionContext = ProjectionContext;

class RegisteredProjections {
  constructor(scope, projections) {
    this.scope = scope;
    this.projections = projections;
  }

}

exports.RegisteredProjections = RegisteredProjections;

const IProjectionProvider = _kernel.DI.createInterface('IProjectionProvider', x => x.singleton(ProjectionProvider));

exports.IProjectionProvider = IProjectionProvider;
const projectionMap = new WeakMap();

class ProjectionProvider {
  registerProjections(projections, scope) {
    for (const [instruction, $projections] of projections) {
      projectionMap.set(instruction, new RegisteredProjections(scope, $projections));
    }
  }

  getProjectionFor(instruction) {
    return projectionMap.get(instruction) ?? null;
  }

}

exports.ProjectionProvider = ProjectionProvider;

class AuSlot {
  constructor(factory, location) {
    this.factory = factory;
    this.hostScope = null;
    this.view = factory.create().setLocation(location);
    this.isProjection = factory.contentType === AuSlotContentType.Projection;
    this.outerScope = factory.projectionScope;
  }
  /**
   * @internal
   */


  static get inject() {
    return [_view.IViewFactory, _dom.IRenderLocation];
  }

  binding(initiator, parent, flags) {
    this.hostScope = this.$controller.scope.parentScope;
  }

  attaching(initiator, parent, flags) {
    const {
      $controller
    } = this;
    return this.view.activate(initiator, $controller, flags, this.outerScope ?? this.hostScope, this.hostScope);
  }

  detaching(initiator, parent, flags) {
    return this.view.deactivate(initiator, this.$controller, flags);
  }

  dispose() {
    this.view.dispose();
    this.view = void 0;
  }

  accept(visitor) {
    if (this.view?.accept(visitor) === true) {
      return true;
    }
  }

}

exports.AuSlot = AuSlot;
(0, _customElement.customElement)({
  name: 'au-slot',
  template: null,
  containerless: true
})(AuSlot);
});

;define.alias('@aurelia/runtime-html/resources/custom-elements/au-slot.js','@aurelia/runtime-html/dist/esm/resources/custom-elements/au-slot.js');
define('@aurelia/runtime-html/dist/esm/resources/custom-elements/compose.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime','../../create-element.js','../../renderer.js','../../platform.js','../../templating/render-context.js','../custom-element.js','../../bindable.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.Compose = void 0;

var _kernel = require("@aurelia/kernel");

var _runtime = require("@aurelia/runtime");

var _createElement = require("../../create-element.js");

var _renderer = require("../../renderer.js");

var _platform = require("../../platform.js");

var _renderContext = require("../../templating/render-context.js");

var _customElement = require("../custom-element.js");

var _bindable = require("../../bindable.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

function toLookup(acc, item) {
  const to = item.to;

  if (to !== void 0 && to !== 'subject' && to !== 'composing') {
    acc[to] = item;
  }

  return acc;
}

let Compose = class Compose {
  constructor(p, instruction) {
    this.p = p;
    this.id = (0, _kernel.nextId)('au$component');
    this.subject = void 0;
    this.composing = false;
    this.view = void 0;
    this.lastSubject = void 0;
    this.properties = instruction.instructions.reduce(toLookup, {});
  }

  attaching(initiator, parent, flags) {
    const {
      subject,
      view
    } = this;

    if (view === void 0 || this.lastSubject !== subject) {
      this.lastSubject = subject;
      this.composing = true;
      return this.compose(void 0, subject, initiator, flags);
    }

    return this.compose(view, subject, initiator, flags);
  }

  detaching(initiator, parent, flags) {
    return this.deactivate(this.view, initiator, flags);
  }

  subjectChanged(newValue, previousValue, flags) {
    const {
      $controller
    } = this;

    if (!$controller.isActive) {
      return;
    }

    if (this.lastSubject === newValue) {
      return;
    }

    this.lastSubject = newValue;
    this.composing = true;
    flags |= $controller.flags;
    const ret = (0, _kernel.onResolve)(this.deactivate(this.view, null, flags), () => {
      // TODO(fkleuver): handle & test race condition
      return this.compose(void 0, newValue, null, flags);
    });

    if (ret instanceof Promise) {
      ret.catch(err => {
        throw err;
      });
    }
  }

  compose(view, subject, initiator, flags) {
    return (0, _kernel.onResolve)(view === void 0 ? (0, _kernel.onResolve)(subject, resolvedSubject => {
      return this.resolveView(resolvedSubject, flags);
    }) : view, resolvedView => {
      return this.activate(resolvedView, initiator, flags);
    });
  }

  deactivate(view, initiator, flags) {
    return view?.deactivate(initiator ?? view, this.$controller, flags);
  }

  activate(view, initiator, flags) {
    const {
      $controller
    } = this;
    return (0, _kernel.onResolve)(view?.activate(initiator ?? view, $controller, flags, $controller.scope, $controller.hostScope), () => {
      this.composing = false;
    });
  }

  resolveView(subject, flags) {
    const view = this.provideViewFor(subject, flags);

    if (view) {
      view.setLocation(this.$controller.location);
      view.lockScope(this.$controller.scope);
      return view;
    }

    return void 0;
  }

  provideViewFor(subject, flags) {
    if (!subject) {
      return void 0;
    }

    if (isController(subject)) {
      // IController
      return subject;
    }

    if ('createView' in subject) {
      // RenderPlan
      return subject.createView(this.$controller.context);
    }

    if ('create' in subject) {
      // IViewFactory
      return subject.create(flags);
    }

    if ('template' in subject) {
      // Raw Template Definition
      const definition = _customElement.CustomElementDefinition.getOrCreate(subject);

      return (0, _renderContext.getRenderContext)(definition, this.$controller.context).getViewFactory().create(flags);
    } // Constructable (Custom Element Constructor)


    return (0, _createElement.createElement)(this.p, subject, this.properties, this.$controller.host.childNodes).createView(this.$controller.context);
  }

  dispose() {
    this.view?.dispose();
    this.view = void 0;
  }

  accept(visitor) {
    if (this.view?.accept(visitor) === true) {
      return true;
    }
  }

};
exports.Compose = Compose;

__decorate([_bindable.bindable], Compose.prototype, "subject", void 0);

__decorate([(0, _bindable.bindable)({
  mode: _runtime.BindingMode.fromView
})], Compose.prototype, "composing", void 0);

exports.Compose = Compose = __decorate([(0, _customElement.customElement)({
  name: 'au-compose',
  template: null,
  containerless: true
}), __param(0, _platform.IPlatform), __param(1, _renderer.IInstruction)], Compose);

function isController(subject) {
  return 'lockScope' in subject;
}
});

;define.alias('@aurelia/runtime-html/resources/custom-elements/compose.js','@aurelia/runtime-html/dist/esm/resources/custom-elements/compose.js');
define('@aurelia/runtime-html/dist/esm/resources/template-controllers/flags.js',['require','exports','module','@aurelia/kernel','../../dom.js','../../templating/view.js','../custom-attribute.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.ObserveShallow = exports.FrequentMutations = void 0;

var _kernel = require("@aurelia/kernel");

var _dom = require("../../dom.js");

var _view = require("../../templating/view.js");

var _customAttribute = require("../custom-attribute.js");

class FlagsTemplateController {
  constructor(factory, location, flags) {
    this.factory = factory;
    this.flags = flags;
    this.id = (0, _kernel.nextId)('au$component');
    this.view = this.factory.create().setLocation(location);
  }

  attaching(initiator, parent, flags) {
    const {
      $controller
    } = this;
    return this.view.activate(initiator, $controller, flags | this.flags, $controller.scope, $controller.hostScope);
  }

  detaching(initiator, parent, flags) {
    return this.view.deactivate(initiator, this.$controller, flags);
  }

  dispose() {
    this.view.dispose();
    this.view = void 0;
  }

  accept(visitor) {
    if (this.view?.accept(visitor) === true) {
      return true;
    }
  }

}

class FrequentMutations extends FlagsTemplateController {
  constructor(factory, location) {
    super(factory, location, 8192
    /* persistentTargetObserverQueue */
    );
  }

}
/**
 * @internal
 */


exports.FrequentMutations = FrequentMutations;
FrequentMutations.inject = [_view.IViewFactory, _dom.IRenderLocation];

class ObserveShallow extends FlagsTemplateController {
  constructor(factory, location) {
    super(factory, location, 2048
    /* observeLeafPropertiesOnly */
    );
  }

}
/**
 * @internal
 */


exports.ObserveShallow = ObserveShallow;
ObserveShallow.inject = [_view.IViewFactory, _dom.IRenderLocation];
(0, _customAttribute.templateController)('frequent-mutations')(FrequentMutations);
(0, _customAttribute.templateController)('observe-shallow')(ObserveShallow);
});

;define.alias('@aurelia/runtime-html/resources/template-controllers/flags.js','@aurelia/runtime-html/dist/esm/resources/template-controllers/flags.js');
define('@aurelia/runtime-html/dist/esm/resources/template-controllers/if.js',['require','exports','module','@aurelia/kernel','../../dom.js','../../templating/view.js','../custom-attribute.js','../../bindable.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.Else = exports.If = void 0;

var _kernel = require("@aurelia/kernel");

var _dom = require("../../dom.js");

var _view = require("../../templating/view.js");

var _customAttribute = require("../custom-attribute.js");

var _bindable = require("../../bindable.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

let If = class If {
  constructor(ifFactory, location) {
    this.ifFactory = ifFactory;
    this.location = location;
    this.id = (0, _kernel.nextId)('au$component');
    this.elseFactory = void 0;
    this.elseView = void 0;
    this.ifView = void 0;
    this.view = void 0;
    this.value = false;
  }

  attaching(initiator, parent, flags) {
    const view = this.view = this.updateView(this.value, flags);

    if (view !== void 0) {
      const {
        $controller
      } = this;
      return view.activate(initiator, $controller, flags, $controller.scope, $controller.hostScope);
    }
  }

  detaching(initiator, parent, flags) {
    if (this.view !== void 0) {
      return this.view.deactivate(initiator, this.$controller, flags);
    }
  }

  valueChanged(newValue, oldValue, flags) {
    const {
      $controller
    } = this;

    if (!$controller.isActive) {
      return;
    }

    const ret = (0, _kernel.onResolve)(this.view?.deactivate(this.view, $controller, flags), () => {
      const view = this.view = this.updateView(this.value, flags);

      if (view !== void 0) {
        // TODO(fkleuver): add logic to the controller that ensures correct handling of race conditions and add a variety of `if` integration tests
        return view.activate(view, $controller, flags, $controller.scope, $controller.hostScope);
      }
    });

    if (ret instanceof Promise) {
      ret.catch(err => {
        throw err;
      });
    }
  }
  /** @internal */


  updateView(value, flags) {
    if (value) {
      return this.ifView = this.ensureView(this.ifView, this.ifFactory, flags);
    }

    if (this.elseFactory != void 0) {
      return this.elseView = this.ensureView(this.elseView, this.elseFactory, flags);
    }

    return void 0;
  }
  /** @internal */


  ensureView(view, factory, flags) {
    if (view === void 0) {
      view = factory.create(flags);
    }

    view.setLocation(this.location);
    return view;
  }

  dispose() {
    if (this.ifView !== void 0) {
      this.ifView.dispose();
      this.ifView = void 0;
    }

    if (this.elseView !== void 0) {
      this.elseView.dispose();
      this.elseView = void 0;
    }

    this.view = void 0;
  }

  accept(visitor) {
    if (this.view?.accept(visitor) === true) {
      return true;
    }
  }

};
exports.If = If;

__decorate([_bindable.bindable], If.prototype, "value", void 0);

exports.If = If = __decorate([(0, _customAttribute.templateController)('if'), __param(0, _view.IViewFactory), __param(1, _dom.IRenderLocation)], If);
let Else = class Else {
  constructor(factory) {
    this.factory = factory;
    this.id = (0, _kernel.nextId)('au$component');
  }

  link(flags, parentContext, controller, _childController, _target, _instruction) {
    const children = controller.children;
    const ifBehavior = children[children.length - 1];

    if (ifBehavior instanceof If) {
      ifBehavior.elseFactory = this.factory;
    } else if (ifBehavior.viewModel instanceof If) {
      ifBehavior.viewModel.elseFactory = this.factory;
    } else {
      throw new Error(`Unsupported IfBehavior`); // TODO: create error code
    }
  }

};
exports.Else = Else;
exports.Else = Else = __decorate([(0, _customAttribute.templateController)({
  name: 'else'
}), __param(0, _view.IViewFactory)], Else);
});

;define.alias('@aurelia/runtime-html/resources/template-controllers/if.js','@aurelia/runtime-html/dist/esm/resources/template-controllers/if.js');
define('@aurelia/runtime-html/dist/esm/resources/template-controllers/portal.js',['require','exports','module','@aurelia/kernel','../../dom.js','../../platform.js','../../templating/view.js','../custom-attribute.js','../../bindable.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.Portal = void 0;

var _kernel = require("@aurelia/kernel");

var _dom = require("../../dom.js");

var _platform = require("../../platform.js");

var _view = require("../../templating/view.js");

var _customAttribute = require("../custom-attribute.js");

var _bindable = require("../../bindable.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

let Portal = class Portal {
  constructor(factory, originalLoc, p) {
    this.factory = factory;
    this.originalLoc = originalLoc;
    this.p = p;
    this.id = (0, _kernel.nextId)('au$component');
    this.strict = false; // to make the shape of this object consistent.
    // todo: is this necessary

    this.currentTarget = p.document.createElement('div');
    this.view = this.factory.create();
    (0, _dom.setEffectiveParentNode)(this.view.nodes, originalLoc);
  }

  attaching(initiator, parent, flags) {
    if (this.callbackContext == null) {
      this.callbackContext = this.$controller.scope.bindingContext;
    }

    const newTarget = this.currentTarget = this.resolveTarget();
    this.view.setHost(newTarget);
    return this.$activating(initiator, newTarget, flags);
  }

  detaching(initiator, parent, flags) {
    return this.$deactivating(initiator, this.currentTarget, flags);
  }

  targetChanged() {
    const {
      $controller
    } = this;

    if (!$controller.isActive) {
      return;
    }

    const oldTarget = this.currentTarget;
    const newTarget = this.currentTarget = this.resolveTarget();

    if (oldTarget === newTarget) {
      return;
    }

    this.view.setHost(newTarget); // TODO(fkleuver): fix and test possible race condition

    const ret = (0, _kernel.onResolve)(this.$deactivating(null, newTarget, $controller.flags), () => {
      return this.$activating(null, newTarget, $controller.flags);
    });

    if (ret instanceof Promise) {
      ret.catch(err => {
        throw err;
      });
    }
  }

  $activating(initiator, target, flags) {
    const {
      activating,
      callbackContext,
      view
    } = this;
    view.setHost(target);
    return (0, _kernel.onResolve)(activating?.call(callbackContext, target, view), () => {
      return this.activate(initiator, target, flags);
    });
  }

  activate(initiator, target, flags) {
    const {
      $controller,
      view
    } = this;

    if (initiator === null) {
      view.nodes.appendTo(target);
    } else {
      // TODO(fkleuver): fix and test possible race condition
      return (0, _kernel.onResolve)(view.activate(initiator ?? view, $controller, flags, $controller.scope), () => {
        return this.$activated(target);
      });
    }

    return this.$activated(target);
  }

  $activated(target) {
    const {
      activated,
      callbackContext,
      view
    } = this;
    return activated?.call(callbackContext, target, view);
  }

  $deactivating(initiator, target, flags) {
    const {
      deactivating,
      callbackContext,
      view
    } = this;
    return (0, _kernel.onResolve)(deactivating?.call(callbackContext, target, view), () => {
      return this.deactivate(initiator, target, flags);
    });
  }

  deactivate(initiator, target, flags) {
    const {
      $controller,
      view
    } = this;

    if (initiator === null) {
      view.nodes.remove();
    } else {
      return (0, _kernel.onResolve)(view.deactivate(initiator, $controller, flags), () => {
        return this.$deactivated(target);
      });
    }

    return this.$deactivated(target);
  }

  $deactivated(target) {
    const {
      deactivated,
      callbackContext,
      view
    } = this;
    return deactivated?.call(callbackContext, target, view);
  }

  resolveTarget() {
    const p = this.p; // with a $ in front to make it less confusing/error prone

    const $document = p.document;
    let target = this.target;
    let context = this.renderContext;

    if (target === '') {
      if (this.strict) {
        throw new Error('Empty querySelector');
      }

      return $document.body;
    }

    if (typeof target === 'string') {
      let queryContext = $document;

      if (typeof context === 'string') {
        context = $document.querySelector(context);
      }

      if (context instanceof p.Node) {
        queryContext = context;
      }

      target = queryContext.querySelector(target);
    }

    if (target instanceof p.Node) {
      return target;
    }

    if (target == null) {
      if (this.strict) {
        throw new Error('Portal target not found');
      }

      return $document.body;
    }

    return target;
  }

  dispose() {
    this.view.dispose();
    this.view = void 0;
    this.callbackContext = null;
  }

  accept(visitor) {
    if (this.view?.accept(visitor) === true) {
      return true;
    }
  }

};
exports.Portal = Portal;

__decorate([(0, _bindable.bindable)({
  primary: true
})], Portal.prototype, "target", void 0);

__decorate([(0, _bindable.bindable)({
  callback: 'targetChanged'
})], Portal.prototype, "renderContext", void 0);

__decorate([(0, _bindable.bindable)()], Portal.prototype, "strict", void 0);

__decorate([(0, _bindable.bindable)()], Portal.prototype, "deactivating", void 0);

__decorate([(0, _bindable.bindable)()], Portal.prototype, "activating", void 0);

__decorate([(0, _bindable.bindable)()], Portal.prototype, "deactivated", void 0);

__decorate([(0, _bindable.bindable)()], Portal.prototype, "activated", void 0);

__decorate([(0, _bindable.bindable)()], Portal.prototype, "callbackContext", void 0);

exports.Portal = Portal = __decorate([(0, _customAttribute.templateController)('portal'), __param(0, _view.IViewFactory), __param(1, _dom.IRenderLocation), __param(2, _platform.IPlatform)], Portal);
});

;define.alias('@aurelia/runtime-html/resources/template-controllers/portal.js','@aurelia/runtime-html/dist/esm/resources/template-controllers/portal.js');
define('@aurelia/runtime-html/dist/esm/resources/template-controllers/repeat.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime','../../dom.js','../../templating/view.js','../custom-attribute.js','../../templating/controller.js','../../bindable.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.longestIncreasingSubsequence = longestIncreasingSubsequence;
exports.Repeat = void 0;

var _kernel = require("@aurelia/kernel");

var _runtime = require("@aurelia/runtime");

var _dom = require("../../dom.js");

var _view = require("../../templating/view.js");

var _customAttribute = require("../custom-attribute.js");

var _controller = require("../../templating/controller.js");

var _bindable = require("../../bindable.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

function dispose(disposable) {
  disposable.dispose();
}

let Repeat = class Repeat {
  constructor(location, parent, factory) {
    this.location = location;
    this.parent = parent;
    this.factory = factory;
    this.id = (0, _kernel.nextId)('au$component');
    this.hasPendingInstanceMutation = false;
    this.observer = void 0;
    this.views = [];
    this.key = void 0;
    this.normalizedItems = void 0;
  }

  binding(initiator, parent, flags) {
    this.checkCollectionObserver(flags);
    const bindings = this.parent.bindings;
    let binding = void 0;

    for (let i = 0, ii = bindings.length; i < ii; ++i) {
      binding = bindings[i];

      if (binding.target === this && binding.targetProperty === 'items') {
        this.forOf = binding.sourceExpression;
        break;
      }
    }

    this.local = this.forOf.declaration.evaluate(flags, this.$controller.scope, null, binding.locator, null);
  }

  attaching(initiator, parent, flags) {
    this.normalizeToArray(flags);
    return this.activateAllViews(initiator, flags);
  }

  detaching(initiator, parent, flags) {
    this.checkCollectionObserver(flags);
    return this.deactivateAllViews(initiator, flags);
  } // called by SetterObserver


  itemsChanged(flags) {
    const {
      $controller
    } = this;

    if (!$controller.isActive) {
      return;
    }

    flags |= $controller.flags;
    this.checkCollectionObserver(flags);
    flags |= 8
    /* updateTarget */
    ;
    this.normalizeToArray(flags);
    const ret = (0, _kernel.onResolve)(this.deactivateAllViews(null, flags), () => {
      // TODO(fkleuver): add logic to the controller that ensures correct handling of race conditions and add a variety of `if` integration tests
      return this.activateAllViews(null, flags);
    });

    if (ret instanceof Promise) {
      ret.catch(err => {
        throw err;
      });
    }
  } // called by a CollectionObserver


  handleCollectionChange(indexMap, flags) {
    const {
      $controller
    } = this;

    if (!$controller.isActive) {
      return;
    }

    flags |= $controller.flags;
    flags |= 8
    /* updateTarget */
    ;
    this.normalizeToArray(flags);

    if (indexMap === void 0) {
      const ret = (0, _kernel.onResolve)(this.deactivateAllViews(null, flags), () => {
        // TODO(fkleuver): add logic to the controller that ensures correct handling of race conditions and add a variety of `if` integration tests
        return this.activateAllViews(null, flags);
      });

      if (ret instanceof Promise) {
        ret.catch(err => {
          throw err;
        });
      }
    } else {
      const oldLength = this.views.length;
      (0, _runtime.applyMutationsToIndices)(indexMap); // first detach+unbind+(remove from array) the deleted view indices

      if (indexMap.deletedItems.length > 0) {
        indexMap.deletedItems.sort(_kernel.compareNumber);
        const ret = (0, _kernel.onResolve)(this.deactivateAndRemoveViewsByKey(indexMap, flags), () => {
          // TODO(fkleuver): add logic to the controller that ensures correct handling of race conditions and add a variety of `if` integration tests
          return this.createAndActivateAndSortViewsByKey(oldLength, indexMap, flags);
        });

        if (ret instanceof Promise) {
          ret.catch(err => {
            throw err;
          });
        }
      } else {
        // TODO(fkleuver): add logic to the controller that ensures correct handling of race conditions and add integration tests
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.createAndActivateAndSortViewsByKey(oldLength, indexMap, flags);
      }
    }
  } // todo: subscribe to collection from inner expression


  checkCollectionObserver(flags) {
    const oldObserver = this.observer;

    if (flags & 64
    /* fromUnbind */
    ) {
        if (oldObserver !== void 0) {
          oldObserver.unsubscribe(this);
        }
      } else if (this.$controller.isActive) {
      const newObserver = this.observer = (0, _runtime.getCollectionObserver)(this.items);

      if (oldObserver !== newObserver && oldObserver) {
        oldObserver.unsubscribe(this);
      }

      if (newObserver) {
        newObserver.subscribe(this);
      }
    }
  }

  normalizeToArray(flags) {
    const items = this.items;

    if (items instanceof Array) {
      this.normalizedItems = items;
      return;
    }

    const forOf = this.forOf;

    if (forOf === void 0) {
      return;
    }

    const normalizedItems = [];
    this.forOf.iterate(flags, items, (arr, index, item) => {
      normalizedItems[index] = item;
    });
    this.normalizedItems = normalizedItems;
  }

  activateAllViews(initiator, flags) {
    let promises = void 0;
    let ret;
    let view;
    let viewScope;
    const {
      $controller,
      factory,
      local,
      location,
      items
    } = this;
    const parentScope = $controller.scope;
    const hostScope = $controller.hostScope;
    const newLen = this.forOf.count(flags, items);
    const views = this.views = Array(newLen);
    this.forOf.iterate(flags, items, (arr, i, item) => {
      view = views[i] = factory.create(flags).setLocation(location);
      view.nodes.unlink();
      viewScope = _runtime.Scope.fromParent(parentScope, _runtime.BindingContext.create(local, item));
      setContextualProperties(viewScope.overrideContext, i, newLen);
      ret = view.activate(initiator ?? view, $controller, flags, viewScope, hostScope);

      if (ret instanceof Promise) {
        (promises ?? (promises = [])).push(ret);
      }
    });

    if (promises !== void 0) {
      return promises.length === 1 ? promises[0] : Promise.all(promises);
    }
  }

  deactivateAllViews(initiator, flags) {
    let promises = void 0;
    let ret;
    let view;
    const {
      views,
      $controller
    } = this;

    for (let i = 0, ii = views.length; i < ii; ++i) {
      view = views[i];
      view.release();
      ret = view.deactivate(initiator ?? view, $controller, flags);

      if (ret instanceof Promise) {
        (promises ?? (promises = [])).push(ret);
      }
    }

    if (promises !== void 0) {
      return promises.length === 1 ? promises[0] : Promise.all(promises);
    }
  }

  deactivateAndRemoveViewsByKey(indexMap, flags) {
    let promises = void 0;
    let ret;
    let view;
    const {
      $controller,
      views
    } = this;
    const deleted = indexMap.deletedItems;
    const deletedLen = deleted.length;
    let i = 0;

    for (; i < deletedLen; ++i) {
      view = views[deleted[i]];
      view.release();
      ret = view.deactivate(view, $controller, flags);

      if (ret instanceof Promise) {
        (promises ?? (promises = [])).push(ret);
      }
    }

    i = 0;
    let j = 0;

    for (; i < deletedLen; ++i) {
      j = deleted[i] - i;
      views.splice(j, 1);
    }

    if (promises !== void 0) {
      return promises.length === 1 ? promises[0] : Promise.all(promises);
    }
  }

  createAndActivateAndSortViewsByKey(oldLength, indexMap, flags) {
    let promises = void 0;
    let ret;
    let view;
    let viewScope;
    const {
      $controller,
      factory,
      local,
      normalizedItems,
      location,
      views
    } = this;
    const mapLen = indexMap.length;

    for (let i = 0; i < mapLen; ++i) {
      if (indexMap[i] === -2) {
        view = factory.create(flags);
        views.splice(i, 0, view);
      }
    }

    if (views.length !== mapLen) {
      // TODO: create error code and use reporter with more informative message
      throw new Error(`viewsLen=${views.length}, mapLen=${mapLen}`);
    }

    const parentScope = $controller.scope;
    const hostScope = $controller.hostScope;
    const newLen = indexMap.length;
    (0, _runtime.synchronizeIndices)(views, indexMap); // this algorithm retrieves the indices of the longest increasing subsequence of items in the repeater
    // the items on those indices are not moved; this minimizes the number of DOM operations that need to be performed

    const seq = longestIncreasingSubsequence(indexMap);
    const seqLen = seq.length;
    let next;
    let j = seqLen - 1;
    let i = newLen - 1;

    for (; i >= 0; --i) {
      view = views[i];
      next = views[i + 1];
      view.nodes.link(next?.nodes ?? location);

      if (indexMap[i] === -2) {
        viewScope = _runtime.Scope.fromParent(parentScope, _runtime.BindingContext.create(local, normalizedItems[i]));
        setContextualProperties(viewScope.overrideContext, i, newLen);
        view.setLocation(location);
        ret = view.activate(view, $controller, flags, viewScope, hostScope);

        if (ret instanceof Promise) {
          (promises ?? (promises = [])).push(ret);
        }
      } else if (j < 0 || seqLen === 1 || i !== seq[j]) {
        setContextualProperties(view.scope.overrideContext, i, newLen);
        view.nodes.insertBefore(view.location);
      } else {
        if (oldLength !== newLen) {
          setContextualProperties(view.scope.overrideContext, i, newLen);
        }

        --j;
      }
    }

    if (promises !== void 0) {
      return promises.length === 1 ? promises[0] : Promise.all(promises);
    }
  }

  dispose() {
    this.views.forEach(dispose);
    this.views = void 0;
  }

  accept(visitor) {
    const {
      views
    } = this;

    if (views !== void 0) {
      for (let i = 0, ii = views.length; i < ii; ++i) {
        if (views[i].accept(visitor) === true) {
          return true;
        }
      }
    }
  }

};
exports.Repeat = Repeat;

__decorate([_bindable.bindable], Repeat.prototype, "items", void 0);

exports.Repeat = Repeat = __decorate([(0, _customAttribute.templateController)('repeat'), __param(0, _dom.IRenderLocation), __param(1, _controller.IController), __param(2, _view.IViewFactory)], Repeat);
let maxLen = 16;
let prevIndices = new Int32Array(maxLen);
let tailIndices = new Int32Array(maxLen); // Based on inferno's lis_algorithm @ https://github.com/infernojs/inferno/blob/master/packages/inferno/src/DOM/patching.ts#L732
// with some tweaks to make it just a bit faster + account for IndexMap (and some names changes for readability)

/** @internal */

function longestIncreasingSubsequence(indexMap) {
  const len = indexMap.length;

  if (len > maxLen) {
    maxLen = len;
    prevIndices = new Int32Array(len);
    tailIndices = new Int32Array(len);
  }

  let cursor = 0;
  let cur = 0;
  let prev = 0;
  let i = 0;
  let j = 0;
  let low = 0;
  let high = 0;
  let mid = 0;

  for (; i < len; i++) {
    cur = indexMap[i];

    if (cur !== -2) {
      j = prevIndices[cursor];
      prev = indexMap[j];

      if (prev !== -2 && prev < cur) {
        tailIndices[i] = j;
        prevIndices[++cursor] = i;
        continue;
      }

      low = 0;
      high = cursor;

      while (low < high) {
        mid = low + high >> 1;
        prev = indexMap[prevIndices[mid]];

        if (prev !== -2 && prev < cur) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }

      prev = indexMap[prevIndices[low]];

      if (cur < prev || prev === -2) {
        if (low > 0) {
          tailIndices[i] = prevIndices[low - 1];
        }

        prevIndices[low] = i;
      }
    }
  }

  i = ++cursor;
  const result = new Int32Array(i);
  cur = prevIndices[cursor - 1];

  while (cursor-- > 0) {
    result[cursor] = cur;
    cur = tailIndices[cur];
  }

  while (i-- > 0) prevIndices[i] = 0;

  return result;
}

function setContextualProperties(oc, index, length) {
  const isFirst = index === 0;
  const isLast = index === length - 1;
  const isEven = index % 2 === 0;
  oc.$index = index;
  oc.$first = isFirst;
  oc.$last = isLast;
  oc.$middle = !isFirst && !isLast;
  oc.$even = isEven;
  oc.$odd = !isEven;
  oc.$length = length;
}
});

;define.alias('@aurelia/runtime-html/resources/template-controllers/repeat.js','@aurelia/runtime-html/dist/esm/resources/template-controllers/repeat.js');
define('@aurelia/runtime-html/dist/esm/resources/template-controllers/switch.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime','../../dom.js','../custom-attribute.js','../../templating/view.js','../../bindable.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.DefaultCase = exports.Case = exports.Switch = void 0;

var _kernel = require("@aurelia/kernel");

var _runtime = require("@aurelia/runtime");

var _dom = require("../../dom.js");

var _customAttribute = require("../custom-attribute.js");

var _view = require("../../templating/view.js");

var _bindable = require("../../bindable.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

let Switch = class Switch {
  constructor(factory, location) {
    this.factory = factory;
    this.location = location;
    this.id = (0, _kernel.nextId)('au$component');
    /** @internal */

    this.cases = [];
    this.activeCases = [];
    /**
     * This is kept around here so that changes can be awaited from the tests.
     * This needs to be removed after the scheduler is ready to handle/queue the floating promises.
     */

    this.promise = void 0;
  }

  link(flags, _parentContext, _controller, _childController, _target, _instruction) {
    this.view = this.factory.create(flags, this.$controller).setLocation(this.location);
  }

  attaching(initiator, parent, flags) {
    const view = this.view;
    const $controller = this.$controller;
    this.queue(() => view.activate(initiator, $controller, flags, $controller.scope, $controller.hostScope));
    this.queue(() => this.swap(initiator, flags, this.value));
    return this.promise;
  }

  detaching(initiator, parent, flags) {
    this.queue(() => {
      const view = this.view;
      return view.deactivate(initiator, this.$controller, flags);
    });
    return this.promise;
  }

  dispose() {
    this.view?.dispose();
    this.view = void 0;
  }

  valueChanged(_newValue, _oldValue, flags) {
    if (!this.$controller.isActive) {
      return;
    }

    this.queue(() => this.swap(null, flags, this.value));
  }

  caseChanged($case, flags) {
    this.queue(() => this.handleCaseChange($case, flags));
  }

  handleCaseChange($case, flags) {
    const isMatch = $case.isMatch(this.value, flags);
    const activeCases = this.activeCases;
    const numActiveCases = activeCases.length; // Early termination #1

    if (!isMatch) {
      /** The previous match started with this; thus clear. */
      if (numActiveCases > 0 && activeCases[0].id === $case.id) {
        return this.clearActiveCases(null, flags);
      }
      /**
       * There are 2 different scenarios here:
       * 1. $case in activeCases: Indicates by-product of fallthrough. The starting case still satisfies. Return.
       * 2. $case not in activeCases: It was previously not active, and currently also not a match. Return.
       */


      return;
    } // Early termination #2


    if (numActiveCases > 0 && activeCases[0].id < $case.id) {
      // Even if this case now a match, the previous case still wins by as that has lower ordinal.
      return;
    } // compute the new active cases


    const newActiveCases = [];
    let fallThrough = $case.fallThrough;

    if (!fallThrough) {
      newActiveCases.push($case);
    } else {
      const cases = this.cases;
      const idx = cases.indexOf($case);

      for (let i = idx, ii = cases.length; i < ii && fallThrough; i++) {
        const c = cases[i];
        newActiveCases.push(c);
        fallThrough = c.fallThrough;
      }
    }

    return (0, _kernel.onResolve)(this.clearActiveCases(null, flags, newActiveCases), () => {
      this.activeCases = newActiveCases;
      return this.activateCases(null, flags);
    });
  }

  swap(initiator, flags, value) {
    const newActiveCases = [];
    let fallThrough = false;

    for (const $case of this.cases) {
      if (fallThrough || $case.isMatch(value, flags)) {
        newActiveCases.push($case);
        fallThrough = $case.fallThrough;
      }

      if (newActiveCases.length > 0 && !fallThrough) {
        break;
      }
    }

    const defaultCase = this.defaultCase;

    if (newActiveCases.length === 0 && defaultCase !== void 0) {
      newActiveCases.push(defaultCase);
    }

    return (0, _kernel.onResolve)(this.activeCases.length > 0 ? this.clearActiveCases(initiator, flags, newActiveCases) : void 0, () => {
      this.activeCases = newActiveCases;

      if (newActiveCases.length === 0) {
        return;
      }

      return this.activateCases(initiator, flags);
    });
  }

  activateCases(initiator, flags) {
    const controller = this.$controller;

    if (!controller.isActive) {
      return;
    }

    const cases = this.activeCases;
    const length = cases.length;

    if (length === 0) {
      return;
    }

    const scope = controller.scope;
    const hostScope = controller.hostScope; // most common case

    if (length === 1) {
      return cases[0].activate(initiator, flags, scope, hostScope);
    }

    return (0, _kernel.resolveAll)(...cases.map($case => $case.activate(initiator, flags, scope, hostScope)));
  }

  clearActiveCases(initiator, flags, newActiveCases = []) {
    const cases = this.activeCases;
    const numCases = cases.length;

    if (numCases === 0) {
      return;
    }

    if (numCases === 1) {
      const firstCase = cases[0];

      if (!newActiveCases.includes(firstCase)) {
        cases.length = 0;
        return firstCase.deactivate(initiator, flags);
      }

      return;
    }

    return (0, _kernel.onResolve)((0, _kernel.resolveAll)(...cases.reduce((acc, $case) => {
      if (!newActiveCases.includes($case)) {
        acc.push($case.deactivate(initiator, flags));
      }

      return acc;
    }, [])), () => {
      cases.length = 0;
    });
  }

  queue(action) {
    const previousPromise = this.promise;
    let promise = void 0;
    promise = this.promise = (0, _kernel.onResolve)((0, _kernel.onResolve)(previousPromise, action), () => {
      if (this.promise === promise) {
        this.promise = void 0;
      }
    });
  }

  accept(visitor) {
    if (this.$controller.accept(visitor) === true) {
      return true;
    }

    if (this.activeCases.some(x => x.accept(visitor))) {
      return true;
    }
  }

};
exports.Switch = Switch;

__decorate([_bindable.bindable], Switch.prototype, "value", void 0);

exports.Switch = Switch = __decorate([(0, _customAttribute.templateController)('switch'), __param(0, _view.IViewFactory), __param(1, _dom.IRenderLocation)], Switch);
let Case = class Case {
  constructor(factory, locator, location, logger) {
    this.factory = factory;
    this.locator = locator;
    this.id = (0, _kernel.nextId)('au$component');
    this.fallThrough = false;
    this.debug = logger.config.level <= 1
    /* debug */
    ;
    this.logger = logger.scopeTo(`${this.constructor.name}-#${this.id}`);
    this.view = this.factory.create().setLocation(location);
  }

  link(flags, parentContext, controller, _childController, _target, _instruction) {
    const switchController = controller.parent;
    const $switch = switchController?.viewModel;

    if ($switch instanceof Switch) {
      this.$switch = $switch;
      this.linkToSwitch($switch);
    } else {
      throw new Error('The parent switch not found; only `*[switch] > *[case|default-case]` relation is supported.');
    }
  }

  detaching(initiator, parent, flags) {
    return this.deactivate(initiator, flags);
  }

  isMatch(value, flags) {
    if (this.debug) {
      this.logger.debug('isMatch()');
    }

    const $value = this.value;

    if (Array.isArray($value)) {
      if (this.observer === void 0) {
        this.observer = this.observeCollection(flags, $value);
      }

      return $value.includes(value);
    }

    return $value === value;
  }

  valueChanged(newValue, _oldValue, flags) {
    if (Array.isArray(newValue)) {
      this.observer?.unsubscribe(this);
      this.observer = this.observeCollection(flags, newValue);
    } else if (this.observer !== void 0) {
      this.observer.unsubscribe(this);
    }

    this.$switch.caseChanged(this, flags);
  }

  handleCollectionChange(_indexMap, flags) {
    this.$switch.caseChanged(this, flags);
  }

  activate(initiator, flags, scope, hostScope) {
    const view = this.view;

    if (view.isActive) {
      return;
    }

    return view.activate(initiator ?? view, this.$controller, flags, scope, hostScope);
  }

  deactivate(initiator, flags) {
    const view = this.view;

    if (!view.isActive) {
      return;
    }

    return view.deactivate(initiator ?? view, this.$controller, flags);
  }

  dispose() {
    this.observer?.unsubscribe(this);
    this.view?.dispose();
    this.view = void 0;
  }

  linkToSwitch(auSwitch) {
    auSwitch.cases.push(this);
  }

  observeCollection(flags, $value) {
    const observer = this.locator.getArrayObserver($value);
    observer.subscribe(this);
    return observer;
  }

  accept(visitor) {
    if (this.$controller.accept(visitor) === true) {
      return true;
    }

    return this.view?.accept(visitor);
  }

};
exports.Case = Case;

__decorate([_bindable.bindable], Case.prototype, "value", void 0);

__decorate([(0, _bindable.bindable)({
  set: v => {
    switch (v) {
      case 'true':
        return true;

      case 'false':
        return false;
      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions

      default:
        return !!v;
    }
  },
  mode: _runtime.BindingMode.oneTime
})], Case.prototype, "fallThrough", void 0);

exports.Case = Case = __decorate([(0, _customAttribute.templateController)('case'), __param(0, _view.IViewFactory), __param(1, _runtime.IObserverLocator), __param(2, _dom.IRenderLocation), __param(3, _kernel.ILogger)], Case);
let DefaultCase = class DefaultCase extends Case {
  linkToSwitch($switch) {
    if ($switch.defaultCase !== void 0) {
      throw new Error('Multiple \'default-case\'s are not allowed.');
    }

    $switch.defaultCase = this;
  }

};
exports.DefaultCase = DefaultCase;
exports.DefaultCase = DefaultCase = __decorate([(0, _customAttribute.templateController)('default-case')], DefaultCase);
});

;define.alias('@aurelia/runtime-html/resources/template-controllers/switch.js','@aurelia/runtime-html/dist/esm/resources/template-controllers/switch.js');
define('@aurelia/runtime-html/dist/esm/resources/template-controllers/with.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime','../../dom.js','../../templating/view.js','../custom-attribute.js','../../bindable.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.With = void 0;

var _kernel = require("@aurelia/kernel");

var _runtime = require("@aurelia/runtime");

var _dom = require("../../dom.js");

var _view = require("../../templating/view.js");

var _customAttribute = require("../custom-attribute.js");

var _bindable = require("../../bindable.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

let With = class With {
  constructor(factory, location) {
    this.factory = factory;
    this.location = location;
    this.id = (0, _kernel.nextId)('au$component');
    this.id = (0, _kernel.nextId)('au$component');
    this.view = this.factory.create().setLocation(location);
  }

  valueChanged(newValue, oldValue, flags) {
    if (this.$controller.isActive) {
      // TODO(fkleuver): add logic to the controller that ensures correct handling of race conditions and add integration tests
      // eslint-disable-next-line @typescript-eslint/no-floating-promises
      this.activateView(this.view, 32
      /* fromBind */
      );
    }
  }

  attaching(initiator, parent, flags) {
    return this.activateView(initiator, flags);
  }

  detaching(initiator, parent, flags) {
    return this.view.deactivate(initiator, this.$controller, flags);
  }

  activateView(initiator, flags) {
    const {
      $controller,
      value
    } = this;

    const scope = _runtime.Scope.fromParent($controller.scope, value === void 0 ? {} : value);

    return this.view.activate(initiator, $controller, flags, scope, $controller.hostScope);
  }

  dispose() {
    this.view.dispose();
    this.view = void 0;
  }

  accept(visitor) {
    if (this.view?.accept(visitor) === true) {
      return true;
    }
  }

};
exports.With = With;

__decorate([_bindable.bindable], With.prototype, "value", void 0);

exports.With = With = __decorate([(0, _customAttribute.templateController)('with'), __param(0, _view.IViewFactory), __param(1, _dom.IRenderLocation)], With);
});

;define.alias('@aurelia/runtime-html/resources/template-controllers/with.js','@aurelia/runtime-html/dist/esm/resources/template-controllers/with.js');
define('@aurelia/runtime-html/dist/esm/resources/value-converters/sanitize.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.SanitizeValueConverter = exports.ISanitizer = void 0;

var _kernel = require("@aurelia/kernel");

var _runtime = require("@aurelia/runtime");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

const SCRIPT_REGEX = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi;

const ISanitizer = _kernel.DI.createInterface('ISanitizer', x => x.singleton(class {
  sanitize(input) {
    return input.replace(SCRIPT_REGEX, '');
  }

}));
/**
 * Simple html sanitization converter to preserve whitelisted elements and attributes on a bound property containing html.
 */


exports.ISanitizer = ISanitizer;
let SanitizeValueConverter = class SanitizeValueConverter {
  constructor(sanitizer) {
    this.sanitizer = sanitizer;
  }
  /**
   * Process the provided markup that flows to the view.
   *
   * @param untrustedMarkup - The untrusted markup to be sanitized.
   */


  toView(untrustedMarkup) {
    if (untrustedMarkup == null) {
      return null;
    }

    return this.sanitizer.sanitize(untrustedMarkup);
  }

};
exports.SanitizeValueConverter = SanitizeValueConverter;
exports.SanitizeValueConverter = SanitizeValueConverter = __decorate([__param(0, ISanitizer)], SanitizeValueConverter);
(0, _runtime.valueConverter)('sanitize')(SanitizeValueConverter);
});

;define.alias('@aurelia/runtime-html/resources/value-converters/sanitize.js','@aurelia/runtime-html/dist/esm/resources/value-converters/sanitize.js');
define('@aurelia/runtime-html/dist/esm/resources/value-converters/view.js',['require','exports','module','../../templating/view.js','@aurelia/runtime'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.ViewValueConverter = void 0;

var _view = require("../../templating/view.js");

var _runtime = require("@aurelia/runtime");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

let ViewValueConverter = class ViewValueConverter {
  constructor(viewLocator) {
    this.viewLocator = viewLocator;
  }

  toView(object, viewNameOrSelector) {
    return this.viewLocator.getViewComponentForObject(object, viewNameOrSelector);
  }

};
exports.ViewValueConverter = ViewValueConverter;
exports.ViewValueConverter = ViewValueConverter = __decorate([__param(0, _view.IViewLocator)], ViewValueConverter);
(0, _runtime.valueConverter)('view')(ViewValueConverter);
});

;define.alias('@aurelia/runtime-html/resources/value-converters/view.js','@aurelia/runtime-html/dist/esm/resources/value-converters/view.js');
define('@aurelia/runtime-html/dist/esm/semantic-model.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.AttrInfo = exports.ElementInfo = exports.BindableInfo = exports.TextSymbol = exports.PlainElementSymbol = exports.LetElementSymbol = exports.CustomElementSymbol = exports.BindingSymbol = exports.PlainAttributeSymbol = exports.CustomAttributeSymbol = exports.ProjectionSymbol = exports.TemplateControllerSymbol = exports.SymbolFlags = void 0;

var _kernel = require("@aurelia/kernel");

var _runtime = require("@aurelia/runtime");

var SymbolFlags;
exports.SymbolFlags = SymbolFlags;

(function (SymbolFlags) {
  SymbolFlags[SymbolFlags["type"] = 1023] = "type";
  SymbolFlags[SymbolFlags["isTemplateController"] = 1] = "isTemplateController";
  SymbolFlags[SymbolFlags["isProjection"] = 2] = "isProjection";
  SymbolFlags[SymbolFlags["isCustomAttribute"] = 4] = "isCustomAttribute";
  SymbolFlags[SymbolFlags["isPlainAttribute"] = 8] = "isPlainAttribute";
  SymbolFlags[SymbolFlags["isCustomElement"] = 16] = "isCustomElement";
  SymbolFlags[SymbolFlags["isLetElement"] = 32] = "isLetElement";
  SymbolFlags[SymbolFlags["isPlainElement"] = 64] = "isPlainElement";
  SymbolFlags[SymbolFlags["isText"] = 128] = "isText";
  SymbolFlags[SymbolFlags["isBinding"] = 256] = "isBinding";
  SymbolFlags[SymbolFlags["isAuSlot"] = 512] = "isAuSlot";
  SymbolFlags[SymbolFlags["hasMarker"] = 1024] = "hasMarker";
  SymbolFlags[SymbolFlags["hasTemplate"] = 2048] = "hasTemplate";
  SymbolFlags[SymbolFlags["hasAttributes"] = 4096] = "hasAttributes";
  SymbolFlags[SymbolFlags["hasBindings"] = 8192] = "hasBindings";
  SymbolFlags[SymbolFlags["hasChildNodes"] = 16384] = "hasChildNodes";
  SymbolFlags[SymbolFlags["hasProjections"] = 32768] = "hasProjections";
})(SymbolFlags || (exports.SymbolFlags = SymbolFlags = {}));

function createMarker(p) {
  const marker = p.document.createElement('au-m');
  marker.className = 'au';
  return marker;
}
/**
 * A html attribute that is associated with a registered resource, specifically a template controller.
 */


class TemplateControllerSymbol {
  constructor(p, syntax, info, res = info.name) {
    this.syntax = syntax;
    this.info = info;
    this.res = res;
    this.flags = 1
    /* isTemplateController */
    | 1024
    /* hasMarker */
    ;
    this.physicalNode = null;
    this.template = null;
    this.templateController = null;
    this._bindings = null;
    this.marker = createMarker(p);
  }

  get bindings() {
    if (this._bindings === null) {
      this._bindings = [];
      this.flags |= 8192
      /* hasBindings */
      ;
    }

    return this._bindings;
  }

}

exports.TemplateControllerSymbol = TemplateControllerSymbol;

class ProjectionSymbol {
  constructor(name, template) {
    this.name = name;
    this.template = template;
    this.flags = 2
    /* isProjection */
    ;
  }

}
/**
 * A html attribute that is associated with a registered resource, but not a template controller.
 */


exports.ProjectionSymbol = ProjectionSymbol;

class CustomAttributeSymbol {
  constructor(syntax, info, res = info.name) {
    this.syntax = syntax;
    this.info = info;
    this.res = res;
    this.flags = 4
    /* isCustomAttribute */
    ;
    this._bindings = null;
  }

  get bindings() {
    if (this._bindings === null) {
      this._bindings = [];
      this.flags |= 8192
      /* hasBindings */
      ;
    }

    return this._bindings;
  }

}
/**
 * An attribute, with either a binding command or an interpolation, whose target is the html
 * attribute of the element.
 *
 * This will never target a bindable property of a custom attribute or element;
 */


exports.CustomAttributeSymbol = CustomAttributeSymbol;

class PlainAttributeSymbol {
  constructor(syntax, command, expression) {
    this.syntax = syntax;
    this.command = command;
    this.expression = expression;
    this.flags = 8
    /* isPlainAttribute */
    ;
  }

}
/**
 * Either an attribute on an custom element that maps to a declared bindable property of that element,
 * a single-value bound custom attribute, or one of several bindables that were extracted from the attribute
 * value of a custom attribute with multiple bindings usage.
 *
 * This will always target a bindable property of a custom attribute or element;
 */


exports.PlainAttributeSymbol = PlainAttributeSymbol;

class BindingSymbol {
  constructor(command, bindable, expression, rawValue, target) {
    this.command = command;
    this.bindable = bindable;
    this.expression = expression;
    this.rawValue = rawValue;
    this.target = target;
    this.flags = 256
    /* isBinding */
    ;
  }

}
/**
 * A html element that is associated with a registered resource either via its (lowerCase) `nodeName`
 * or the value of its `as-element` attribute.
 */


exports.BindingSymbol = BindingSymbol;

class CustomElementSymbol {
  constructor(p, physicalNode, info, res = info.name, bindables = info.bindables) {
    this.physicalNode = physicalNode;
    this.info = info;
    this.res = res;
    this.bindables = bindables;
    this.flags = 16
    /* isCustomElement */
    ;
    this.isTarget = true;
    this.templateController = null;
    this._customAttributes = null;
    this._plainAttributes = null;
    this._bindings = null;
    this._childNodes = null;
    this._projections = null;

    if (info.containerless) {
      this.isContainerless = true;
      this.marker = createMarker(p);
      this.flags |= 1024
      /* hasMarker */
      ;
    } else {
      this.isContainerless = false;
      this.marker = null;
    }
  }

  get customAttributes() {
    if (this._customAttributes === null) {
      this._customAttributes = [];
      this.flags |= 4096
      /* hasAttributes */
      ;
    }

    return this._customAttributes;
  }

  get plainAttributes() {
    if (this._plainAttributes === null) {
      this._plainAttributes = [];
      this.flags |= 4096
      /* hasAttributes */
      ;
    }

    return this._plainAttributes;
  }

  get bindings() {
    if (this._bindings === null) {
      this._bindings = [];
      this.flags |= 8192
      /* hasBindings */
      ;
    }

    return this._bindings;
  }

  get childNodes() {
    if (this._childNodes === null) {
      this._childNodes = [];
      this.flags |= 16384
      /* hasChildNodes */
      ;
    }

    return this._childNodes;
  }

  get projections() {
    if (this._projections === null) {
      this._projections = [];
      this.flags |= 32768
      /* hasProjections */
      ;
    }

    return this._projections;
  }

}

exports.CustomElementSymbol = CustomElementSymbol;

class LetElementSymbol {
  constructor(p, physicalNode, marker = createMarker(p)) {
    this.physicalNode = physicalNode;
    this.marker = marker;
    this.flags = 32
    /* isLetElement */
    | 1024
    /* hasMarker */
    ;
    this.toBindingContext = false;
    this._bindings = null;
  }

  get bindings() {
    if (this._bindings === null) {
      this._bindings = [];
      this.flags |= 8192
      /* hasBindings */
      ;
    }

    return this._bindings;
  }

}
/**
 * A normal html element that may or may not have attribute behaviors and/or child node behaviors.
 *
 * It is possible for a PlainElementSymbol to not yield any instructions during compilation.
 */


exports.LetElementSymbol = LetElementSymbol;

class PlainElementSymbol {
  constructor(physicalNode) {
    this.physicalNode = physicalNode;
    this.flags = 64
    /* isPlainElement */
    ;
    this.isTarget = false;
    this.templateController = null;
    this.hasSlots = false;
    this._customAttributes = null;
    this._plainAttributes = null;
    this._childNodes = null;
  }

  get customAttributes() {
    if (this._customAttributes === null) {
      this._customAttributes = [];
      this.flags |= 4096
      /* hasAttributes */
      ;
    }

    return this._customAttributes;
  }

  get plainAttributes() {
    if (this._plainAttributes === null) {
      this._plainAttributes = [];
      this.flags |= 4096
      /* hasAttributes */
      ;
    }

    return this._plainAttributes;
  }

  get childNodes() {
    if (this._childNodes === null) {
      this._childNodes = [];
      this.flags |= 16384
      /* hasChildNodes */
      ;
    }

    return this._childNodes;
  }

}
/**
 * A standalone text node that has an interpolation.
 */


exports.PlainElementSymbol = PlainElementSymbol;

class TextSymbol {
  constructor(p, physicalNode, interpolation, marker = createMarker(p)) {
    this.physicalNode = physicalNode;
    this.interpolation = interpolation;
    this.marker = marker;
    this.flags = 128
    /* isText */
    | 1024
    /* hasMarker */
    ;
  }

}
/**
 * A pre-processed piece of information about a defined bindable property on a custom
 * element or attribute, optimized for consumption by the template compiler.
 */


exports.TextSymbol = TextSymbol;

class BindableInfo {
  constructor(
  /**
   * The pre-processed *property* (not attribute) name of the bindable, which is
   * (in order of priority):
   *
   * 1. The `property` from the description (if defined)
   * 2. The name of the property of the bindable itself
   */
  propName,
  /**
   * The pre-processed (default) bindingMode of the bindable, which is (in order of priority):
   *
   * 1. The `mode` from the bindable (if defined and not bindingMode.default)
   * 2. The `defaultBindingMode` (if it's an attribute, defined, and not bindingMode.default)
   * 3. `bindingMode.toView`
   */
  mode) {
    this.propName = propName;
    this.mode = mode;
  }

}

exports.BindableInfo = BindableInfo;
const elementInfoLookup = new WeakMap();
/**
 * Pre-processed information about a custom element resource, optimized
 * for consumption by the template compiler.
 */

class ElementInfo {
  constructor(name, alias, containerless) {
    this.name = name;
    this.alias = alias;
    this.containerless = containerless;
    /**
     * A lookup of the bindables of this element, indexed by the (pre-processed)
     * attribute names as they would be found in parsed markup.
     */

    this.bindables = Object.create(null);
  }

  static from(def, alias) {
    if (def === null) {
      return null;
    }

    let rec = elementInfoLookup.get(def);

    if (rec === void 0) {
      elementInfoLookup.set(def, rec = Object.create(null));
    }

    let info = rec[alias];

    if (info === void 0) {
      info = rec[alias] = new ElementInfo(def.name, alias === def.name ? void 0 : alias, def.containerless);
      const bindables = def.bindables;
      const defaultBindingMode = _runtime.BindingMode.toView;
      let bindable;
      let prop;
      let attr;
      let mode;

      for (prop in bindables) {
        bindable = bindables[prop]; // explicitly provided property name has priority over the implicit property name

        if (bindable.property !== void 0) {
          prop = bindable.property;
        } // explicitly provided attribute name has priority over the derived implicit attribute name


        if (bindable.attribute !== void 0) {
          attr = bindable.attribute;
        } else {
          // derive the attribute name from the resolved property name
          attr = (0, _kernel.kebabCase)(prop);
        }

        if (bindable.mode !== void 0 && bindable.mode !== _runtime.BindingMode.default) {
          mode = bindable.mode;
        } else {
          mode = defaultBindingMode;
        }

        info.bindables[attr] = new BindableInfo(prop, mode);
      }
    }

    return info;
  }

}

exports.ElementInfo = ElementInfo;
const attrInfoLookup = new WeakMap();
/**
 * Pre-processed information about a custom attribute resource, optimized
 * for consumption by the template compiler.
 */

class AttrInfo {
  constructor(name, alias, isTemplateController, noMultiBindings) {
    this.name = name;
    this.alias = alias;
    this.isTemplateController = isTemplateController;
    this.noMultiBindings = noMultiBindings;
    /**
     * A lookup of the bindables of this attribute, indexed by the (pre-processed)
     * bindable names as they would be found in the attribute value.
     *
     * Only applicable to multi attribute bindings (semicolon-separated).
     */

    this.bindables = Object.create(null);
    /**
     * The single or first bindable of this attribute, or a default 'value'
     * bindable if no bindables were defined on the attribute.
     *
     * Only applicable to single attribute bindings (where the attribute value
     * contains no semicolons)
     */

    this.bindable = null;
  }

  static from(def, alias) {
    if (def === null) {
      return null;
    }

    let rec = attrInfoLookup.get(def);

    if (rec === void 0) {
      attrInfoLookup.set(def, rec = Object.create(null));
    }

    let info = rec[alias];

    if (info === void 0) {
      info = rec[alias] = new AttrInfo(def.name, alias === def.name ? void 0 : alias, def.isTemplateController, def.noMultiBindings);
      const bindables = def.bindables;
      const defaultBindingMode = def.defaultBindingMode !== void 0 && def.defaultBindingMode !== _runtime.BindingMode.default ? def.defaultBindingMode : _runtime.BindingMode.toView;
      let bindable;
      let prop;
      let mode;
      let hasPrimary = false;
      let isPrimary = false;
      let bindableInfo;

      for (prop in bindables) {
        bindable = bindables[prop]; // explicitly provided property name has priority over the implicit property name

        if (bindable.property !== void 0) {
          prop = bindable.property;
        }

        if (bindable.mode !== void 0 && bindable.mode !== _runtime.BindingMode.default) {
          mode = bindable.mode;
        } else {
          mode = defaultBindingMode;
        }

        isPrimary = bindable.primary === true;
        bindableInfo = info.bindables[prop] = new BindableInfo(prop, mode);

        if (isPrimary) {
          if (hasPrimary) {
            throw new Error('primary already exists');
          }

          hasPrimary = true;
          info.bindable = bindableInfo;
        } // set to first bindable by convention


        if (info.bindable === null) {
          info.bindable = bindableInfo;
        }
      } // if no bindables are present, default to "value"


      if (info.bindable === null) {
        info.bindable = new BindableInfo('value', defaultBindingMode);
      }
    }

    return info;
  }

}

exports.AttrInfo = AttrInfo;
});

;define.alias('@aurelia/runtime-html/semantic-model.js','@aurelia/runtime-html/dist/esm/semantic-model.js');
define('@aurelia/runtime-html/dist/esm/template-binder.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime','./resources/binding-command.js','./resources/custom-attribute.js','./resources/custom-element.js','./semantic-model.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.TemplateBinder = void 0;

var _kernel = require("@aurelia/kernel");

var _runtime = require("@aurelia/runtime");

var _bindingCommand = require("./resources/binding-command.js");

var _customAttribute = require("./resources/custom-attribute.js");

var _customElement = require("./resources/custom-element.js");

var _semanticModel = require("./semantic-model.js");

const invalidSurrogateAttribute = Object.assign(Object.create(null), {
  'id': true,
  'au-slot': true
});
const attributesToIgnore = Object.assign(Object.create(null), {
  'as-element': true
});

function hasInlineBindings(rawValue) {
  const len = rawValue.length;
  let ch = 0;

  for (let i = 0; i < len; ++i) {
    ch = rawValue.charCodeAt(i);

    if (ch === 92
    /* Backslash */
    ) {
        ++i; // Ignore whatever comes next because it's escaped
      } else if (ch === 58
    /* Colon */
    ) {
        return true;
      } else if (ch === 36
    /* Dollar */
    && rawValue.charCodeAt(i + 1) === 123
    /* OpenBrace */
    ) {
        return false;
      }
  }

  return false;
}

function processInterpolationText(symbol) {
  const node = symbol.physicalNode;
  const parentNode = node.parentNode;

  while (node.nextSibling !== null && node.nextSibling.nodeType === 3
  /* Text */
  ) {
    parentNode.removeChild(node.nextSibling);
  }

  node.textContent = '';
  parentNode.insertBefore(symbol.marker, node);
}

function isTemplateControllerOf(proxy, manifest) {
  return proxy !== manifest;
}
/**
 * A (temporary) standalone function that purely does the DOM processing (lifting) related to template controllers.
 * It's a first refactoring step towards separating DOM parsing/binding from mutations.
 */


function processTemplateControllers(p, manifestProxy, manifest) {
  const manifestNode = manifest.physicalNode;
  let current = manifestProxy;
  let currentTemplate;

  while (isTemplateControllerOf(current, manifest)) {
    if (current.template === manifest) {
      // the DOM linkage is still in its original state here so we can safely assume the parentNode is non-null
      manifestNode.parentNode.replaceChild(current.marker, manifestNode); // if the manifest is a template element (e.g. <template repeat.for="...">) then we can skip one lift operation
      // and simply use the template directly, saving a bit of work

      if (manifestNode.nodeName === 'TEMPLATE') {
        current.physicalNode = manifestNode; // the template could safely stay without affecting anything visible, but let's keep the DOM tidy

        manifestNode.remove();
      } else {
        // the manifest is not a template element so we need to wrap it in one
        currentTemplate = current.physicalNode = p.document.createElement('template');
        currentTemplate.content.appendChild(manifestNode);
      }
    } else {
      currentTemplate = current.physicalNode = p.document.createElement('template');
      currentTemplate.content.appendChild(current.marker);
    }

    manifestNode.removeAttribute(current.syntax.rawName);
    current = current.template;
  }
}
/**
 * TemplateBinder. Todo: describe goal of this class
 */


class TemplateBinder {
  constructor(platform, container, attrParser, exprParser, attrSyntaxTransformer) {
    this.platform = platform;
    this.container = container;
    this.attrParser = attrParser;
    this.exprParser = exprParser;
    this.attrSyntaxTransformer = attrSyntaxTransformer;
    this.commandLookup = Object.create(null);
  }

  bind(node) {
    const surrogate = new _semanticModel.PlainElementSymbol(node);
    const attrSyntaxTransformer = this.attrSyntaxTransformer;
    const attributes = node.attributes;
    let i = 0;

    while (i < attributes.length) {
      const attr = attributes[i];
      const attrSyntax = this.attrParser.parse(attr.name, attr.value);

      if (invalidSurrogateAttribute[attrSyntax.target] === true) {
        throw new Error(`Invalid surrogate attribute: ${attrSyntax.target}`); // TODO: use reporter
      }

      const bindingCommand = this.getBindingCommand(attrSyntax, true);

      if (bindingCommand === null || (bindingCommand.bindingType & 4096
      /* IgnoreCustomAttr */
      ) === 0) {
        const attrInfo = _semanticModel.AttrInfo.from(this.container.find(_customAttribute.CustomAttribute, attrSyntax.target), attrSyntax.target);

        if (attrInfo === null) {
          // map special html attributes to their corresponding properties
          attrSyntaxTransformer.transform(node, attrSyntax); // it's not a custom attribute but might be a regular bound attribute or interpolation (it might also be nothing)

          this.bindPlainAttribute(
          /* attrSyntax */
          attrSyntax,
          /* attr       */
          attr,
          /* surrogate  */
          surrogate,
          /* manifest   */
          surrogate);
        } else if (attrInfo.isTemplateController) {
          throw new Error('Cannot have template controller on surrogate element.'); // TODO: use reporter
        } else {
          this.bindCustomAttribute(
          /* attrSyntax */
          attrSyntax,
          /* attrInfo   */
          attrInfo,
          /* command    */
          bindingCommand,
          /* manifest   */
          surrogate);
        }
      } else {
        // map special html attributes to their corresponding properties
        attrSyntaxTransformer.transform(node, attrSyntax); // it's not a custom attribute but might be a regular bound attribute or interpolation (it might also be nothing)

        this.bindPlainAttribute(
        /* attrSyntax */
        attrSyntax,
        /* attr       */
        attr,
        /* surrogate  */
        surrogate,
        /* manifest   */
        surrogate);
      }

      ++i;
    }

    this.bindChildNodes(
    /* node               */
    node,
    /* surrogate          */
    surrogate,
    /* manifest           */
    surrogate,
    /* manifestRoot       */
    null,
    /* parentManifestRoot */
    null);
    return surrogate;
  }

  bindManifest(parentManifest, node, surrogate, manifest, manifestRoot, parentManifestRoot) {
    let isAuSlot = false;

    switch (node.nodeName) {
      case 'LET':
        // let cannot have children and has some different processing rules, so return early
        this.bindLetElement(
        /* parentManifest */
        parentManifest,
        /* node           */
        node);
        return;

      case 'SLOT':
        surrogate.hasSlots = true;
        break;

      case 'AU-SLOT':
        isAuSlot = true;
        break;
    }

    let name = node.getAttribute('as-element');

    if (name === null) {
      name = node.nodeName.toLowerCase();
    }

    const elementInfo = _semanticModel.ElementInfo.from(this.container.find(_customElement.CustomElement, name), name);

    if (elementInfo === null) {
      // there is no registered custom element with this name
      manifest = new _semanticModel.PlainElementSymbol(node);
    } else {
      // it's a custom element so we set the manifestRoot as well (for storing replaces)
      parentManifestRoot = manifestRoot;
      const ceSymbol = new _semanticModel.CustomElementSymbol(this.platform, node, elementInfo);

      if (isAuSlot) {
        ceSymbol.flags = 512
        /* isAuSlot */
        ;
        ceSymbol.slotName = node.getAttribute("name") ?? "default";
      }

      manifestRoot = manifest = ceSymbol;
    } // lifting operations done by template controllers and replaces effectively unlink the nodes, so start at the bottom


    this.bindChildNodes(
    /* node               */
    node,
    /* surrogate          */
    surrogate,
    /* manifest           */
    manifest,
    /* manifestRoot       */
    manifestRoot,
    /* parentManifestRoot */
    parentManifestRoot); // the parentManifest will receive either the direct child nodes, or the template controllers / replaces
    // wrapping them

    this.bindAttributes(
    /* node               */
    node,
    /* parentManifest     */
    parentManifest,
    /* surrogate          */
    surrogate,
    /* manifest           */
    manifest,
    /* manifestRoot       */
    manifestRoot,
    /* parentManifestRoot */
    parentManifestRoot);

    if (manifestRoot === manifest && manifest.isContainerless) {
      node.parentNode.replaceChild(manifest.marker, node);
    } else if (manifest.isTarget) {
      node.classList.add('au');
    }
  }

  bindLetElement(parentManifest, node) {
    const symbol = new _semanticModel.LetElementSymbol(this.platform, node);
    parentManifest.childNodes.push(symbol);
    const attributes = node.attributes;
    let i = 0;

    while (i < attributes.length) {
      const attr = attributes[i];

      if (attr.name === 'to-binding-context') {
        node.removeAttribute('to-binding-context');
        symbol.toBindingContext = true;
        continue;
      }

      const attrSyntax = this.attrParser.parse(attr.name, attr.value);
      const command = this.getBindingCommand(attrSyntax, false);
      const bindingType = command === null ? 2048
      /* Interpolation */
      : command.bindingType;
      const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);
      const to = (0, _kernel.camelCase)(attrSyntax.target);
      const info = new _semanticModel.BindableInfo(to, _runtime.BindingMode.toView);
      symbol.bindings.push(new _semanticModel.BindingSymbol(command, info, expr, attrSyntax.rawValue, to));
      ++i;
    }

    node.parentNode.replaceChild(symbol.marker, node);
  }

  bindAttributes(node, parentManifest, surrogate, manifest, manifestRoot, parentManifestRoot) {
    // This is the top-level symbol for the current depth.
    // If there are no template controllers or replaces, it is always the manifest itself.
    // If there are template controllers, then this will be the outer-most TemplateControllerSymbol.
    let manifestProxy = manifest;
    let previousController = void 0;
    let currentController = void 0;
    const attributes = node.attributes;
    let i = 0;

    while (i < attributes.length) {
      const attr = attributes[i];
      ++i;

      if (attributesToIgnore[attr.name] === true) {
        continue;
      }

      const attrSyntax = this.attrParser.parse(attr.name, attr.value);
      const bindingCommand = this.getBindingCommand(attrSyntax, true);

      if (bindingCommand === null || (bindingCommand.bindingType & 4096
      /* IgnoreCustomAttr */
      ) === 0) {
        const attrInfo = _semanticModel.AttrInfo.from(this.container.find(_customAttribute.CustomAttribute, attrSyntax.target), attrSyntax.target);

        if (attrInfo === null) {
          // map special html attributes to their corresponding properties
          this.attrSyntaxTransformer.transform(node, attrSyntax); // it's not a custom attribute but might be a regular bound attribute or interpolation (it might also be nothing)

          this.bindPlainAttribute(
          /* attrSyntax */
          attrSyntax,
          /* attr       */
          attr,
          /* surrogate  */
          surrogate,
          /* manifest   */
          manifest);
        } else if (attrInfo.isTemplateController) {
          // the manifest is wrapped by the inner-most template controller (if there are multiple on the same element)
          // so keep setting manifest.templateController to the latest template controller we find
          currentController = manifest.templateController = this.declareTemplateController(
          /* attrSyntax */
          attrSyntax,
          /* attrInfo   */
          attrInfo); // the proxy and the manifest are only identical when we're at the first template controller (since the controller
          // is assigned to the proxy), so this evaluates to true at most once per node

          if (manifestProxy === manifest) {
            currentController.template = manifest;
            manifestProxy = currentController;
          } else {
            currentController.templateController = previousController;
            currentController.template = previousController.template;
            previousController.template = currentController;
          }

          previousController = currentController;
        } else {
          // a regular custom attribute
          this.bindCustomAttribute(
          /* attrSyntax */
          attrSyntax,
          /* attrInfo   */
          attrInfo,
          /* command    */
          bindingCommand,
          /* manifest   */
          manifest);
        }
      } else {
        // map special html attributes to their corresponding properties
        this.attrSyntaxTransformer.transform(node, attrSyntax); // it's not a custom attribute but might be a regular bound attribute or interpolation (it might also be nothing)

        this.bindPlainAttribute(
        /* attrSyntax */
        attrSyntax,
        /* attr       */
        attr,
        /* surrogate  */
        surrogate,
        /* manifest   */
        manifest);
      }
    }

    if (node.tagName === 'INPUT') {
      const type = node.type;

      if (type === 'checkbox' || type === 'radio') {
        this.ensureAttributeOrder(manifest);
      }
    }

    let projection = node.getAttribute('au-slot');

    if (projection === '') {
      projection = 'default';
    }

    const hasProjection = projection !== null;

    if (hasProjection && isTemplateControllerOf(manifestProxy, manifest)) {
      // prevents <some-el au-slot TEMPLATE.CONTROLLER></some-el>.
      throw new Error(`Unsupported usage of [au-slot="${projection}"] along with a template controller (if, else, repeat.for etc.) found (example: <some-el au-slot if.bind="true"></some-el>).`);
      /**
       * TODO: prevent <template TEMPLATE.CONTROLLER><some-el au-slot></some-el></template>.
       * But there is not easy way for now, as the attribute binding is done after binding the child nodes.
       * This means by the time the template controller in the ancestor is processed, the projection is already registered.
       */
    }

    const parentName = node.parentNode?.nodeName.toLowerCase();

    if (hasProjection && (manifestRoot === null || parentName === void 0 || this.container.find(_customElement.CustomElement, parentName) === null)) {
      /**
       * Prevents the following cases:
       * - <template><div au-slot></div></template>
       * - <my-ce><div><div au-slot></div></div></my-ce>
       * - <my-ce><div au-slot="s1"><div au-slot="s2"></div></div></my-ce>
       */
      throw new Error(`Unsupported usage of [au-slot="${projection}"]. It seems that projection is attempted, but not for a custom element.`);
    }

    processTemplateControllers(this.platform, manifestProxy, manifest);
    const projectionOwner = manifest === manifestRoot ? parentManifestRoot : manifestRoot;

    if (!hasProjection || projectionOwner === null) {
      // the proxy is either the manifest itself or the outer-most controller; add it directly to the parent
      parentManifest.childNodes.push(manifestProxy);
    } else if (hasProjection) {
      projectionOwner.projections.push(new _semanticModel.ProjectionSymbol(projection, manifestProxy));
      node.removeAttribute('au-slot');
      node.remove();
    }
  } // TODO: refactor to use render priority slots (this logic shouldn't be in the template binder)


  ensureAttributeOrder(manifest) {
    // swap the order of checked and model/value attribute, so that the required observers are prepared for checked-observer
    const attributes = manifest.plainAttributes;
    let modelOrValueIndex = void 0;
    let checkedIndex = void 0;
    let found = 0;

    for (let i = 0; i < attributes.length && found < 3; i++) {
      switch (attributes[i].syntax.target) {
        case 'model':
        case 'value':
        case 'matcher':
          modelOrValueIndex = i;
          found++;
          break;

        case 'checked':
          checkedIndex = i;
          found++;
          break;
      }
    }

    if (checkedIndex !== void 0 && modelOrValueIndex !== void 0 && checkedIndex < modelOrValueIndex) {
      [attributes[modelOrValueIndex], attributes[checkedIndex]] = [attributes[checkedIndex], attributes[modelOrValueIndex]];
    }
  }

  bindChildNodes(node, surrogate, manifest, manifestRoot, parentManifestRoot) {
    let childNode;

    if (node.nodeName === 'TEMPLATE') {
      childNode = node.content.firstChild;
    } else {
      childNode = node.firstChild;
    }

    let nextChild;

    while (childNode !== null) {
      switch (childNode.nodeType) {
        case 1
        /* Element */
        :
          nextChild = childNode.nextSibling;
          this.bindManifest(
          /* parentManifest     */
          manifest,
          /* node               */
          childNode,
          /* surrogate          */
          surrogate,
          /* manifest           */
          manifest,
          /* manifestRoot       */
          manifestRoot,
          /* parentManifestRoot */
          parentManifestRoot);
          childNode = nextChild;
          break;

        case 3
        /* Text */
        :
          childNode = this.bindText(
          /* textNode */
          childNode,
          /* manifest */
          manifest).nextSibling;
          break;

        case 4
        /* CDATASection */
        :
        case 7
        /* ProcessingInstruction */
        :
        case 8
        /* Comment */
        :
        case 10
        /* DocumentType */
        :
          childNode = childNode.nextSibling;
          break;

        case 9
        /* Document */
        :
        case 11
        /* DocumentFragment */
        :
          childNode = childNode.firstChild;
      }
    }
  }

  bindText(textNode, manifest) {
    const interpolation = this.exprParser.parse(textNode.wholeText, 2048
    /* Interpolation */
    );

    if (interpolation !== null) {
      const symbol = new _semanticModel.TextSymbol(this.platform, textNode, interpolation);
      manifest.childNodes.push(symbol);
      processInterpolationText(symbol);
    }

    let next = textNode;

    while (next.nextSibling !== null && next.nextSibling.nodeType === 3
    /* Text */
    ) {
      next = next.nextSibling;
    }

    return next;
  }

  declareTemplateController(attrSyntax, attrInfo) {
    let symbol;
    const attrRawValue = attrSyntax.rawValue;
    const command = this.getBindingCommand(attrSyntax, false); // multi-bindings logic here is similar to (and explained in) bindCustomAttribute

    const isMultiBindings = attrInfo.noMultiBindings === false && command === null && hasInlineBindings(attrRawValue);

    if (isMultiBindings) {
      symbol = new _semanticModel.TemplateControllerSymbol(this.platform, attrSyntax, attrInfo);
      this.bindMultiAttribute(symbol, attrInfo, attrRawValue);
    } else {
      symbol = new _semanticModel.TemplateControllerSymbol(this.platform, attrSyntax, attrInfo);
      const bindingType = command === null ? 2048
      /* Interpolation */
      : command.bindingType;
      const expr = this.exprParser.parse(attrRawValue, bindingType);
      symbol.bindings.push(new _semanticModel.BindingSymbol(command, attrInfo.bindable, expr, attrRawValue, attrSyntax.target));
    }

    return symbol;
  }

  bindCustomAttribute(attrSyntax, attrInfo, command, manifest) {
    let symbol;
    const attrRawValue = attrSyntax.rawValue; // Custom attributes are always in multiple binding mode,
    // except when they can't be
    // When they cannot be:
    //        * has explicit configuration noMultiBindings: false
    //        * has binding command, ie: <div my-attr.bind="...">.
    //          In this scenario, the value of the custom attributes is required to be a valid expression
    //        * has no colon: ie: <div my-attr="abcd">
    //          In this scenario, it's simply invalid syntax. Consider style attribute rule-value pair: <div style="rule: ruleValue">

    const isMultiBindings = attrInfo.noMultiBindings === false && command === null && hasInlineBindings(attrRawValue);

    if (isMultiBindings) {
      // a multiple-bindings attribute usage (semicolon separated binding) is only valid without a binding command;
      // the binding commands must be declared in each of the property bindings
      symbol = new _semanticModel.CustomAttributeSymbol(attrSyntax, attrInfo);
      this.bindMultiAttribute(symbol, attrInfo, attrRawValue);
    } else {
      symbol = new _semanticModel.CustomAttributeSymbol(attrSyntax, attrInfo);
      const bindingType = command === null ? 2048
      /* Interpolation */
      : command.bindingType;
      const expr = this.exprParser.parse(attrRawValue, bindingType);
      symbol.bindings.push(new _semanticModel.BindingSymbol(command, attrInfo.bindable, expr, attrRawValue, attrSyntax.target));
    }

    manifest.customAttributes.push(symbol);
    manifest.isTarget = true;
  }

  bindMultiAttribute(symbol, attrInfo, value) {
    const bindables = attrInfo.bindables;
    const valueLength = value.length;
    let attrName = void 0;
    let attrValue = void 0;
    let start = 0;
    let ch = 0;

    for (let i = 0; i < valueLength; ++i) {
      ch = value.charCodeAt(i);

      if (ch === 92
      /* Backslash */
      ) {
          ++i; // Ignore whatever comes next because it's escaped
        } else if (ch === 58
      /* Colon */
      ) {
          attrName = value.slice(start, i); // Skip whitespace after colon

          while (value.charCodeAt(++i) <= 32
          /* Space */
          );

          start = i;

          for (; i < valueLength; ++i) {
            ch = value.charCodeAt(i);

            if (ch === 92
            /* Backslash */
            ) {
                ++i; // Ignore whatever comes next because it's escaped
              } else if (ch === 59
            /* Semicolon */
            ) {
                attrValue = value.slice(start, i);
                break;
              }
          }

          if (attrValue === void 0) {
            // No semicolon found, so just grab the rest of the value
            attrValue = value.slice(start);
          }

          const attrSyntax = this.attrParser.parse(attrName, attrValue);
          const attrTarget = (0, _kernel.camelCase)(attrSyntax.target);
          const command = this.getBindingCommand(attrSyntax, false);
          const bindingType = command === null ? 2048
          /* Interpolation */
          : command.bindingType;
          const expr = this.exprParser.parse(attrValue, bindingType);
          let bindable = bindables[attrTarget];

          if (bindable === undefined) {
            // everything in a multi-bindings expression must be used,
            // so if it's not a bindable then we create one on the spot
            bindable = bindables[attrTarget] = new _semanticModel.BindableInfo(attrTarget, _runtime.BindingMode.toView);
          }

          symbol.bindings.push(new _semanticModel.BindingSymbol(command, bindable, expr, attrValue, attrTarget)); // Skip whitespace after semicolon

          while (i < valueLength && value.charCodeAt(++i) <= 32
          /* Space */
          );

          start = i;
          attrName = void 0;
          attrValue = void 0;
        }
    }
  }

  bindPlainAttribute(attrSyntax, attr, surrogate, manifest) {
    const command = this.getBindingCommand(attrSyntax, false);
    const bindingType = command === null ? 2048
    /* Interpolation */
    : command.bindingType;
    const attrTarget = attrSyntax.target;
    const attrRawValue = attrSyntax.rawValue;
    let expr;

    if (attrRawValue.length === 0 && (bindingType & 53
    /* BindCommand */
    | 49
    /* OneTimeCommand */
    | 50
    /* ToViewCommand */
    | 52
    /* TwoWayCommand */
    ) > 0) {
      if ((bindingType & 53
      /* BindCommand */
      | 49
      /* OneTimeCommand */
      | 50
      /* ToViewCommand */
      | 52
      /* TwoWayCommand */
      ) > 0) {
        // Default to the name of the attr for empty binding commands
        expr = this.exprParser.parse((0, _kernel.camelCase)(attrTarget), bindingType);
      } else {
        return;
      }
    } else {
      expr = this.exprParser.parse(attrRawValue, bindingType);
    }

    if ((manifest.flags & 16
    /* isCustomElement */
    ) > 0) {
      const bindable = manifest.bindables[attrTarget];

      if (bindable != null) {
        // if the attribute name matches a bindable property name, add it regardless of whether it's a command, interpolation, or just a plain string;
        // the template compiler will translate it to the correct instruction
        manifest.bindings.push(new _semanticModel.BindingSymbol(command, bindable, expr, attrRawValue, attrTarget));
        manifest.isTarget = true;
      } else if (expr != null) {
        // if it does not map to a bindable, only add it if we were able to parse an expression (either a command or interpolation)
        manifest.plainAttributes.push(new _semanticModel.PlainAttributeSymbol(attrSyntax, command, expr));
        manifest.isTarget = true;
      }
    } else if (expr != null) {
      // either a binding command, an interpolation, or a ref
      manifest.plainAttributes.push(new _semanticModel.PlainAttributeSymbol(attrSyntax, command, expr));
      manifest.isTarget = true;
    } else if (manifest === surrogate) {
      // any attributes, even if they are plain (no command/interpolation etc), should be added if they
      // are on the surrogate element
      manifest.plainAttributes.push(new _semanticModel.PlainAttributeSymbol(attrSyntax, command, expr));
    }

    if (command == null && expr != null) {
      // if it's an interpolation, clear the attribute value
      attr.value = '';
    }
  }
  /**
   * Retrieve a binding command resource.
   *
   * @param name - The parsed `AttrSyntax`
   *
   * @returns An instance of the command if it exists, or `null` if it does not exist.
   */


  getBindingCommand(syntax, optional) {
    const name = syntax.command;

    if (name === null) {
      return null;
    }

    let result = this.commandLookup[name];

    if (result === void 0) {
      result = this.container.create(_bindingCommand.BindingCommand, name);

      if (result === null) {
        if (optional) {
          return null;
        }

        throw new Error(`Unknown binding command: ${name}`);
      }

      this.commandLookup[name] = result;
    }

    return result;
  }

}

exports.TemplateBinder = TemplateBinder;
});

;define.alias('@aurelia/runtime-html/template-binder.js','@aurelia/runtime-html/dist/esm/template-binder.js');
define('@aurelia/runtime-html/dist/esm/template-compiler.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime','./attribute-syntax-transformer.js','./template-binder.js','./template-element-factory.js','./renderer.js','./platform.js','./bindable.js','./resources/attribute-pattern.js','./resources/custom-elements/au-slot.js','./resources/custom-element.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.TemplateCompiler = void 0;

var _kernel = require("@aurelia/kernel");

var _runtime = require("@aurelia/runtime");

var _attributeSyntaxTransformer = require("./attribute-syntax-transformer.js");

var _templateBinder = require("./template-binder.js");

var _templateElementFactory = require("./template-element-factory.js");

var _renderer = require("./renderer.js");

var _platform = require("./platform.js");

var _bindable = require("./bindable.js");

var _attributePattern = require("./resources/attribute-pattern.js");

var _auSlot = require("./resources/custom-elements/au-slot.js");

var _customElement = require("./resources/custom-element.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

class CustomElementCompilationUnit {
  constructor(partialDefinition, surrogate, template) {
    this.partialDefinition = partialDefinition;
    this.surrogate = surrogate;
    this.template = template;
    this.instructions = [];
    this.surrogates = [];
    this.projectionsMap = new Map();
  }

  toDefinition() {
    const def = this.partialDefinition;
    return _customElement.CustomElementDefinition.create({ ...def,
      instructions: (0, _kernel.mergeArrays)(def.instructions, this.instructions),
      surrogates: (0, _kernel.mergeArrays)(def.surrogates, this.surrogates),
      template: this.template,
      needsCompile: false,
      hasSlots: this.surrogate.hasSlots,
      projectionsMap: this.projectionsMap
    });
  }

}

var LocalTemplateBindableAttributes;

(function (LocalTemplateBindableAttributes) {
  LocalTemplateBindableAttributes["property"] = "property";
  LocalTemplateBindableAttributes["attribute"] = "attribute";
  LocalTemplateBindableAttributes["mode"] = "mode";
})(LocalTemplateBindableAttributes || (LocalTemplateBindableAttributes = {}));

const allowedLocalTemplateBindableAttributes = Object.freeze(["property"
/* property */
, "attribute"
/* attribute */
, "mode"
/* mode */
]);
const localTemplateIdentifier = 'as-custom-element';
/**
 * Default (runtime-agnostic) implementation for `ITemplateCompiler`.
 *
 * @internal
 */

let TemplateCompiler = class TemplateCompiler {
  constructor(factory, attrParser, exprParser, attrSyntaxModifier, logger, p) {
    this.factory = factory;
    this.attrParser = attrParser;
    this.exprParser = exprParser;
    this.attrSyntaxModifier = attrSyntaxModifier;
    this.p = p;
    this.logger = logger.scopeTo('TemplateCompiler');
  }

  get name() {
    return 'default';
  }

  static register(container) {
    return _kernel.Registration.singleton(_renderer.ITemplateCompiler, this).register(container);
  }

  compile(partialDefinition, context, targetedProjections) {
    const definition = _customElement.CustomElementDefinition.getOrCreate(partialDefinition);

    if (definition.template === null || definition.template === void 0) {
      return definition;
    }

    const {
      attrParser,
      exprParser,
      attrSyntaxModifier,
      factory
    } = this;
    const p = context.get(_platform.IPlatform);
    const binder = new _templateBinder.TemplateBinder(p, context, attrParser, exprParser, attrSyntaxModifier);
    const template = definition.enhance === true ? definition.template : factory.createTemplate(definition.template);
    processLocalTemplates(template, definition, context, p, this.logger);
    const surrogate = binder.bind(template);
    const compilation = this.compilation = new CustomElementCompilationUnit(definition, surrogate, template);
    const customAttributes = surrogate.customAttributes;
    const plainAttributes = surrogate.plainAttributes;
    const customAttributeLength = customAttributes.length;
    const plainAttributeLength = plainAttributes.length;

    if (customAttributeLength + plainAttributeLength > 0) {
      let offset = 0;

      for (let i = 0; customAttributeLength > i; ++i) {
        compilation.surrogates[offset] = this.compileCustomAttribute(customAttributes[i]);
        offset++;
      }

      for (let i = 0; i < plainAttributeLength; ++i) {
        compilation.surrogates[offset] = this.compilePlainAttribute(plainAttributes[i], true);
        offset++;
      }
    }

    this.compileChildNodes(surrogate, compilation.instructions, compilation.projectionsMap, targetedProjections);
    const compiledDefinition = compilation.toDefinition();
    this.compilation = null;
    return compiledDefinition;
  }

  compileChildNodes(parent, instructionRows, projections, targetedProjections) {
    if ((parent.flags & 16384
    /* hasChildNodes */
    ) > 0) {
      const childNodes = parent.childNodes;
      const ii = childNodes.length;
      let childNode;

      for (let i = 0; i < ii; ++i) {
        childNode = childNodes[i];

        if ((childNode.flags & 128
        /* isText */
        ) > 0) {
          instructionRows.push([new _renderer.TextBindingInstruction(childNode.interpolation)]);
        } else if ((childNode.flags & 32
        /* isLetElement */
        ) > 0) {
          const bindings = childNode.bindings;
          const instructions = [];
          let binding;
          const jj = bindings.length;

          for (let j = 0; j < jj; ++j) {
            binding = bindings[j];
            instructions[j] = new _renderer.LetBindingInstruction(binding.expression, binding.target);
          }

          instructionRows.push([new _renderer.HydrateLetElementInstruction(instructions, childNode.toBindingContext)]);
        } else {
          this.compileParentNode(childNode, instructionRows, projections, targetedProjections);
        }
      }
    }
  }

  compileCustomElement(symbol, instructionRows, projections, targetedProjections) {
    const isAuSlot = (symbol.flags & 512
    /* isAuSlot */
    ) > 0; // offset 1 to leave a spot for the hydrate instruction so we don't need to create 2 arrays with a spread etc

    const instructionRow = this.compileAttributes(symbol, 1);
    const slotName = symbol.slotName;
    let slotInfo = null;

    if (isAuSlot) {
      const targetedProjection = targetedProjections?.projections?.[slotName];
      slotInfo = targetedProjection !== void 0 ? new _auSlot.SlotInfo(slotName, _auSlot.AuSlotContentType.Projection, new _auSlot.ProjectionContext(targetedProjection, targetedProjections?.scope)) : new _auSlot.SlotInfo(slotName, _auSlot.AuSlotContentType.Fallback, new _auSlot.ProjectionContext(this.compileProjectionFallback(symbol, projections, targetedProjections)));
    }

    const instruction = instructionRow[0] = new _renderer.HydrateElementInstruction(symbol.res, symbol.info.alias, this.compileBindings(symbol), slotInfo);
    const compiledProjections = this.compileProjections(symbol, projections, targetedProjections);

    if (compiledProjections !== null) {
      projections.set(instruction, compiledProjections);
    }

    instructionRows.push(instructionRow);

    if (!isAuSlot) {
      this.compileChildNodes(symbol, instructionRows, projections, targetedProjections);
    }
  }

  compilePlainElement(symbol, instructionRows, projections, targetedProjections) {
    const attributes = this.compileAttributes(symbol, 0);

    if (attributes.length > 0) {
      instructionRows.push(attributes);
    }

    this.compileChildNodes(symbol, instructionRows, projections, targetedProjections);
  }

  compileParentNode(symbol, instructionRows, projections, targetedProjections) {
    switch (symbol.flags & 1023
    /* type */
    ) {
      case 16
      /* isCustomElement */
      :
      case 512
      /* isAuSlot */
      :
        this.compileCustomElement(symbol, instructionRows, projections, targetedProjections);
        break;

      case 64
      /* isPlainElement */
      :
        this.compilePlainElement(symbol, instructionRows, projections, targetedProjections);
        break;

      case 1
      /* isTemplateController */
      :
        this.compileTemplateController(symbol, instructionRows, projections, targetedProjections);
    }
  }

  compileTemplateController(symbol, instructionRows, projections, targetedProjections) {
    const bindings = this.compileBindings(symbol);
    const controllerInstructionRows = [];
    this.compileParentNode(symbol.template, controllerInstructionRows, projections, targetedProjections);

    const def = _customElement.CustomElementDefinition.create({
      name: symbol.info.alias ?? symbol.info.name,
      template: symbol.physicalNode,
      instructions: controllerInstructionRows,
      needsCompile: false
    });

    instructionRows.push([new _renderer.HydrateTemplateController(def, symbol.res, symbol.info.alias, bindings)]);
  }

  compileBindings(symbol) {
    let bindingInstructions;

    if ((symbol.flags & 8192
    /* hasBindings */
    ) > 0) {
      // either a custom element with bindings, a custom attribute / template controller with dynamic options,
      // or a single value custom attribute binding
      const {
        bindings
      } = symbol;
      const len = bindings.length;
      bindingInstructions = Array(len);
      let i = 0;

      for (; i < len; ++i) {
        bindingInstructions[i] = this.compileBinding(bindings[i]);
      }
    } else {
      bindingInstructions = _kernel.emptyArray;
    }

    return bindingInstructions;
  }

  compileBinding(symbol) {
    if (symbol.command === null) {
      // either an interpolation or a normal string value assigned to an element or attribute binding
      if (symbol.expression === null) {
        // the template binder already filtered out non-bindables, so we know we need a setProperty here
        return new _renderer.SetPropertyInstruction(symbol.rawValue, symbol.bindable.propName);
      } else {
        // either an element binding interpolation or a dynamic options attribute binding interpolation
        return new _renderer.InterpolationInstruction(symbol.expression, symbol.bindable.propName);
      }
    } else {
      // either an element binding command, dynamic options attribute binding command,
      // or custom attribute / template controller (single value) binding command
      return symbol.command.compile(symbol);
    }
  }

  compileAttributes(symbol, offset) {
    let attributeInstructions;

    if ((symbol.flags & 4096
    /* hasAttributes */
    ) > 0) {
      // any attributes on a custom element (which are not bindables) or a plain element
      const customAttributes = symbol.customAttributes;
      const plainAttributes = symbol.plainAttributes;
      const customAttributeLength = customAttributes.length;
      const plainAttributesLength = plainAttributes.length;
      attributeInstructions = Array(offset + customAttributeLength + plainAttributesLength);

      for (let i = 0; customAttributeLength > i; ++i) {
        attributeInstructions[offset] = this.compileCustomAttribute(customAttributes[i]);
        offset++;
      }

      for (let i = 0; plainAttributesLength > i; ++i) {
        attributeInstructions[offset] = this.compilePlainAttribute(plainAttributes[i], false);
        offset++;
      }
    } else if (offset > 0) {
      attributeInstructions = Array(offset);
    } else {
      attributeInstructions = _kernel.emptyArray;
    }

    return attributeInstructions;
  }

  compileCustomAttribute(symbol) {
    // a normal custom attribute (not template controller)
    const bindings = this.compileBindings(symbol);
    return new _renderer.HydrateAttributeInstruction(symbol.res, symbol.info.alias, bindings);
  }

  compilePlainAttribute(symbol, isOnSurrogate) {
    if (symbol.command === null) {
      const syntax = symbol.syntax;

      if (symbol.expression === null) {
        const attrRawValue = syntax.rawValue;

        if (isOnSurrogate) {
          switch (syntax.target) {
            case 'class':
              return new _renderer.SetClassAttributeInstruction(attrRawValue);

            case 'style':
              return new _renderer.SetStyleAttributeInstruction(attrRawValue);
            // todo:  define how to merge other attribute peacefully
            //        this is an existing feature request
          }
        } // a plain attribute on a surrogate


        return new _renderer.SetAttributeInstruction(attrRawValue, syntax.target);
      } else {
        // a plain attribute with an interpolation
        return new _renderer.InterpolationInstruction(symbol.expression, syntax.target);
      }
    } else {
      // a plain attribute with a binding command
      return symbol.command.compile(symbol);
    }
  } // private compileAttribute(symbol: IAttributeSymbol): AttributeInstruction {
  //   // any attribute on a custom element (which is not a bindable) or a plain element
  //   if (symbol.flags & SymbolFlags.isCustomAttribute) {
  //     return this.compileCustomAttribute(symbol as CustomAttributeSymbol);
  //   } else {
  //     return this.compilePlainAttribute(symbol as PlainAttributeSymbol);
  //   }
  // }


  compileProjections(symbol, projectionMap, targetedProjections) {
    if ((symbol.flags & 32768
    /* hasProjections */
    ) === 0) {
      return null;
    }

    const p = this.p;
    const projections = Object.create(null);
    const $projections = symbol.projections;
    const len = $projections.length;

    for (let i = 0; i < len; ++i) {
      const projection = $projections[i];
      const name = projection.name;
      const instructions = [];
      this.compileParentNode(projection.template, instructions, projectionMap, targetedProjections);
      const definition = projections[name];

      if (definition === void 0) {
        let template = projection.template.physicalNode;

        if (template.tagName !== 'TEMPLATE') {
          const _template = p.document.createElement('template');

          _template.content.appendChild(template);

          template = _template;
        }

        projections[name] = _customElement.CustomElementDefinition.create({
          name,
          template,
          instructions,
          needsCompile: false
        });
      } else {
        // consolidate the projections to same slot
        definition.template.content.appendChild(projection.template.physicalNode);
        definition.instructions.push(...instructions);
      }
    }

    return projections;
  }

  compileProjectionFallback(symbol, projections, targetedProjections) {
    const instructions = [];
    this.compileChildNodes(symbol, instructions, projections, targetedProjections);
    const template = this.p.document.createElement('template');
    template.content.append(...(0, _kernel.toArray)(symbol.physicalNode.childNodes));
    return _customElement.CustomElementDefinition.create({
      name: _customElement.CustomElement.generateName(),
      template,
      instructions,
      needsCompile: false
    });
  }

};
exports.TemplateCompiler = TemplateCompiler;
exports.TemplateCompiler = TemplateCompiler = __decorate([__param(0, _templateElementFactory.ITemplateElementFactory), __param(1, _attributePattern.IAttributeParser), __param(2, _runtime.IExpressionParser), __param(3, _attributeSyntaxTransformer.IAttrSyntaxTransformer), __param(4, _kernel.ILogger), __param(5, _platform.IPlatform)], TemplateCompiler);

function processTemplateName(localTemplate, localTemplateNames) {
  const name = localTemplate.getAttribute(localTemplateIdentifier);

  if (name === null || name === '') {
    throw new Error('The value of "as-custom-element" attribute cannot be empty for local template');
  }

  if (localTemplateNames.has(name)) {
    throw new Error(`Duplicate definition of the local template named ${name}`);
  } else {
    localTemplateNames.add(name);
    localTemplate.removeAttribute(localTemplateIdentifier);
  }

  return name;
}

function getBindingMode(bindable) {
  switch (bindable.getAttribute("mode"
  /* mode */
  )) {
    case 'oneTime':
      return _runtime.BindingMode.oneTime;

    case 'toView':
      return _runtime.BindingMode.toView;

    case 'fromView':
      return _runtime.BindingMode.fromView;

    case 'twoWay':
      return _runtime.BindingMode.twoWay;

    case 'default':
    default:
      return _runtime.BindingMode.default;
  }
}

function processLocalTemplates(template, definition, context, p, logger) {
  let root;

  if (template.nodeName === 'TEMPLATE') {
    if (template.hasAttribute(localTemplateIdentifier)) {
      throw new Error('The root cannot be a local template itself.');
    }

    root = template.content;
  } else {
    root = template;
  }

  const localTemplates = (0, _kernel.toArray)(root.querySelectorAll('template[as-custom-element]'));
  const numLocalTemplates = localTemplates.length;

  if (numLocalTemplates === 0) {
    return;
  }

  if (numLocalTemplates === root.childElementCount) {
    throw new Error('The custom element does not have any content other than local template(s).');
  }

  const localTemplateNames = new Set();

  for (const localTemplate of localTemplates) {
    if (localTemplate.parentNode !== root) {
      throw new Error('Local templates needs to be defined directly under root.');
    }

    const name = processTemplateName(localTemplate, localTemplateNames);
    const localTemplateType = class LocalTemplate {};
    const content = localTemplate.content;
    const bindableEls = (0, _kernel.toArray)(content.querySelectorAll('bindable'));

    const bindableInstructions = _bindable.Bindable.for(localTemplateType);

    const properties = new Set();
    const attributes = new Set();

    for (const bindableEl of bindableEls) {
      if (bindableEl.parentNode !== content) {
        throw new Error('Bindable properties of local templates needs to be defined directly under root.');
      }

      const property = bindableEl.getAttribute("property"
      /* property */
      );

      if (property === null) {
        throw new Error(`The attribute 'property' is missing in ${bindableEl.outerHTML}`);
      }

      const attribute = bindableEl.getAttribute("attribute"
      /* attribute */
      );

      if (attribute !== null && attributes.has(attribute) || properties.has(property)) {
        throw new Error(`Bindable property and attribute needs to be unique; found property: ${property}, attribute: ${attribute}`);
      } else {
        if (attribute !== null) {
          attributes.add(attribute);
        }

        properties.add(property);
      }

      bindableInstructions.add({
        property,
        attribute: attribute ?? void 0,
        mode: getBindingMode(bindableEl)
      });
      const ignoredAttributes = bindableEl.getAttributeNames().filter(attrName => !allowedLocalTemplateBindableAttributes.includes(attrName));

      if (ignoredAttributes.length > 0) {
        logger.warn(`The attribute(s) ${ignoredAttributes.join(', ')} will be ignored for ${bindableEl.outerHTML}. Only ${allowedLocalTemplateBindableAttributes.join(', ')} are processed.`);
      }

      content.removeChild(bindableEl);
    }

    const localTemplateDefinition = _customElement.CustomElement.define({
      name,
      template: localTemplate
    }, localTemplateType); // the casting is needed here as the dependencies are typed as readonly array


    definition.dependencies.push(localTemplateDefinition);
    context.register(localTemplateDefinition);
    root.removeChild(localTemplate);
  }
}
});

;define.alias('@aurelia/runtime-html/template-compiler.js','@aurelia/runtime-html/dist/esm/template-compiler.js');
define('@aurelia/runtime-html/dist/esm/template-element-factory.js',['require','exports','module','@aurelia/kernel','./platform.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.TemplateElementFactory = exports.ITemplateElementFactory = void 0;

var _kernel = require("@aurelia/kernel");

var _platform = require("./platform.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

const ITemplateElementFactory = _kernel.DI.createInterface('ITemplateElementFactory', x => x.singleton(TemplateElementFactory));

exports.ITemplateElementFactory = ITemplateElementFactory;
const markupCache = {};
let TemplateElementFactory = class TemplateElementFactory {
  constructor(p) {
    this.p = p;
    this.template = p.document.createElement('template');
  }

  createTemplate(input) {
    if (typeof input === 'string') {
      let result = markupCache[input];

      if (result === void 0) {
        const template = this.template;
        template.innerHTML = input;
        const node = template.content.firstElementChild; // if the input is either not wrapped in a template or there is more than one node,
        // return the whole template that wraps it/them (and create a new one for the next input)

        if (node == null || node.nodeName !== 'TEMPLATE' || node.nextElementSibling != null) {
          this.template = this.p.document.createElement('template');
          result = template;
        } else {
          // the node to return is both a template and the only node, so return just the node
          // and clean up the template for the next input
          template.content.removeChild(node);
          result = node;
        }

        markupCache[input] = result;
      }

      return result.cloneNode(true);
    }

    if (input.nodeName !== 'TEMPLATE') {
      // if we get one node that is not a template, wrap it in one
      const template = this.p.document.createElement('template');
      template.content.appendChild(input);
      return template;
    } // we got a template element, remove it from the DOM if it's present there and don't
    // do any other processing


    input.parentNode?.removeChild(input);
    return input.cloneNode(true);
  }

};
exports.TemplateElementFactory = TemplateElementFactory;
exports.TemplateElementFactory = TemplateElementFactory = __decorate([__param(0, _platform.IPlatform)], TemplateElementFactory);
});

;define.alias('@aurelia/runtime-html/template-element-factory.js','@aurelia/runtime-html/dist/esm/template-element-factory.js');
define('@aurelia/runtime-html/dist/esm/templating/children.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime','../resources/custom-element.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.children = children;
exports.filterChildren = filterChildren;
exports.ChildrenObserver = exports.ChildrenDefinition = exports.Children = void 0;

var _kernel = require("@aurelia/kernel");

var _runtime = require("@aurelia/runtime");

var _customElement = require("../resources/custom-element.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var ChildrenObserver_1;

function children(configOrTarget, prop) {
  let config;

  function decorator($target, $prop) {
    if (arguments.length > 1) {
      // Non invocation:
      // - @children
      // Invocation with or w/o opts:
      // - @children()
      // - @children({...opts})
      config.property = $prop;
    }

    _kernel.Metadata.define(Children.name, ChildrenDefinition.create($prop, config), $target.constructor, $prop);

    _kernel.Protocol.annotation.appendTo($target.constructor, Children.keyFrom($prop));
  }

  if (arguments.length > 1) {
    // Non invocation:
    // - @children
    config = {};
    decorator(configOrTarget, prop);
    return;
  } else if (typeof configOrTarget === 'string') {
    // ClassDecorator
    // - @children('bar')
    // Direct call:
    // - @children('bar')(Foo)
    config = {};
    return decorator;
  } // Invocation with or w/o opts:
  // - @children()
  // - @children({...opts})


  config = configOrTarget === void 0 ? {} : configOrTarget;
  return decorator;
}

function isChildrenObserverAnnotation(key) {
  return key.startsWith(Children.name);
}

const Children = {
  name: _kernel.Protocol.annotation.keyFor('children-observer'),

  keyFrom(name) {
    return `${Children.name}:${name}`;
  },

  from(...childrenObserverLists) {
    const childrenObservers = {};
    const isArray = Array.isArray;

    function addName(name) {
      childrenObservers[name] = ChildrenDefinition.create(name);
    }

    function addDescription(name, def) {
      childrenObservers[name] = ChildrenDefinition.create(name, def);
    }

    function addList(maybeList) {
      if (isArray(maybeList)) {
        maybeList.forEach(addName);
      } else if (maybeList instanceof ChildrenDefinition) {
        childrenObservers[maybeList.property] = maybeList;
      } else if (maybeList !== void 0) {
        Object.keys(maybeList).forEach(name => addDescription(name, maybeList));
      }
    }

    childrenObserverLists.forEach(addList);
    return childrenObservers;
  },

  getAll(Type) {
    const propStart = Children.name.length + 1;
    const defs = [];
    const prototypeChain = (0, _kernel.getPrototypeChain)(Type);
    let iProto = prototypeChain.length;
    let iDefs = 0;
    let keys;
    let keysLen;
    let Class;

    while (--iProto >= 0) {
      Class = prototypeChain[iProto];
      keys = _kernel.Protocol.annotation.getKeys(Class).filter(isChildrenObserverAnnotation);
      keysLen = keys.length;

      for (let i = 0; i < keysLen; ++i) {
        defs[iDefs++] = _kernel.Metadata.getOwn(Children.name, Class, keys[i].slice(propStart));
      }
    }

    return defs;
  }

};
exports.Children = Children;
const childObserverOptions = {
  childList: true
};

class ChildrenDefinition {
  constructor(callback, property, options, query, filter, map) {
    this.callback = callback;
    this.property = property;
    this.options = options;
    this.query = query;
    this.filter = filter;
    this.map = map;
  }

  static create(prop, def = {}) {
    return new ChildrenDefinition((0, _kernel.firstDefined)(def.callback, `${prop}Changed`), (0, _kernel.firstDefined)(def.property, prop), def.options ?? childObserverOptions, def.query, def.filter, def.map);
  }

}
/** @internal */


exports.ChildrenDefinition = ChildrenDefinition;
let ChildrenObserver = ChildrenObserver_1 = class ChildrenObserver {
  constructor(controller, obj, propertyKey, cbName, query = defaultChildQuery, filter = defaultChildFilter, map = defaultChildMap, options) {
    this.controller = controller;
    this.obj = obj;
    this.propertyKey = propertyKey;
    this.query = query;
    this.filter = filter;
    this.map = map;
    this.options = options;
    this.observing = false;
    this.children = void 0;
    this.callback = obj[cbName];
    Reflect.defineProperty(this.obj, this.propertyKey, {
      enumerable: true,
      configurable: true,
      get: () => this.getValue(),
      set: () => {
        return;
      }
    });
  }

  getValue() {
    this.tryStartObserving();
    return this.children;
  }

  setValue(newValue) {}

  subscribe(subscriber) {
    this.tryStartObserving();
    this.subs.add(subscriber);
  }

  tryStartObserving() {
    if (!this.observing) {
      this.observing = true;
      this.children = filterChildren(this.controller, this.query, this.filter, this.map);
      const obs = new this.controller.host.ownerDocument.defaultView.MutationObserver(() => {
        this.onChildrenChanged();
      });
      obs.observe(this.controller.host, this.options);
    }
  }

  onChildrenChanged() {
    this.children = filterChildren(this.controller, this.query, this.filter, this.map);

    if (this.callback !== void 0) {
      this.callback.call(this.obj);
    }

    this.subs.notify(this.children, undefined, 8
    /* updateTarget */
    );
  }

};
exports.ChildrenObserver = ChildrenObserver;
exports.ChildrenObserver = ChildrenObserver = ChildrenObserver_1 = __decorate([(0, _runtime.subscriberCollection)()], ChildrenObserver);

function defaultChildQuery(controller) {
  return controller.host.childNodes;
}

function defaultChildFilter(node, controller, viewModel) {
  return !!viewModel;
}

function defaultChildMap(node, controller, viewModel) {
  return viewModel;
}

const forOpts = {
  optional: true
};
/** @internal */

function filterChildren(controller, query, filter, map) {
  const nodes = query(controller);
  const children = [];

  for (let i = 0, ii = nodes.length; i < ii; ++i) {
    const node = nodes[i];

    const $controller = _customElement.CustomElement.for(node, forOpts);

    const viewModel = $controller?.viewModel ?? null;

    if (filter(node, $controller, viewModel)) {
      children.push(map(node, $controller, viewModel));
    }
  }

  return children;
}
});

;define.alias('@aurelia/runtime-html/templating/children.js','@aurelia/runtime-html/dist/esm/templating/children.js');
define('@aurelia/runtime-html/dist/esm/templating/controller.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime','../observation/bindable-observer.js','../dom.js','../resources/custom-element.js','../resources/custom-attribute.js','./render-context.js','./children.js','../app-root.js','../platform.js','./styles.js','./watchers.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.isCustomElementController = isCustomElementController;
exports.isCustomElementViewModel = isCustomElementViewModel;
exports.stringifyState = stringifyState;
exports.IController = exports.State = exports.ViewModelKind = exports.HooksDefinition = exports.Controller = exports.MountTarget = void 0;

var _kernel = require("@aurelia/kernel");

var _runtime = require("@aurelia/runtime");

var _bindableObserver = require("../observation/bindable-observer.js");

var _dom = require("../dom.js");

var _customElement = require("../resources/custom-element.js");

var _customAttribute = require("../resources/custom-attribute.js");

var _renderContext = require("./render-context.js");

var _children = require("./children.js");

var _appRoot = require("../app-root.js");

var _platform = require("../platform.js");

var _styles = require("./styles.js");

var _watchers = require("./watchers.js");

/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */
function callDispose(disposable) {
  disposable.dispose();
}

var MountTarget;
exports.MountTarget = MountTarget;

(function (MountTarget) {
  MountTarget[MountTarget["none"] = 0] = "none";
  MountTarget[MountTarget["host"] = 1] = "host";
  MountTarget[MountTarget["shadowRoot"] = 2] = "shadowRoot";
  MountTarget[MountTarget["location"] = 3] = "location";
})(MountTarget || (exports.MountTarget = MountTarget = {}));

const optional = {
  optional: true
};
const controllerLookup = new WeakMap();

class Controller {
  constructor(root, container, vmKind, flags, definition,
  /**
   * The viewFactory. Only present for synthetic views.
   */
  viewFactory,
  /**
   * The backing viewModel. Only present for custom attributes and elements.
   */
  viewModel,
  /**
   * The physical host dom node.
   *
   * For containerless elements, this node will be removed from the DOM and replaced by a comment, which is assigned to the `location` property.
   *
   * For ShadowDOM elements, this will be the original declaring element, NOT the shadow root (the shadow root is stored on the `shadowRoot` property)
   */
  host) {
    this.root = root;
    this.container = container;
    this.vmKind = vmKind;
    this.flags = flags;
    this.definition = definition;
    this.viewFactory = viewFactory;
    this.viewModel = viewModel;
    this.host = host;
    this.id = (0, _kernel.nextId)('au$component');
    this.head = null;
    this.tail = null;
    this.next = null;
    this.parent = null;
    this.bindings = null;
    this.children = null;
    this.hasLockedScope = false;
    this.isStrictBinding = false;
    this.scope = null;
    this.hostScope = null; // If a host from another custom element was passed in, then this will be the controller for that custom element (could be `au-viewport` for example).
    // In that case, this controller will create a new host node (with the definition's name) and use that as the target host for the nodes instead.
    // That host node is separately mounted to the host controller's original host node.

    this.hostController = null;
    this.mountTarget = 0
    /* none */
    ;
    this.shadowRoot = null;
    this.nodes = null;
    this.context = null;
    this.location = null;
    this.state = 0
    /* none */
    ;
    this.logger = null;
    this.debug = false;
    this.fullyNamed = false;
    this.$initiator = null;
    this.$flags = 0
    /* none */
    ;
    this.$resolve = void 0;
    this.$reject = void 0;
    this.$promise = void 0;
    this.activatingStack = 0;
    this.detachingStack = 0;
    this.unbindingStack = 0;

    if (root === null && container.has(_appRoot.IAppRoot, true)) {
      this.root = container.get(_appRoot.IAppRoot);
    }

    this.platform = container.get(_platform.IPlatform);

    switch (vmKind) {
      case 1
      /* customAttribute */
      :
      case 0
      /* customElement */
      :
        this.hooks = new HooksDefinition(viewModel);
        break;

      case 2
      /* synthetic */
      :
        this.hooks = HooksDefinition.none;
        break;
    }
  }

  get isActive() {
    return (this.state & (1
    /* activating */
    | 2
    /* activated */
    )) > 0 && (this.state & 4
    /* deactivating */
    ) === 0;
  }

  get name() {
    if (this.parent === null) {
      switch (this.vmKind) {
        case 1
        /* customAttribute */
        :
          return `[${this.definition.name}]`;

        case 0
        /* customElement */
        :
          return this.definition.name;

        case 2
        /* synthetic */
        :
          return this.viewFactory.name;
      }
    }

    switch (this.vmKind) {
      case 1
      /* customAttribute */
      :
        return `${this.parent.name}>[${this.definition.name}]`;

      case 0
      /* customElement */
      :
        return `${this.parent.name}>${this.definition.name}`;

      case 2
      /* synthetic */
      :
        return this.viewFactory.name === this.parent.definition?.name ? `${this.parent.name}[view]` : `${this.parent.name}[view:${this.viewFactory.name}]`;
    }
  }

  static getCached(viewModel) {
    return controllerLookup.get(viewModel);
  }

  static getCachedOrThrow(viewModel) {
    const controller = Controller.getCached(viewModel);

    if (controller === void 0) {
      throw new Error(`There is no cached controller for the provided ViewModel: ${String(viewModel)}`);
    }

    return controller;
  }

  static forCustomElement(root, container, viewModel, host, // projections *targeted* for this custom element. these are not the projections *provided* by this custom element.
  targetedProjections, flags = 0
  /* none */
  , hydrate = true, // Use this when `instance.constructor` is not a custom element type to pass on the CustomElement definition
  definition = void 0) {
    if (controllerLookup.has(viewModel)) {
      return controllerLookup.get(viewModel);
    }

    definition = definition ?? _customElement.CustomElement.getDefinition(viewModel.constructor);
    const controller = new Controller(
    /* root           */
    root,
    /* container      */
    container, 0
    /* customElement */
    ,
    /* flags          */
    flags,
    /* definition     */
    definition,
    /* viewFactory    */
    null,
    /* viewModel      */
    viewModel,
    /* host           */
    host);
    controllerLookup.set(viewModel, controller);

    if (hydrate) {
      controller.hydrateCustomElement(container, targetedProjections);
    }

    return controller;
  }

  static forCustomAttribute(root, container, viewModel, host, flags = 0
  /* none */
  ) {
    if (controllerLookup.has(viewModel)) {
      return controllerLookup.get(viewModel);
    }

    const definition = _customAttribute.CustomAttribute.getDefinition(viewModel.constructor);

    const controller = new Controller(
    /* root           */
    root,
    /* container      */
    container, 1
    /* customAttribute */
    ,
    /* flags          */
    flags,
    /* definition     */
    definition,
    /* viewFactory    */
    null,
    /* viewModel      */
    viewModel,
    /* host           */
    host);
    controllerLookup.set(viewModel, controller);
    controller.hydrateCustomAttribute();
    return controller;
  }

  static forSyntheticView(root, context, viewFactory, flags = 0
  /* none */
  , parentController = void 0) {
    const controller = new Controller(
    /* root           */
    root,
    /* container      */
    context, 2
    /* synthetic */
    ,
    /* flags          */
    flags,
    /* definition     */
    null,
    /* viewFactory    */
    viewFactory,
    /* viewModel      */
    null,
    /* host           */
    null);
    controller.parent = parentController ?? null;
    controller.hydrateSynthetic(context);
    return controller;
  }
  /** @internal */


  hydrateCustomElement(parentContainer, targetedProjections) {
    this.logger = parentContainer.get(_kernel.ILogger).root;
    this.debug = this.logger.config.level <= 1
    /* debug */
    ;

    if (this.debug) {
      this.logger = this.logger.scopeTo(this.name);
    }

    let definition = this.definition;
    const flags = this.flags;
    const instance = this.viewModel;
    this.scope = _runtime.Scope.create(instance, null, true);

    if (definition.watches.length > 0) {
      createWatchers(this, this.container, definition, instance);
    }

    createObservers(this, definition, flags, instance);
    createChildrenObservers(this, definition, flags, instance);

    if (this.hooks.hasDefine) {
      if (this.debug) {
        this.logger.trace(`invoking define() hook`);
      }

      const result = instance.define(
      /* controller      */
      this,
      /* parentContainer */
      parentContainer,
      /* definition      */
      definition);

      if (result !== void 0 && result !== definition) {
        definition = _customElement.CustomElementDefinition.getOrCreate(result);
      }
    }

    const context = this.context = (0, _renderContext.getRenderContext)(definition, parentContainer, targetedProjections?.projections); // Support Recursive Components by adding self to own context

    definition.register(context);

    if (definition.injectable !== null) {
      // If the element is registered as injectable, support injecting the instance into children
      context.beginChildComponentOperation(instance);
    } // If this is the root controller, then the AppRoot will invoke things in the following order:
    // - Controller.hydrateCustomElement
    // - runAppTasks('hydrating') // may return a promise
    // - Controller.compile
    // - runAppTasks('hydrated') // may return a promise
    // - Controller.compileChildren
    // This keeps hydration synchronous while still allowing the composition root compile hooks to do async work.


    if (this.root?.controller !== this) {
      this.hydrate(targetedProjections);
      this.hydrateChildren();
    }
  }
  /** @internal */


  hydrate(targetedProjections) {
    if (this.hooks.hasHydrating) {
      if (this.debug) {
        this.logger.trace(`invoking hasHydrating() hook`);
      }

      this.viewModel.hydrating(this);
    }

    const compiledContext = this.context.compile(targetedProjections);
    const {
      projectionsMap,
      shadowOptions,
      isStrictBinding,
      hasSlots,
      containerless
    } = compiledContext.compiledDefinition;
    compiledContext.registerProjections(projectionsMap, this.scope); // once the projections are registered, we can cleanup the projection map to prevent memory leaks.

    projectionsMap.clear();
    this.isStrictBinding = isStrictBinding;

    if ((this.hostController = _customElement.CustomElement.for(this.host, optional)) !== null) {
      this.host = this.platform.document.createElement(this.context.definition.name);
    }

    _kernel.Metadata.define(_customElement.CustomElement.name, this, this.host);

    if (shadowOptions !== null || hasSlots) {
      if (containerless) {
        throw new Error('You cannot combine the containerless custom element option with Shadow DOM.');
      }

      _kernel.Metadata.define(_customElement.CustomElement.name, this, this.shadowRoot = this.host.attachShadow(shadowOptions ?? defaultShadowOptions));

      this.mountTarget = 2
      /* shadowRoot */
      ;
    } else if (containerless) {
      _kernel.Metadata.define(_customElement.CustomElement.name, this, this.location = (0, _dom.convertToRenderLocation)(this.host));

      this.mountTarget = 3
      /* location */
      ;
    } else {
      this.mountTarget = 1
      /* host */
      ;
    }

    this.viewModel.$controller = this;
    this.nodes = compiledContext.createNodes();

    if (this.hooks.hasHydrated) {
      if (this.debug) {
        this.logger.trace(`invoking hasHydrated() hook`);
      }

      this.viewModel.hydrated(this);
    }
  }
  /** @internal */


  hydrateChildren() {
    const targets = this.nodes.findTargets();
    this.context.render(
    /* flags      */
    this.flags,
    /* controller */
    this,
    /* targets    */
    targets,
    /* definition */
    this.context.compiledDefinition,
    /* host       */
    this.host);

    if (this.hooks.hasCreated) {
      if (this.debug) {
        this.logger.trace(`invoking created() hook`);
      }

      this.viewModel.created(this);
    }
  }

  hydrateCustomAttribute() {
    const definition = this.definition;
    const instance = this.viewModel;

    if (definition.watches.length > 0) {
      createWatchers(this, this.container, definition, instance);
    }

    createObservers(this, definition, this.flags, instance);
    instance.$controller = this;
  }

  hydrateSynthetic(context) {
    this.context = context;
    const compiledContext = context.compile(null);
    const compiledDefinition = compiledContext.compiledDefinition;
    this.isStrictBinding = compiledDefinition.isStrictBinding;
    const nodes = this.nodes = compiledContext.createNodes();
    const targets = nodes.findTargets();
    compiledContext.render(
    /* flags      */
    this.flags,
    /* controller */
    this,
    /* targets    */
    targets,
    /* definition */
    compiledDefinition,
    /* host       */
    void 0);
  }

  activate(initiator, parent, flags, scope, hostScope) {
    switch (this.state) {
      case 0
      /* none */
      :
      case 8
      /* deactivated */
      :
        if (!(parent === null || parent.isActive)) {
          // If this is not the root, and the parent is either:
          // 1. Not activated, or activating children OR
          // 2. Deactivating itself
          // abort.
          return;
        } // Otherwise, proceed normally.
        // 'deactivated' and 'none' are treated the same because, from an activation perspective, they mean the same thing.


        this.state = 1
        /* activating */
        ;
        break;

      case 2
      /* activated */
      :
        // If we're already activated, no need to do anything.
        return;

      case 32
      /* disposed */
      :
        throw new Error(`${this.name} trying to activate a controller that is disposed.`);

      default:
        throw new Error(`${this.name} unexpected state: ${stringifyState(this.state)}.`);
    }

    this.parent = parent;

    if (this.debug && !this.fullyNamed) {
      this.fullyNamed = true;
      this.logger = this.context.get(_kernel.ILogger).root.scopeTo(this.name);
      this.logger.trace(`activate()`);
    }

    this.hostScope = hostScope ?? null;
    flags |= 32
    /* fromBind */
    ;

    switch (this.vmKind) {
      case 0
      /* customElement */
      :
        // Custom element scope is created and assigned during hydration
        this.scope.parentScope = scope ?? null;
        break;

      case 1
      /* customAttribute */
      :
        this.scope = scope ?? null;
        break;

      case 2
      /* synthetic */
      :
        if (scope === void 0 || scope === null) {
          throw new Error(`Scope is null or undefined`);
        }

        if (!this.hasLockedScope) {
          this.scope = scope;
        }

        break;
    }

    if (this.isStrictBinding) {
      flags |= 4
      /* isStrictBindingStrategy */
      ;
    }

    this.$initiator = initiator;
    this.$flags = flags; // opposing leave is called in attach() (which will trigger attached())

    this.enterActivating();

    if (this.hooks.hasBinding) {
      if (this.debug) {
        this.logger.trace(`binding()`);
      }

      const ret = this.viewModel.binding(this.$initiator, this.parent, this.$flags);

      if (ret instanceof Promise) {
        this.ensurePromise();
        ret.then(() => {
          this.bind();
        }).catch(err => {
          this.reject(err);
        });
        return this.$promise;
      }
    }

    this.bind();
    return this.$promise;
  }

  bind() {
    if (this.debug) {
      this.logger.trace(`bind()`);
    }

    if (this.bindings !== null) {
      for (let i = 0; i < this.bindings.length; ++i) {
        this.bindings[i].$bind(this.$flags, this.scope, this.hostScope);
      }
    }

    if (this.hooks.hasBound) {
      if (this.debug) {
        this.logger.trace(`bound()`);
      }

      const ret = this.viewModel.bound(this.$initiator, this.parent, this.$flags);

      if (ret instanceof Promise) {
        this.ensurePromise();
        ret.then(() => {
          this.attach();
        }).catch(err => {
          this.reject(err);
        });
        return;
      }
    }

    this.attach();
  }

  append(...nodes) {
    switch (this.mountTarget) {
      case 1
      /* host */
      :
        this.host.append(...nodes);
        break;

      case 2
      /* shadowRoot */
      :
        this.shadowRoot.append(...nodes);
        break;

      case 3
      /* location */
      :
        for (let i = 0; i < nodes.length; ++i) {
          this.location.parentNode.insertBefore(nodes[i], this.location);
        }

        break;
    }
  }

  attach() {
    if (this.debug) {
      this.logger.trace(`attach()`);
    }

    if (this.hostController !== null) {
      switch (this.mountTarget) {
        case 1
        /* host */
        :
        case 2
        /* shadowRoot */
        :
          this.hostController.append(this.host);
          break;

        case 3
        /* location */
        :
          this.hostController.append(this.location.$start, this.location);
          break;
      }
    }

    switch (this.mountTarget) {
      case 1
      /* host */
      :
        this.nodes.appendTo(this.host, this.definition?.enhance);
        break;

      case 2
      /* shadowRoot */
      :
        {
          const styles = this.context.has(_styles.IShadowDOMStyles, false) ? this.context.get(_styles.IShadowDOMStyles) : this.context.get(_styles.IShadowDOMGlobalStyles);
          styles.applyTo(this.shadowRoot);
          this.nodes.appendTo(this.shadowRoot);
          break;
        }

      case 3
      /* location */
      :
        this.nodes.insertBefore(this.location);
        break;
    }

    if (this.hooks.hasAttaching) {
      if (this.debug) {
        this.logger.trace(`attaching()`);
      }

      const ret = this.viewModel.attaching(this.$initiator, this.parent, this.$flags);

      if (ret instanceof Promise) {
        this.ensurePromise();
        this.enterActivating();
        ret.then(() => {
          this.leaveActivating();
        }).catch(err => {
          this.reject(err);
        });
      }
    } // attaching() and child activation run in parallel, and attached() is called when both are finished


    if (this.children !== null) {
      for (let i = 0; i < this.children.length; ++i) {
        // Any promises returned from child activation are cumulatively awaited before this.$promise resolves
        void this.children[i].activate(this.$initiator, this, this.$flags, this.scope, this.hostScope);
      }
    } // attached() is invoked by Controller#leaveActivating when `activatingStack` reaches 0


    this.leaveActivating();
  }

  deactivate(initiator, parent, flags) {
    switch (this.state & ~16
    /* released */
    ) {
      case 2
      /* activated */
      :
        // We're fully activated, so proceed with normal deactivation.
        this.state = 4
        /* deactivating */
        ;
        break;

      case 0
      /* none */
      :
      case 8
      /* deactivated */
      :
      case 32
      /* disposed */
      :
      case 8
      /* deactivated */
      | 32
      /* disposed */
      :
        // If we're already deactivated (or even disposed), or never activated in the first place, no need to do anything.
        return;

      default:
        throw new Error(`${this.name} unexpected state: ${stringifyState(this.state)}.`);
    }

    if (this.debug) {
      this.logger.trace(`deactivate()`);
    }

    this.$initiator = initiator;
    this.$flags = flags;

    if (initiator === this) {
      this.enterDetaching();
    }

    if (this.children !== null) {
      for (let i = 0; i < this.children.length; ++i) {
        // Child promise results are tracked by enter/leave combo's
        void this.children[i].deactivate(initiator, this, flags);
      }
    }

    if (this.hooks.hasDetaching) {
      if (this.debug) {
        this.logger.trace(`detaching()`);
      }

      const ret = this.viewModel.detaching(this.$initiator, this.parent, this.$flags);

      if (ret instanceof Promise) {
        this.ensurePromise();
        initiator.enterDetaching();
        ret.then(() => {
          initiator.leaveDetaching();
        }).catch(err => {
          initiator.reject(err);
        });
      }
    } // Note: if a 3rd party plugin happens to do any async stuff in a template controller before calling deactivate on its view,
    // then the linking will become out of order.
    // For framework components, this shouldn't cause issues.
    // We can only prevent that by linking up after awaiting the detaching promise, which would add an extra tick + a fair bit of
    // overhead on this hot path, so it's (for now) a deliberate choice to not account for such situation.
    // Just leaving the note here so that we know to look here if a weird detaching-related timing issue is ever reported.


    if (initiator.head === null) {
      initiator.head = this;
    } else {
      initiator.tail.next = this;
    }

    initiator.tail = this;

    if (initiator !== this) {
      // Only detaching is called + the linked list is built when any controller that is not the initiator, is deactivated.
      // The rest is handled by the initiator.
      // This means that descendant controllers have to make sure to await the initiator's promise before doing any subsequent
      // controller api calls, or race conditions might occur.
      return;
    }

    this.leaveDetaching();
    return this.$promise;
  }

  removeNodes() {
    switch (this.vmKind) {
      case 0
      /* customElement */
      :
      case 2
      /* synthetic */
      :
        this.nodes.remove();
        this.nodes.unlink();
    }

    if (this.hostController !== null) {
      switch (this.mountTarget) {
        case 1
        /* host */
        :
        case 2
        /* shadowRoot */
        :
          this.host.remove();
          break;

        case 3
        /* location */
        :
          this.location.$start.remove();
          this.location.remove();
          break;
      }
    }
  }

  unbind() {
    if (this.debug) {
      this.logger.trace(`unbind()`);
    }

    const flags = this.$flags | 64
    /* fromUnbind */
    ;

    if (this.bindings !== null) {
      for (let i = 0; i < this.bindings.length; ++i) {
        this.bindings[i].$unbind(flags);
      }
    }

    this.parent = null;

    switch (this.vmKind) {
      case 1
      /* customAttribute */
      :
        this.scope = null;
        break;

      case 2
      /* synthetic */
      :
        if (!this.hasLockedScope) {
          this.scope = null;
        }

        if ((this.state & 16
        /* released */
        ) === 16
        /* released */
        && !this.viewFactory.tryReturnToCache(this)) {
          this.dispose();
        }

        break;

      case 0
      /* customElement */
      :
        this.scope.parentScope = null;
        break;
    }

    if ((flags & 512
    /* dispose */
    ) === 512
    /* dispose */
    ) {
        this.dispose();
      }

    this.state = this.state & 32
    /* disposed */
    | 8
    /* deactivated */
    ;
    this.$initiator = null;
    this.resolve();
  }

  ensurePromise() {
    if (this.$promise === void 0) {
      this.$promise = new Promise((resolve, reject) => {
        this.$resolve = resolve;
        this.$reject = reject;
      });

      if (this.$initiator !== this) {
        this.parent.ensurePromise();
      }
    }
  }

  resolve() {
    if (this.$promise !== void 0) {
      const resolve = this.$resolve;
      this.$resolve = this.$reject = this.$promise = void 0;
      resolve();
    }
  }

  reject(err) {
    if (this.$promise !== void 0) {
      const reject = this.$reject;
      this.$resolve = this.$reject = this.$promise = void 0;
      reject(err);
    }

    if (this.$initiator !== this) {
      this.parent.reject(err);
    }
  }

  enterActivating() {
    ++this.activatingStack;

    if (this.$initiator !== this) {
      this.parent.enterActivating();
    }
  }

  leaveActivating() {
    if (--this.activatingStack === 0) {
      if (this.hooks.hasAttached) {
        if (this.debug) {
          this.logger.trace(`attached()`);
        }

        const ret = this.viewModel.attached(this.$initiator, this.$flags);

        if (ret instanceof Promise) {
          this.ensurePromise();
          ret.then(() => {
            this.state = 2
            /* activated */
            ; // Resolve this.$promise, signaling that activation is done (path 1 of 2)

            this.resolve();

            if (this.$initiator !== this) {
              this.parent.leaveActivating();
            }
          }).catch(err => {
            this.reject(err);
          });
          return;
        }
      }

      this.state = 2
      /* activated */
      ; // Resolve this.$promise (if present), signaling that activation is done (path 2 of 2)

      this.resolve();
    }

    if (this.$initiator !== this) {
      this.parent.leaveActivating();
    }
  }

  enterDetaching() {
    ++this.detachingStack;
  }

  leaveDetaching() {
    if (--this.detachingStack === 0) {
      // Note: this controller is the initiator (detach is only ever called on the initiator)
      if (this.debug) {
        this.logger.trace(`detach()`);
      }

      this.enterUnbinding();
      this.removeNodes();
      let cur = this.$initiator.head;

      while (cur !== null) {
        if (cur !== this) {
          if (cur.debug) {
            cur.logger.trace(`detach()`);
          }

          cur.removeNodes();
        }

        if (cur.hooks.hasUnbinding) {
          if (cur.debug) {
            cur.logger.trace('unbinding()');
          }

          const ret = cur.viewModel.unbinding(cur.$initiator, cur.parent, cur.$flags);

          if (ret instanceof Promise) {
            this.ensurePromise();
            this.enterUnbinding();
            ret.then(() => {
              this.leaveUnbinding();
            }).catch(err => {
              this.reject(err);
            });
          }
        }

        cur = cur.next;
      }

      this.leaveUnbinding();
    }
  }

  enterUnbinding() {
    ++this.unbindingStack;
  }

  leaveUnbinding() {
    if (--this.unbindingStack === 0) {
      if (this.debug) {
        this.logger.trace(`unbind()`);
      }

      let cur = this.$initiator.head;
      let next = null;

      while (cur !== null) {
        if (cur !== this) {
          cur.unbind();
        }

        next = cur.next;
        cur.next = null;
        cur = next;
      }

      this.head = this.tail = null;
      this.unbind();
    }
  }

  addBinding(binding) {
    if (this.bindings === null) {
      this.bindings = [binding];
    } else {
      this.bindings[this.bindings.length] = binding;
    }
  }

  addController(controller) {
    if (this.children === null) {
      this.children = [controller];
    } else {
      this.children[this.children.length] = controller;
    }
  }

  is(name) {
    switch (this.vmKind) {
      case 1
      /* customAttribute */
      :
        {
          const def = _customAttribute.CustomAttribute.getDefinition(this.viewModel.constructor);

          return def.name === name;
        }

      case 0
      /* customElement */
      :
        {
          const def = _customElement.CustomElement.getDefinition(this.viewModel.constructor);

          return def.name === name;
        }

      case 2
      /* synthetic */
      :
        return this.viewFactory.name === name;
    }
  }

  lockScope(scope) {
    this.scope = scope;
    this.hasLockedScope = true;
  }

  setHost(host) {
    if (this.vmKind === 0
    /* customElement */
    ) {
        _kernel.Metadata.define(_customElement.CustomElement.name, this, host);
      }

    this.host = host;
    this.mountTarget = 1
    /* host */
    ;
    return this;
  }

  setShadowRoot(shadowRoot) {
    if (this.vmKind === 0
    /* customElement */
    ) {
        _kernel.Metadata.define(_customElement.CustomElement.name, this, shadowRoot);
      }

    this.shadowRoot = shadowRoot;
    this.mountTarget = 2
    /* shadowRoot */
    ;
    return this;
  }

  setLocation(location) {
    if (this.vmKind === 0
    /* customElement */
    ) {
        _kernel.Metadata.define(_customElement.CustomElement.name, this, location);
      }

    this.location = location;
    this.mountTarget = 3
    /* location */
    ;
    return this;
  }

  release() {
    this.state |= 16
    /* released */
    ;
  }

  dispose() {
    if (this.debug) {
      this.logger.trace(`dispose()`);
    }

    if ((this.state & 32
    /* disposed */
    ) === 32
    /* disposed */
    ) {
        return;
      }

    this.state |= 32
    /* disposed */
    ;

    if (this.hooks.hasDispose) {
      this.viewModel.dispose();
    }

    if (this.children !== null) {
      this.children.forEach(callDispose);
      this.children = null;
    }

    this.hostController = null;
    this.scope = null;
    this.nodes = null;
    this.context = null;
    this.location = null;
    this.viewFactory = null;

    if (this.viewModel !== null) {
      controllerLookup.delete(this.viewModel);
      this.viewModel = null;
    }

    this.viewModel = null;
    this.host = null;
    this.shadowRoot = null;
    this.root = null;
  }

  accept(visitor) {
    if (visitor(this) === true) {
      return true;
    }

    if (this.hooks.hasAccept && this.viewModel.accept(visitor) === true) {
      return true;
    }

    if (this.children !== null) {
      const {
        children
      } = this;

      for (let i = 0, ii = children.length; i < ii; ++i) {
        if (children[i].accept(visitor) === true) {
          return true;
        }
      }
    }
  }

  getTargetAccessor(propertyName) {
    const {
      bindings
    } = this;

    if (bindings !== null) {
      const binding = bindings.find(b => b.targetProperty === propertyName);

      if (binding !== void 0) {
        return binding.targetObserver;
      }
    }

    return void 0;
  }

}

exports.Controller = Controller;

function getLookup(instance) {
  let lookup = instance.$observers;

  if (lookup === void 0) {
    Reflect.defineProperty(instance, '$observers', {
      enumerable: false,
      value: lookup = {}
    });
  }

  return lookup;
}

function createObservers(controller, definition, // deepscan-disable-next-line
_flags, instance) {
  const bindables = definition.bindables;
  const observableNames = Object.getOwnPropertyNames(bindables);
  const length = observableNames.length;

  if (length > 0) {
    let name;
    let bindable;
    const observers = getLookup(instance);

    for (let i = 0; i < length; ++i) {
      name = observableNames[i];

      if (observers[name] === void 0) {
        bindable = bindables[name];
        observers[name] = new _bindableObserver.BindableObserver(instance, name, bindable.callback, bindable.set, controller);
      }
    }
  }
}

function createChildrenObservers(controller, definition, // deepscan-disable-next-line
_flags, instance) {
  const childrenObservers = definition.childrenObservers;
  const childObserverNames = Object.getOwnPropertyNames(childrenObservers);
  const length = childObserverNames.length;

  if (length > 0) {
    const observers = getLookup(instance);
    let name;

    for (let i = 0; i < length; ++i) {
      name = childObserverNames[i];

      if (observers[name] == void 0) {
        const childrenDescription = childrenObservers[name];
        observers[name] = new _children.ChildrenObserver(controller, instance, name, childrenDescription.callback, childrenDescription.query, childrenDescription.filter, childrenDescription.map, childrenDescription.options);
      }
    }
  }
}

const AccessScopeAst = {
  map: new Map(),

  for(key) {
    let ast = AccessScopeAst.map.get(key);

    if (ast == null) {
      ast = new _runtime.AccessScopeExpression(key, 0);
      AccessScopeAst.map.set(key, ast);
    }

    return ast;
  }

};

function createWatchers(controller, context, definition, instance) {
  const observerLocator = context.get(_runtime.IObserverLocator);
  const expressionParser = context.get(_runtime.IExpressionParser);
  const watches = definition.watches;
  let expression;
  let callback;

  for (let i = 0, ii = watches.length; ii > i; ++i) {
    ({
      expression,
      callback
    } = watches[i]);
    callback = typeof callback === 'function' ? callback : Reflect.get(instance, callback);

    if (typeof callback !== 'function') {
      throw new Error(`Invalid callback for @watch decorator: ${String(callback)}`);
    }

    if (typeof expression === 'function') {
      controller.addBinding(new _watchers.ComputedWatcher(instance, observerLocator, expression, callback, // there should be a flag to purposely disable proxy
      // AOT: not true for IE11
      true));
    } else {
      const ast = typeof expression === 'string' ? expressionParser.parse(expression, 53
      /* BindCommand */
      ) : AccessScopeAst.for(expression);
      controller.addBinding(new _watchers.ExpressionWatcher(controller.scope, context, observerLocator, ast, callback));
    }
  }
}

function isCustomElementController(value) {
  return value instanceof Controller && value.vmKind === 0
  /* customElement */
  ;
}

function isCustomElementViewModel(value) {
  return (0, _kernel.isObject)(value) && _customElement.CustomElement.isType(value.constructor);
}

class HooksDefinition {
  constructor(target) {
    this.hasDefine = 'define' in target;
    this.hasHydrating = 'hydrating' in target;
    this.hasHydrated = 'hydrated' in target;
    this.hasCreated = 'created' in target;
    this.hasBinding = 'binding' in target;
    this.hasBound = 'bound' in target;
    this.hasAttaching = 'attaching' in target;
    this.hasAttached = 'attached' in target;
    this.hasDetaching = 'detaching' in target;
    this.hasUnbinding = 'unbinding' in target;
    this.hasDispose = 'dispose' in target;
    this.hasAccept = 'accept' in target;
  }

}

exports.HooksDefinition = HooksDefinition;
HooksDefinition.none = new HooksDefinition({});
const defaultShadowOptions = {
  mode: 'open'
};
var ViewModelKind;
exports.ViewModelKind = ViewModelKind;

(function (ViewModelKind) {
  ViewModelKind[ViewModelKind["customElement"] = 0] = "customElement";
  ViewModelKind[ViewModelKind["customAttribute"] = 1] = "customAttribute";
  ViewModelKind[ViewModelKind["synthetic"] = 2] = "synthetic";
})(ViewModelKind || (exports.ViewModelKind = ViewModelKind = {}));

var State;
exports.State = State;

(function (State) {
  State[State["none"] = 0] = "none";
  State[State["activating"] = 1] = "activating";
  State[State["activated"] = 2] = "activated";
  State[State["deactivating"] = 4] = "deactivating";
  State[State["deactivated"] = 8] = "deactivated";
  State[State["released"] = 16] = "released";
  State[State["disposed"] = 32] = "disposed";
})(State || (exports.State = State = {}));

function stringifyState(state) {
  const names = [];

  if ((state & 1
  /* activating */
  ) === 1
  /* activating */
  ) {
      names.push('activating');
    }

  if ((state & 2
  /* activated */
  ) === 2
  /* activated */
  ) {
      names.push('activated');
    }

  if ((state & 4
  /* deactivating */
  ) === 4
  /* deactivating */
  ) {
      names.push('deactivating');
    }

  if ((state & 8
  /* deactivated */
  ) === 8
  /* deactivated */
  ) {
      names.push('deactivated');
    }

  if ((state & 16
  /* released */
  ) === 16
  /* released */
  ) {
      names.push('released');
    }

  if ((state & 32
  /* disposed */
  ) === 32
  /* disposed */
  ) {
      names.push('disposed');
    }

  return names.length === 0 ? 'none' : names.join('|');
}

const IController = _kernel.DI.createInterface('IController');

exports.IController = IController;
});

;define.alias('@aurelia/runtime-html/templating/controller.js','@aurelia/runtime-html/dist/esm/templating/controller.js');
define('@aurelia/runtime-html/dist/esm/templating/render-context.js',['require','exports','module','@aurelia/kernel','../dom.js','../renderer.js','../resources/custom-element.js','./view.js','../resources/custom-elements/au-slot.js','../platform.js','./controller.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.isRenderContext = isRenderContext;
exports.getRenderContext = getRenderContext;
exports.ViewFactoryProvider = exports.RenderContext = void 0;

var _kernel = require("@aurelia/kernel");

var _dom = require("../dom.js");

var _renderer = require("../renderer.js");

var _customElement = require("../resources/custom-element.js");

var _view = require("./view.js");

var _auSlot = require("../resources/custom-elements/au-slot.js");

var _platform = require("../platform.js");

var _controller = require("./controller.js");

const definitionContainerLookup = new WeakMap();
const definitionContainerProjectionsLookup = new WeakMap();
const fragmentCache = new WeakMap();

function isRenderContext(value) {
  return value instanceof RenderContext;
}

function getRenderContext(partialDefinition, parentContainer, projections) {
  const definition = _customElement.CustomElementDefinition.getOrCreate(partialDefinition); // injectable completely prevents caching, ensuring that each instance gets a new context context


  if (definition.injectable !== null) {
    return new RenderContext(definition, parentContainer);
  }

  if (projections == null) {
    let containerLookup = definitionContainerLookup.get(definition);

    if (containerLookup === void 0) {
      definitionContainerLookup.set(definition, containerLookup = new WeakMap());
    }

    let context = containerLookup.get(parentContainer);

    if (context === void 0) {
      containerLookup.set(parentContainer, context = new RenderContext(definition, parentContainer));
    }

    return context;
  }

  let containerProjectionsLookup = definitionContainerProjectionsLookup.get(definition);

  if (containerProjectionsLookup === void 0) {
    definitionContainerProjectionsLookup.set(definition, containerProjectionsLookup = new WeakMap());
  }

  let projectionsLookup = containerProjectionsLookup.get(parentContainer);

  if (projectionsLookup === void 0) {
    containerProjectionsLookup.set(parentContainer, projectionsLookup = new WeakMap());
  }

  let context = projectionsLookup.get(projections);

  if (context === void 0) {
    projectionsLookup.set(projections, context = new RenderContext(definition, parentContainer));
  }

  return context;
}

const emptyNodeCache = new WeakMap();

class RenderContext {
  constructor(definition, parentContainer) {
    this.definition = definition;
    this.parentContainer = parentContainer;
    this.viewModelProvider = void 0;
    this.fragment = null;
    this.factory = void 0;
    this.isCompiled = false;
    this.renderers = Object.create(null);
    this.compiledDefinition = void 0;
    const container = this.container = parentContainer.createChild(); // TODO(fkleuver): get contextual + root renderers

    const renderers = container.getAll(_renderer.IRenderer);

    for (let i = 0; i < renderers.length; ++i) {
      const renderer = renderers[i];
      this.renderers[renderer.instructionType] = renderer;
    }

    this.projectionProvider = container.get(_auSlot.IProjectionProvider);
    const p = this.platform = container.get(_platform.IPlatform);
    container.registerResolver(_view.IViewFactory, this.factoryProvider = new ViewFactoryProvider(), true);
    container.registerResolver(_controller.IController, this.parentControllerProvider = new _kernel.InstanceProvider('IController'), true);
    container.registerResolver(_renderer.IInstruction, this.instructionProvider = new _kernel.InstanceProvider('IInstruction'), true);
    container.registerResolver(_dom.IRenderLocation, this.renderLocationProvider = new _kernel.InstanceProvider('IRenderLocation'), true);
    const ep = this.elementProvider = new _kernel.InstanceProvider('ElementResolver');
    container.registerResolver(_dom.INode, ep);
    container.registerResolver(p.Node, ep);
    container.registerResolver(p.Element, ep);
    container.registerResolver(p.HTMLElement, ep);
    container.register(...definition.dependencies);
  } // #region IServiceLocator api


  has(key, searchAncestors) {
    return this.container.has(key, searchAncestors);
  }

  get(key) {
    return this.container.get(key);
  }

  getAll(key) {
    return this.container.getAll(key);
  } // #endregion
  // #region IContainer api


  register(...params) {
    return this.container.register(...params);
  }

  registerResolver(key, resolver) {
    return this.container.registerResolver(key, resolver);
  } // public deregisterResolverFor<K extends Key, T = K>(key: K): void {
  //   this.container.deregisterResolverFor(key);
  // }


  registerTransformer(key, transformer) {
    return this.container.registerTransformer(key, transformer);
  }

  getResolver(key, autoRegister) {
    return this.container.getResolver(key, autoRegister);
  }

  getFactory(key) {
    return this.container.getFactory(key);
  }

  registerFactory(key, factory) {
    this.container.registerFactory(key, factory);
  }

  createChild() {
    return this.container.createChild();
  }

  find(kind, name) {
    return this.container.find(kind, name);
  }

  create(kind, name) {
    return this.container.create(kind, name);
  }

  disposeResolvers() {
    this.container.disposeResolvers();
  } // #endregion
  // #region IRenderContext api


  compile(targetedProjections) {
    let compiledDefinition;

    if (this.isCompiled) {
      return this;
    }

    this.isCompiled = true;
    const definition = this.definition;

    if (definition.needsCompile) {
      const container = this.container;
      const compiler = container.get(_renderer.ITemplateCompiler);
      compiledDefinition = this.compiledDefinition = compiler.compile(definition, container, targetedProjections);
    } else {
      compiledDefinition = this.compiledDefinition = definition;
    } // Support Recursive Components by adding self to own context


    compiledDefinition.register(this);

    if (fragmentCache.has(compiledDefinition)) {
      this.fragment = fragmentCache.get(compiledDefinition);
    } else {
      const doc = this.platform.document;
      const template = compiledDefinition.template;

      if (template === null || this.definition.enhance === true) {
        this.fragment = null;
      } else if (template instanceof this.platform.Node) {
        if (template.nodeName === 'TEMPLATE') {
          this.fragment = doc.adoptNode(template.content);
        } else {
          (this.fragment = doc.adoptNode(doc.createDocumentFragment())).appendChild(template);
        }
      } else {
        const tpl = doc.createElement('template');
        doc.adoptNode(tpl.content);

        if (typeof template === 'string') {
          tpl.innerHTML = template;
        }

        this.fragment = tpl.content;
      }

      fragmentCache.set(compiledDefinition, this.fragment);
    }

    return this;
  }

  getViewFactory(name, contentType, projectionScope) {
    let factory = this.factory;

    if (factory === void 0) {
      if (name === void 0) {
        name = this.definition.name;
      }

      factory = this.factory = new _view.ViewFactory(name, this, contentType, projectionScope);
    }

    return factory;
  }

  beginChildComponentOperation(instance) {
    const definition = this.definition;

    if (definition.injectable !== null) {
      if (this.viewModelProvider === void 0) {
        this.container.registerResolver(definition.injectable, this.viewModelProvider = new _kernel.InstanceProvider('definition.injectable'));
      }

      this.viewModelProvider.prepare(instance);
    }

    return this;
  } // #endregion
  // #region ICompiledRenderContext api


  createNodes() {
    if (this.compiledDefinition.enhance === true) {
      return new _dom.FragmentNodeSequence(this.platform, this.compiledDefinition.template);
    }

    if (this.fragment === null) {
      let emptyNodes = emptyNodeCache.get(this.platform);

      if (emptyNodes === void 0) {
        emptyNodeCache.set(this.platform, emptyNodes = new _dom.FragmentNodeSequence(this.platform, this.platform.document.createDocumentFragment()));
      }

      return emptyNodes;
    }

    return new _dom.FragmentNodeSequence(this.platform, this.fragment.cloneNode(true));
  } // TODO: split up into 2 methods? getComponentFactory + getSyntheticFactory or something


  getComponentFactory(parentController, host, instruction, viewFactory, location) {
    if (parentController !== void 0) {
      this.parentControllerProvider.prepare(parentController);
    }

    if (host !== void 0) {
      // TODO: fix provider input type, Key is probably not a good constraint
      this.elementProvider.prepare(host);
    }

    if (instruction !== void 0) {
      this.instructionProvider.prepare(instruction);
    }

    if (location !== void 0) {
      this.renderLocationProvider.prepare(location);
    }

    if (viewFactory !== void 0) {
      this.factoryProvider.prepare(viewFactory);
    }

    return this;
  } // #endregion
  // #region IComponentFactory api


  createComponent(resourceKey) {
    return this.container.get(resourceKey);
  }

  render(flags, controller, targets, definition, host) {
    if (targets.length !== definition.instructions.length) {
      throw new Error(`The compiled template is not aligned with the render instructions. There are ${targets.length} targets and ${definition.instructions.length} instructions.`);
    }

    for (let i = 0; i < targets.length; ++i) {
      this.renderChildren(
      /* flags        */
      flags,
      /* instructions */
      definition.instructions[i],
      /* controller   */
      controller,
      /* target       */
      targets[i]);
    }

    if (host !== void 0 && host !== null) {
      this.renderChildren(
      /* flags        */
      flags,
      /* instructions */
      definition.surrogates,
      /* controller   */
      controller,
      /* target       */
      host);
    }
  }

  renderChildren(flags, instructions, controller, target) {
    for (let i = 0; i < instructions.length; ++i) {
      const current = instructions[i];
      this.renderers[current.type].render(flags, this, controller, target, current);
    }
  }

  dispose() {
    this.elementProvider.dispose();
  } // #endregion
  // #region IProjectionProvider api


  registerProjections(projections, scope) {
    this.projectionProvider.registerProjections(projections, scope);
  }

  getProjectionFor(instruction) {
    return this.projectionProvider.getProjectionFor(instruction);
  }

}
/** @internal */


exports.RenderContext = RenderContext;

class ViewFactoryProvider {
  constructor() {
    this.factory = null;
  }

  prepare(factory) {
    this.factory = factory;
  }

  get $isResolver() {
    return true;
  }

  resolve(_handler, _requestor) {
    const factory = this.factory;

    if (factory === null) {
      throw new Error('Cannot resolve ViewFactory before the provider was prepared.');
    }

    if (typeof factory.name !== 'string' || factory.name.length === 0) {
      throw new Error('Cannot resolve ViewFactory without a (valid) name.');
    }

    return factory;
  }

  dispose() {
    this.factory = null;
  }

}

exports.ViewFactoryProvider = ViewFactoryProvider;
});

;define.alias('@aurelia/runtime-html/templating/render-context.js','@aurelia/runtime-html/dist/esm/templating/render-context.js');
define('@aurelia/runtime-html/dist/esm/templating/styles.js',['require','exports','module','@aurelia/kernel','../app-task.js','../dom.js','../observation/class-attribute-accessor.js','../platform.js','../resources/custom-attribute.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.cssModules = cssModules;
exports.shadowCSS = shadowCSS;
exports.StyleConfiguration = exports.StyleElementStyles = exports.AdoptedStyleSheetsStyles = exports.IShadowDOMGlobalStyles = exports.IShadowDOMStyles = exports.ShadowDOMRegistry = exports.IShadowDOMStyleFactory = exports.CSSModulesProcessorRegistry = void 0;

var _kernel = require("@aurelia/kernel");

var _appTask = require("../app-task.js");

var _dom = require("../dom.js");

var _classAttributeAccessor = require("../observation/class-attribute-accessor.js");

var _platform = require("../platform.js");

var _customAttribute = require("../resources/custom-attribute.js");

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

function cssModules(...modules) {
  return new CSSModulesProcessorRegistry(modules);
}

class CSSModulesProcessorRegistry {
  constructor(modules) {
    this.modules = modules;
  }

  register(container) {
    var _a;

    const classLookup = Object.assign({}, ...this.modules);

    const ClassCustomAttribute = _customAttribute.CustomAttribute.define({
      name: 'class',
      bindables: ['value']
    }, (_a = class CustomAttributeClass {
      constructor(element) {
        this.element = element;
      }

      binding() {
        this.valueChanged();
      }

      valueChanged() {
        if (!this.value) {
          this.element.className = '';
          return;
        }

        this.element.className = (0, _classAttributeAccessor.getClassesToAdd)(this.value).map(x => classLookup[x] || x).join(' ');
      }

    }, _a.inject = [_dom.INode], _a));

    container.register(ClassCustomAttribute);
  }

}

exports.CSSModulesProcessorRegistry = CSSModulesProcessorRegistry;

function shadowCSS(...css) {
  return new ShadowDOMRegistry(css);
}

const IShadowDOMStyleFactory = _kernel.DI.createInterface('IShadowDOMStyleFactory', x => x.cachedCallback(handler => {
  if (AdoptedStyleSheetsStyles.supported(handler.get(_platform.IPlatform))) {
    return handler.get(AdoptedStyleSheetsStylesFactory);
  }

  return handler.get(StyleElementStylesFactory);
}));

exports.IShadowDOMStyleFactory = IShadowDOMStyleFactory;

class ShadowDOMRegistry {
  constructor(css) {
    this.css = css;
  }

  register(container) {
    const sharedStyles = container.get(IShadowDOMGlobalStyles);
    const factory = container.get(IShadowDOMStyleFactory);
    container.register(_kernel.Registration.instance(IShadowDOMStyles, factory.createStyles(this.css, sharedStyles)));
  }

}

exports.ShadowDOMRegistry = ShadowDOMRegistry;
let AdoptedStyleSheetsStylesFactory = class AdoptedStyleSheetsStylesFactory {
  constructor(p) {
    this.p = p;
    this.cache = new Map();
  }

  createStyles(localStyles, sharedStyles) {
    return new AdoptedStyleSheetsStyles(this.p, localStyles, this.cache, sharedStyles);
  }

};
AdoptedStyleSheetsStylesFactory = __decorate([__param(0, _platform.IPlatform)], AdoptedStyleSheetsStylesFactory);
let StyleElementStylesFactory = class StyleElementStylesFactory {
  constructor(p) {
    this.p = p;
  }

  createStyles(localStyles, sharedStyles) {
    return new StyleElementStyles(this.p, localStyles, sharedStyles);
  }

};
StyleElementStylesFactory = __decorate([__param(0, _platform.IPlatform)], StyleElementStylesFactory);

const IShadowDOMStyles = _kernel.DI.createInterface('IShadowDOMStyles');

exports.IShadowDOMStyles = IShadowDOMStyles;

const IShadowDOMGlobalStyles = _kernel.DI.createInterface('IShadowDOMGlobalStyles', x => x.instance({
  applyTo: _kernel.noop
}));

exports.IShadowDOMGlobalStyles = IShadowDOMGlobalStyles;

class AdoptedStyleSheetsStyles {
  constructor(p, localStyles, styleSheetCache, sharedStyles = null) {
    this.sharedStyles = sharedStyles;
    this.styleSheets = localStyles.map(x => {
      let sheet;

      if (x instanceof p.CSSStyleSheet) {
        sheet = x;
      } else {
        sheet = styleSheetCache.get(x);

        if (sheet === void 0) {
          sheet = new p.CSSStyleSheet();
          sheet.replaceSync(x);
          styleSheetCache.set(x, sheet);
        }
      }

      return sheet;
    });
  }

  static supported(p) {
    return 'adoptedStyleSheets' in p.ShadowRoot.prototype;
  }

  applyTo(shadowRoot) {
    if (this.sharedStyles !== null) {
      this.sharedStyles.applyTo(shadowRoot);
    } // https://wicg.github.io/construct-stylesheets/
    // https://developers.google.com/web/updates/2019/02/constructable-stylesheets


    shadowRoot.adoptedStyleSheets = [...shadowRoot.adoptedStyleSheets, ...this.styleSheets];
  }

}

exports.AdoptedStyleSheetsStyles = AdoptedStyleSheetsStyles;

class StyleElementStyles {
  constructor(p, localStyles, sharedStyles = null) {
    this.p = p;
    this.localStyles = localStyles;
    this.sharedStyles = sharedStyles;
  }

  applyTo(shadowRoot) {
    const styles = this.localStyles;
    const p = this.p;

    for (let i = styles.length - 1; i > -1; --i) {
      const element = p.document.createElement('style');
      element.innerHTML = styles[i];
      shadowRoot.prepend(element);
    }

    if (this.sharedStyles !== null) {
      this.sharedStyles.applyTo(shadowRoot);
    }
  }

}

exports.StyleElementStyles = StyleElementStyles;
const StyleConfiguration = {
  shadowDOM(config) {
    return _appTask.AppTask.with(_kernel.IContainer).beforeCreate().call(container => {
      if (config.sharedStyles != null) {
        const factory = container.get(IShadowDOMStyleFactory);
        container.register(_kernel.Registration.instance(IShadowDOMGlobalStyles, factory.createStyles(config.sharedStyles, null)));
      }
    });
  }

};
exports.StyleConfiguration = StyleConfiguration;
});

;define.alias('@aurelia/runtime-html/templating/styles.js','@aurelia/runtime-html/dist/esm/templating/styles.js');
define('@aurelia/runtime-html/dist/esm/templating/view.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime','../resources/custom-element.js','./controller.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.view = view;
exports.ViewLocator = exports.IViewLocator = exports.Views = exports.ViewFactory = exports.IViewFactory = void 0;

var _kernel = require("@aurelia/kernel");

var _runtime = require("@aurelia/runtime");

var _customElement = require("../resources/custom-element.js");

var _controller = require("./controller.js");

const IViewFactory = _kernel.DI.createInterface('IViewFactory');

exports.IViewFactory = IViewFactory;

class ViewFactory {
  constructor(name, context, contentType, projectionScope = null) {
    this.name = name;
    this.context = context;
    this.contentType = contentType;
    this.projectionScope = projectionScope;
    this.isCaching = false;
    this.cache = null;
    this.cacheSize = -1;
  }

  setCacheSize(size, doNotOverrideIfAlreadySet) {
    if (size) {
      if (size === '*') {
        size = ViewFactory.maxCacheSize;
      } else if (typeof size === 'string') {
        size = parseInt(size, 10);
      }

      if (this.cacheSize === -1 || !doNotOverrideIfAlreadySet) {
        this.cacheSize = size;
      }
    }

    if (this.cacheSize > 0) {
      this.cache = [];
    } else {
      this.cache = null;
    }

    this.isCaching = this.cacheSize > 0;
  }

  canReturnToCache(controller) {
    return this.cache != null && this.cache.length < this.cacheSize;
  }

  tryReturnToCache(controller) {
    if (this.canReturnToCache(controller)) {
      this.cache.push(controller);
      return true;
    }

    return false;
  }

  create(flags, parentController) {
    const cache = this.cache;
    let controller;

    if (cache != null && cache.length > 0) {
      controller = cache.pop();
      return controller;
    }

    controller = _controller.Controller.forSyntheticView(null, this.context, this, flags, parentController);
    return controller;
  }

}

exports.ViewFactory = ViewFactory;
ViewFactory.maxCacheSize = 0xFFFF;
const seenViews = new WeakSet();

function notYetSeen($view) {
  return !seenViews.has($view);
}

function toCustomElementDefinition($view) {
  seenViews.add($view);
  return _customElement.CustomElementDefinition.create($view);
}

const Views = {
  name: _kernel.Protocol.resource.keyFor('views'),

  has(value) {
    return typeof value === 'function' && (_kernel.Metadata.hasOwn(Views.name, value) || '$views' in value);
  },

  get(value) {
    if (typeof value === 'function' && '$views' in value) {
      // TODO: a `get` operation with side effects is not a good thing. Should refactor this to a proper resource kind.
      const $views = value.$views;
      const definitions = $views.filter(notYetSeen).map(toCustomElementDefinition);

      for (const def of definitions) {
        Views.add(value, def);
      }
    }

    let views = _kernel.Metadata.getOwn(Views.name, value);

    if (views === void 0) {
      _kernel.Metadata.define(Views.name, views = [], value);
    }

    return views;
  },

  add(Type, partialDefinition) {
    const definition = _customElement.CustomElementDefinition.create(partialDefinition);

    let views = _kernel.Metadata.getOwn(Views.name, Type);

    if (views === void 0) {
      _kernel.Metadata.define(Views.name, views = [definition], Type);
    } else {
      views.push(definition);
    }

    return views;
  }

};
exports.Views = Views;

function view(v) {
  return function (target) {
    Views.add(target, v);
  };
}

const IViewLocator = _kernel.DI.createInterface('IViewLocator', x => x.singleton(ViewLocator));

exports.IViewLocator = IViewLocator;

class ViewLocator {
  constructor() {
    this.modelInstanceToBoundComponent = new WeakMap();
    this.modelTypeToUnboundComponent = new Map();
  }

  getViewComponentForObject(object, viewNameOrSelector) {
    if (object) {
      const availableViews = Views.has(object.constructor) ? Views.get(object.constructor) : [];
      const resolvedViewName = typeof viewNameOrSelector === 'function' ? viewNameOrSelector(object, availableViews) : this.getViewName(availableViews, viewNameOrSelector);
      return this.getOrCreateBoundComponent(object, availableViews, resolvedViewName);
    }

    return null;
  }

  getOrCreateBoundComponent(object, availableViews, resolvedViewName) {
    let lookup = this.modelInstanceToBoundComponent.get(object);
    let BoundComponent;

    if (lookup === void 0) {
      lookup = {};
      this.modelInstanceToBoundComponent.set(object, lookup);
    } else {
      BoundComponent = lookup[resolvedViewName];
    }

    if (BoundComponent === void 0) {
      const UnboundComponent = this.getOrCreateUnboundComponent(object, availableViews, resolvedViewName);
      BoundComponent = _customElement.CustomElement.define(_customElement.CustomElement.getDefinition(UnboundComponent), class extends UnboundComponent {
        constructor() {
          super(object);
        }

      });
      lookup[resolvedViewName] = BoundComponent;
    }

    return BoundComponent;
  }

  getOrCreateUnboundComponent(object, availableViews, resolvedViewName) {
    let lookup = this.modelTypeToUnboundComponent.get(object.constructor);
    let UnboundComponent;

    if (lookup === void 0) {
      lookup = {};
      this.modelTypeToUnboundComponent.set(object.constructor, lookup);
    } else {
      UnboundComponent = lookup[resolvedViewName];
    }

    if (UnboundComponent === void 0) {
      UnboundComponent = _customElement.CustomElement.define(this.getView(availableViews, resolvedViewName), class {
        constructor(viewModel) {
          this.viewModel = viewModel;
        }

        define(controller, parentContainer, definition) {
          const vm = this.viewModel;
          controller.scope = _runtime.Scope.fromParent(controller.scope, vm);

          if (vm.define !== void 0) {
            return vm.define(controller, parentContainer, definition);
          }
        }

      });
      const proto = UnboundComponent.prototype;

      if ('hydrating' in object) {
        proto.hydrating = function hydrating(controller) {
          this.viewModel.hydrating(controller);
        };
      }

      if ('hydrated' in object) {
        proto.hydrated = function hydrated(controller) {
          this.viewModel.hydrated(controller);
        };
      }

      if ('created' in object) {
        proto.created = function created(controller) {
          this.viewModel.created(controller);
        };
      }

      if ('binding' in object) {
        proto.binding = function binding(initiator, parent, flags) {
          return this.viewModel.binding(initiator, parent, flags);
        };
      }

      if ('bound' in object) {
        proto.bound = function bound(initiator, parent, flags) {
          return this.viewModel.bound(initiator, parent, flags);
        };
      }

      if ('attaching' in object) {
        proto.attaching = function attaching(initiator, parent, flags) {
          return this.viewModel.attaching(initiator, parent, flags);
        };
      }

      if ('attached' in object) {
        proto.attached = function attached(initiator, flags) {
          return this.viewModel.attached(initiator, flags);
        };
      }

      if ('detaching' in object) {
        proto.detaching = function detaching(initiator, parent, flags) {
          return this.viewModel.detaching(initiator, parent, flags);
        };
      }

      if ('unbinding' in object) {
        proto.unbinding = function unbinding(initiator, parent, flags) {
          return this.viewModel.unbinding(initiator, parent, flags);
        };
      }

      if ('dispose' in object) {
        proto.dispose = function dispose() {
          this.viewModel.dispose();
        };
      }

      lookup[resolvedViewName] = UnboundComponent;
    }

    return UnboundComponent;
  }

  getViewName(views, requestedName) {
    if (requestedName) {
      return requestedName;
    }

    if (views.length === 1) {
      return views[0].name;
    }

    return 'default-view';
  }

  getView(views, name) {
    const v = views.find(x => x.name === name);

    if (v === void 0) {
      throw new Error(`Could not find view: ${name}`);
    }

    return v;
  }

}

exports.ViewLocator = ViewLocator;
});

;define.alias('@aurelia/runtime-html/templating/view.js','@aurelia/runtime-html/dist/esm/templating/view.js');
define('@aurelia/runtime-html/dist/esm/templating/watchers.js',['require','exports','module','@aurelia/runtime'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.ExpressionWatcher = exports.ComputedWatcher = void 0;

var _runtime = require("@aurelia/runtime");

const {
  enter,
  exit
} = _runtime.ConnectableSwitcher;
const {
  wrap,
  unwrap
} = _runtime.ProxyObservable;

class ComputedWatcher {
  constructor(obj, observerLocator, get, cb, useProxy) {
    this.obj = obj;
    this.observerLocator = observerLocator;
    this.get = get;
    this.cb = cb;
    this.useProxy = useProxy;
    this.interceptor = this;
    this.value = void 0;
    this.isBound = false; // todo: maybe use a counter allow recursive call to a certain level

    this.running = false;

    _runtime.connectable.assignIdTo(this);
  }

  handleChange() {
    this.run();
  }

  handleCollectionChange() {
    this.run();
  }

  $bind() {
    if (this.isBound) {
      return;
    }

    this.isBound = true;
    this.compute();
  }

  $unbind() {
    if (!this.isBound) {
      return;
    }

    this.isBound = false;
    this.obs.clear(true);
  }

  run() {
    if (!this.isBound || this.running) {
      return;
    }

    const obj = this.obj;
    const oldValue = this.value;
    const newValue = this.compute();

    if (!Object.is(newValue, oldValue)) {
      // should optionally queue
      this.cb.call(obj, newValue, oldValue, obj);
    }
  }

  compute() {
    this.running = true;
    this.obs.version++;

    try {
      enter(this);
      return this.value = unwrap(this.get.call(void 0, this.useProxy ? wrap(this.obj) : this.obj, this));
    } finally {
      this.obs.clear(false);
      this.running = false;
      exit(this);
    }
  }

}

exports.ComputedWatcher = ComputedWatcher;

class ExpressionWatcher {
  constructor(scope, locator, observerLocator, expression, callback) {
    this.scope = scope;
    this.locator = locator;
    this.observerLocator = observerLocator;
    this.expression = expression;
    this.callback = callback;
    this.interceptor = this;
    this.isBound = false;
    this.obj = scope.bindingContext;

    _runtime.connectable.assignIdTo(this);
  }

  handleChange(value) {
    const expr = this.expression;
    const obj = this.obj;
    const oldValue = this.value;
    const canOptimize = expr.$kind === 10082
    /* AccessScope */
    && this.obs.count === 1;

    if (!canOptimize) {
      this.obs.version++;
      value = expr.evaluate(0, this.scope, null, this.locator, this);
      this.obs.clear(false);
    }

    if (!Object.is(value, oldValue)) {
      this.value = value; // should optionally queue for batch synchronous

      this.callback.call(obj, value, oldValue, obj);
    }
  }

  $bind() {
    if (this.isBound) {
      return;
    }

    this.isBound = true;
    this.obs.version++;
    this.value = this.expression.evaluate(0
    /* none */
    , this.scope, null, this.locator, this);
    this.obs.clear(false);
  }

  $unbind() {
    if (!this.isBound) {
      return;
    }

    this.isBound = false;
    this.obs.clear(true);
    this.value = void 0;
  }

}

exports.ExpressionWatcher = ExpressionWatcher;
(0, _runtime.connectable)(ComputedWatcher);
(0, _runtime.connectable)(ExpressionWatcher);
});

;define.alias('@aurelia/runtime-html/templating/watchers.js','@aurelia/runtime-html/dist/esm/templating/watchers.js');
define('@aurelia/runtime-html/dist/esm/watch.js',['require','exports','module','@aurelia/kernel'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.watch = watch;
exports.Watch = void 0;

var _kernel = require("@aurelia/kernel");

function watch(expressionOrPropertyAccessFn, changeHandlerOrCallback) {
  if (!expressionOrPropertyAccessFn) {
    throw new Error('Invalid watch config. Expected an expression or a fn');
  }

  return function decorator(target, key, descriptor) {
    const isClassDecorator = key == null;
    const Type = isClassDecorator ? target : target.constructor; // basic validation

    if (isClassDecorator) {
      if (typeof changeHandlerOrCallback !== 'function' && (changeHandlerOrCallback == null || !(changeHandlerOrCallback in Type.prototype))) {
        throw new Error(`Invalid change handler config. Method "${String(changeHandlerOrCallback)}" not found in class ${Type.name}`);
      }
    } else if (typeof descriptor?.value !== 'function') {
      throw new Error(`decorated target ${String(key)} is not a class method.`);
    }

    Watch.add(Type, new WatchDefinition(expressionOrPropertyAccessFn, isClassDecorator ? changeHandlerOrCallback : descriptor.value));
  };
}

class WatchDefinition {
  constructor(expression, callback) {
    this.expression = expression;
    this.callback = callback;
  }

}

const noDefinitions = _kernel.emptyArray;
const Watch = {
  name: _kernel.Protocol.annotation.keyFor('watch'),

  add(Type, definition) {
    let watchDefinitions = _kernel.Metadata.getOwn(Watch.name, Type);

    if (watchDefinitions == null) {
      _kernel.Metadata.define(Watch.name, watchDefinitions = [], Type);
    }

    watchDefinitions.push(definition);
  },

  getAnnotation(Type) {
    return _kernel.Metadata.getOwn(Watch.name, Type) ?? noDefinitions;
  }

};
exports.Watch = Watch;
});

;define.alias('@aurelia/runtime-html/watch.js','@aurelia/runtime-html/dist/esm/watch.js');
define('@aurelia/runtime/dist/esm/alias.js',['require','exports','module','@aurelia/kernel'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.alias = alias;
exports.registerAliases = registerAliases;

var _kernel = require("@aurelia/kernel");

function alias(...aliases) {
  return function (target) {
    const key = _kernel.Protocol.annotation.keyFor('aliases');

    const existing = _kernel.Metadata.getOwn(key, target);

    if (existing === void 0) {
      _kernel.Metadata.define(key, aliases, target);
    } else {
      existing.push(...aliases);
    }
  };
}

function registerAliases(aliases, resource, key, container) {
  for (let i = 0, ii = aliases.length; i < ii; ++i) {
    _kernel.Registration.aliasTo(key, resource.keyFrom(aliases[i])).register(container);
  }
}
});

;define.alias('@aurelia/runtime/alias.js','@aurelia/runtime/dist/esm/alias.js');
define('@aurelia/runtime/dist/esm/binding-behavior.js',['require','exports','module','@aurelia/kernel','./alias.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.bindingBehavior = bindingBehavior;
exports.BindingBehavior = exports.BindingInterceptor = exports.BindingBehaviorFactory = exports.BindingBehaviorDefinition = exports.BindingBehaviorStrategy = void 0;

var _kernel = require("@aurelia/kernel");

var _alias = require("./alias.js");

var BindingBehaviorStrategy;
exports.BindingBehaviorStrategy = BindingBehaviorStrategy;

(function (BindingBehaviorStrategy) {
  BindingBehaviorStrategy[BindingBehaviorStrategy["singleton"] = 1] = "singleton";
  BindingBehaviorStrategy[BindingBehaviorStrategy["interceptor"] = 2] = "interceptor";
})(BindingBehaviorStrategy || (exports.BindingBehaviorStrategy = BindingBehaviorStrategy = {}));

function bindingBehavior(nameOrDef) {
  return function (target) {
    return BindingBehavior.define(nameOrDef, target);
  };
}

class BindingBehaviorDefinition {
  constructor(Type, name, aliases, key, strategy) {
    this.Type = Type;
    this.name = name;
    this.aliases = aliases;
    this.key = key;
    this.strategy = strategy;
  }

  static create(nameOrDef, Type) {
    let name;
    let def;

    if (typeof nameOrDef === 'string') {
      name = nameOrDef;
      def = {
        name
      };
    } else {
      name = nameOrDef.name;
      def = nameOrDef;
    }

    const inheritsFromInterceptor = Object.getPrototypeOf(Type) === BindingInterceptor;
    return new BindingBehaviorDefinition(Type, (0, _kernel.firstDefined)(BindingBehavior.getAnnotation(Type, 'name'), name), (0, _kernel.mergeArrays)(BindingBehavior.getAnnotation(Type, 'aliases'), def.aliases, Type.aliases), BindingBehavior.keyFrom(name), (0, _kernel.fromAnnotationOrDefinitionOrTypeOrDefault)('strategy', def, Type, () => inheritsFromInterceptor ? 2
    /* interceptor */
    : 1
    /* singleton */
    ));
  }

  register(container) {
    const {
      Type,
      key,
      aliases,
      strategy
    } = this;

    switch (strategy) {
      case 1
      /* singleton */
      :
        _kernel.Registration.singleton(key, Type).register(container);

        break;

      case 2
      /* interceptor */
      :
        _kernel.Registration.instance(key, new BindingBehaviorFactory(container, Type)).register(container);

        break;
    }

    _kernel.Registration.aliasTo(key, Type).register(container);

    (0, _alias.registerAliases)(aliases, BindingBehavior, key, container);
  }

}

exports.BindingBehaviorDefinition = BindingBehaviorDefinition;

class BindingBehaviorFactory {
  constructor(container, Type) {
    this.container = container;
    this.Type = Type;
    this.deps = _kernel.DI.getDependencies(Type);
  }

  construct(binding, expr) {
    const container = this.container;
    const deps = this.deps;

    switch (deps.length) {
      case 0:
      case 1:
      case 2:
        // TODO(fkleuver): fix this cast
        return new this.Type(binding, expr);

      case 3:
        return new this.Type(container.get(deps[0]), binding, expr);

      case 4:
        return new this.Type(container.get(deps[0]), container.get(deps[1]), binding, expr);

      default:
        return new this.Type(...deps.map(d => container.get(d)), binding, expr);
    }
  }

}

exports.BindingBehaviorFactory = BindingBehaviorFactory;

class BindingInterceptor {
  constructor(binding, expr) {
    this.binding = binding;
    this.expr = expr;
    this.interceptor = this;
    let interceptor;

    while (binding.interceptor !== this) {
      interceptor = binding.interceptor;
      binding.interceptor = this;
      binding = interceptor;
    }
  }

  get id() {
    return this.binding.id;
  }

  get observerLocator() {
    return this.binding.observerLocator;
  }

  get locator() {
    return this.binding.locator;
  }

  get $scope() {
    return this.binding.$scope;
  }

  get $hostScope() {
    return this.binding.$hostScope;
  }

  get isBound() {
    return this.binding.isBound;
  }

  get obs() {
    return this.binding.obs;
  }

  updateTarget(value, flags) {
    this.binding.updateTarget(value, flags);
  }

  updateSource(value, flags) {
    this.binding.updateSource(value, flags);
  }

  callSource(args) {
    return this.binding.callSource(args);
  }

  handleChange(newValue, previousValue, flags) {
    this.binding.handleChange(newValue, previousValue, flags);
  }

  handleCollectionChange(indexMap, flags) {
    this.binding.handleCollectionChange(indexMap, flags);
  }

  observeProperty(obj, key) {
    this.binding.observeProperty(obj, key);
  }

  observeCollection(observer) {
    this.binding.observeCollection(observer);
  }

  $bind(flags, scope, hostScope) {
    this.binding.$bind(flags, scope, hostScope);
  }

  $unbind(flags) {
    this.binding.$unbind(flags);
  }

}

exports.BindingInterceptor = BindingInterceptor;
const BindingBehavior = {
  name: _kernel.Protocol.resource.keyFor('binding-behavior'),

  keyFrom(name) {
    return `${BindingBehavior.name}:${name}`;
  },

  isType(value) {
    return typeof value === 'function' && _kernel.Metadata.hasOwn(BindingBehavior.name, value);
  },

  define(nameOrDef, Type) {
    const definition = BindingBehaviorDefinition.create(nameOrDef, Type);

    _kernel.Metadata.define(BindingBehavior.name, definition, definition.Type);

    _kernel.Metadata.define(BindingBehavior.name, definition, definition);

    _kernel.Protocol.resource.appendTo(Type, BindingBehavior.name);

    return definition.Type;
  },

  getDefinition(Type) {
    const def = _kernel.Metadata.getOwn(BindingBehavior.name, Type);

    if (def === void 0) {
      throw new Error(`No definition found for type ${Type.name}`);
    }

    return def;
  },

  annotate(Type, prop, value) {
    _kernel.Metadata.define(_kernel.Protocol.annotation.keyFor(prop), value, Type);
  },

  getAnnotation(Type, prop) {
    return _kernel.Metadata.getOwn(_kernel.Protocol.annotation.keyFor(prop), Type);
  }

};
exports.BindingBehavior = BindingBehavior;
});

;define.alias('@aurelia/runtime/binding-behavior.js','@aurelia/runtime/dist/esm/binding-behavior.js');
define('@aurelia/runtime/dist/esm/binding/ast.js',['require','exports','module','@aurelia/kernel','../observation/binding-context.js','../observation/signaler.js','../binding-behavior.js','../value-converter.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.Interpolation = exports.ForOfStatement = exports.BindingIdentifier = exports.ObjectBindingPattern = exports.ArrayBindingPattern = exports.TaggedTemplateExpression = exports.TemplateExpression = exports.ObjectLiteralExpression = exports.ArrayLiteralExpression = exports.HtmlLiteralExpression = exports.PrimitiveLiteralExpression = exports.UnaryExpression = exports.BinaryExpression = exports.CallFunctionExpression = exports.CallMemberExpression = exports.CallScopeExpression = exports.AccessKeyedExpression = exports.AccessMemberExpression = exports.AccessScopeExpression = exports.AccessThisExpression = exports.ConditionalExpression = exports.AssignExpression = exports.ValueConverterExpression = exports.BindingBehaviorExpression = exports.CustomExpression = exports.Unparser = exports.ExpressionKind = void 0;

var _kernel = require("@aurelia/kernel");

var _bindingContext = require("../observation/binding-context.js");

var _signaler = require("../observation/signaler.js");

var _bindingBehavior = require("../binding-behavior.js");

var _valueConverter = require("../value-converter.js");

/* eslint-disable eqeqeq */

/* eslint-disable @typescript-eslint/restrict-template-expressions */
var ExpressionKind;
exports.ExpressionKind = ExpressionKind;

(function (ExpressionKind) {
  ExpressionKind[ExpressionKind["Connects"] = 32] = "Connects";
  ExpressionKind[ExpressionKind["Observes"] = 64] = "Observes";
  ExpressionKind[ExpressionKind["CallsFunction"] = 128] = "CallsFunction";
  ExpressionKind[ExpressionKind["HasAncestor"] = 256] = "HasAncestor";
  ExpressionKind[ExpressionKind["IsPrimary"] = 512] = "IsPrimary";
  ExpressionKind[ExpressionKind["IsLeftHandSide"] = 1024] = "IsLeftHandSide";
  ExpressionKind[ExpressionKind["HasBind"] = 2048] = "HasBind";
  ExpressionKind[ExpressionKind["HasUnbind"] = 4096] = "HasUnbind";
  ExpressionKind[ExpressionKind["IsAssignable"] = 8192] = "IsAssignable";
  ExpressionKind[ExpressionKind["IsLiteral"] = 16384] = "IsLiteral";
  ExpressionKind[ExpressionKind["IsResource"] = 32768] = "IsResource";
  ExpressionKind[ExpressionKind["IsForDeclaration"] = 65536] = "IsForDeclaration";
  ExpressionKind[ExpressionKind["Type"] = 31] = "Type"; // ---------------------------------------------------------------------------------------------------------------------------

  ExpressionKind[ExpressionKind["AccessThis"] = 1793] = "AccessThis";
  ExpressionKind[ExpressionKind["AccessScope"] = 10082] = "AccessScope";
  ExpressionKind[ExpressionKind["ArrayLiteral"] = 17955] = "ArrayLiteral";
  ExpressionKind[ExpressionKind["ObjectLiteral"] = 17956] = "ObjectLiteral";
  ExpressionKind[ExpressionKind["PrimitiveLiteral"] = 17925] = "PrimitiveLiteral";
  ExpressionKind[ExpressionKind["Template"] = 17958] = "Template";
  ExpressionKind[ExpressionKind["Unary"] = 39] = "Unary";
  ExpressionKind[ExpressionKind["CallScope"] = 1448] = "CallScope";
  ExpressionKind[ExpressionKind["CallMember"] = 1161] = "CallMember";
  ExpressionKind[ExpressionKind["CallFunction"] = 1162] = "CallFunction";
  ExpressionKind[ExpressionKind["AccessMember"] = 9323] = "AccessMember";
  ExpressionKind[ExpressionKind["AccessKeyed"] = 9324] = "AccessKeyed";
  ExpressionKind[ExpressionKind["TaggedTemplate"] = 1197] = "TaggedTemplate";
  ExpressionKind[ExpressionKind["Binary"] = 46] = "Binary";
  ExpressionKind[ExpressionKind["Conditional"] = 63] = "Conditional";
  ExpressionKind[ExpressionKind["Assign"] = 8208] = "Assign";
  ExpressionKind[ExpressionKind["ValueConverter"] = 36913] = "ValueConverter";
  ExpressionKind[ExpressionKind["BindingBehavior"] = 38962] = "BindingBehavior";
  ExpressionKind[ExpressionKind["HtmlLiteral"] = 51] = "HtmlLiteral";
  ExpressionKind[ExpressionKind["ArrayBindingPattern"] = 65556] = "ArrayBindingPattern";
  ExpressionKind[ExpressionKind["ObjectBindingPattern"] = 65557] = "ObjectBindingPattern";
  ExpressionKind[ExpressionKind["BindingIdentifier"] = 65558] = "BindingIdentifier";
  ExpressionKind[ExpressionKind["ForOfStatement"] = 6199] = "ForOfStatement";
  ExpressionKind[ExpressionKind["Interpolation"] = 24] = "Interpolation"; //
})(ExpressionKind || (exports.ExpressionKind = ExpressionKind = {}));

class Unparser {
  constructor() {
    this.text = '';
  }

  static unparse(expr) {
    const visitor = new Unparser();
    expr.accept(visitor);
    return visitor.text;
  }

  visitAccessMember(expr) {
    expr.object.accept(this);
    this.text += `.${expr.name}`;
  }

  visitAccessKeyed(expr) {
    expr.object.accept(this);
    this.text += '[';
    expr.key.accept(this);
    this.text += ']';
  }

  visitAccessThis(expr) {
    if (expr.ancestor === 0) {
      this.text += '$this';
      return;
    }

    this.text += '$parent';
    let i = expr.ancestor - 1;

    while (i--) {
      this.text += '.$parent';
    }
  }

  visitAccessScope(expr) {
    let i = expr.ancestor;

    while (i--) {
      this.text += '$parent.';
    }

    this.text += expr.name;
  }

  visitArrayLiteral(expr) {
    const elements = expr.elements;
    this.text += '[';

    for (let i = 0, length = elements.length; i < length; ++i) {
      if (i !== 0) {
        this.text += ',';
      }

      elements[i].accept(this);
    }

    this.text += ']';
  }

  visitObjectLiteral(expr) {
    const keys = expr.keys;
    const values = expr.values;
    this.text += '{';

    for (let i = 0, length = keys.length; i < length; ++i) {
      if (i !== 0) {
        this.text += ',';
      }

      this.text += `'${keys[i]}':`;
      values[i].accept(this);
    }

    this.text += '}';
  }

  visitPrimitiveLiteral(expr) {
    this.text += '(';

    if (typeof expr.value === 'string') {
      const escaped = expr.value.replace(/'/g, '\\\'');
      this.text += `'${escaped}'`;
    } else {
      this.text += `${expr.value}`;
    }

    this.text += ')';
  }

  visitCallFunction(expr) {
    this.text += '(';
    expr.func.accept(this);
    this.writeArgs(expr.args);
    this.text += ')';
  }

  visitCallMember(expr) {
    this.text += '(';
    expr.object.accept(this);
    this.text += `.${expr.name}`;
    this.writeArgs(expr.args);
    this.text += ')';
  }

  visitCallScope(expr) {
    this.text += '(';
    let i = expr.ancestor;

    while (i--) {
      this.text += '$parent.';
    }

    this.text += expr.name;
    this.writeArgs(expr.args);
    this.text += ')';
  }

  visitTemplate(expr) {
    const {
      cooked,
      expressions
    } = expr;
    const length = expressions.length;
    this.text += '`';
    this.text += cooked[0];

    for (let i = 0; i < length; i++) {
      expressions[i].accept(this);
      this.text += cooked[i + 1];
    }

    this.text += '`';
  }

  visitTaggedTemplate(expr) {
    const {
      cooked,
      expressions
    } = expr;
    const length = expressions.length;
    expr.func.accept(this);
    this.text += '`';
    this.text += cooked[0];

    for (let i = 0; i < length; i++) {
      expressions[i].accept(this);
      this.text += cooked[i + 1];
    }

    this.text += '`';
  }

  visitUnary(expr) {
    this.text += `(${expr.operation}`;

    if (expr.operation.charCodeAt(0) >=
    /* a */
    97) {
      this.text += ' ';
    }

    expr.expression.accept(this);
    this.text += ')';
  }

  visitBinary(expr) {
    this.text += '(';
    expr.left.accept(this);

    if (expr.operation.charCodeAt(0) ===
    /* i */
    105) {
      this.text += ` ${expr.operation} `;
    } else {
      this.text += expr.operation;
    }

    expr.right.accept(this);
    this.text += ')';
  }

  visitConditional(expr) {
    this.text += '(';
    expr.condition.accept(this);
    this.text += '?';
    expr.yes.accept(this);
    this.text += ':';
    expr.no.accept(this);
    this.text += ')';
  }

  visitAssign(expr) {
    this.text += '(';
    expr.target.accept(this);
    this.text += '=';
    expr.value.accept(this);
    this.text += ')';
  }

  visitValueConverter(expr) {
    const args = expr.args;
    expr.expression.accept(this);
    this.text += `|${expr.name}`;

    for (let i = 0, length = args.length; i < length; ++i) {
      this.text += ':';
      args[i].accept(this);
    }
  }

  visitBindingBehavior(expr) {
    const args = expr.args;
    expr.expression.accept(this);
    this.text += `&${expr.name}`;

    for (let i = 0, length = args.length; i < length; ++i) {
      this.text += ':';
      args[i].accept(this);
    }
  }

  visitArrayBindingPattern(expr) {
    const elements = expr.elements;
    this.text += '[';

    for (let i = 0, length = elements.length; i < length; ++i) {
      if (i !== 0) {
        this.text += ',';
      }

      elements[i].accept(this);
    }

    this.text += ']';
  }

  visitObjectBindingPattern(expr) {
    const keys = expr.keys;
    const values = expr.values;
    this.text += '{';

    for (let i = 0, length = keys.length; i < length; ++i) {
      if (i !== 0) {
        this.text += ',';
      }

      this.text += `'${keys[i]}':`;
      values[i].accept(this);
    }

    this.text += '}';
  }

  visitBindingIdentifier(expr) {
    this.text += expr.name;
  }

  visitHtmlLiteral(expr) {
    throw new Error('visitHtmlLiteral');
  }

  visitForOfStatement(expr) {
    expr.declaration.accept(this);
    this.text += ' of ';
    expr.iterable.accept(this);
  }

  visitInterpolation(expr) {
    const {
      parts,
      expressions
    } = expr;
    const length = expressions.length;
    this.text += '${';
    this.text += parts[0];

    for (let i = 0; i < length; i++) {
      expressions[i].accept(this);
      this.text += parts[i + 1];
    }

    this.text += '}';
  }

  writeArgs(args) {
    this.text += '(';

    for (let i = 0, length = args.length; i < length; ++i) {
      if (i !== 0) {
        this.text += ',';
      }

      args[i].accept(this);
    }

    this.text += ')';
  }

}

exports.Unparser = Unparser;

function chooseScope(accessHostScope, s, hs) {
  if (accessHostScope) {
    if (hs === null || hs === void 0) {
      throw new Error('Host scope is missing. Are you using `$host` outside the `au-slot`? Or missing the `au-slot` attribute?');
    }

    return hs;
  }

  return s;
}

class CustomExpression {
  constructor(value) {
    this.value = value;
  }

  evaluate(_f, _s, _hs, _l, _c) {
    return this.value;
  }

}

exports.CustomExpression = CustomExpression;

class BindingBehaviorExpression {
  constructor(expression, name, args) {
    this.expression = expression;
    this.name = name;
    this.args = args;
    this.behaviorKey = _bindingBehavior.BindingBehavior.keyFrom(name);
  }

  get $kind() {
    return 38962
    /* BindingBehavior */
    ;
  }

  get hasBind() {
    return true;
  }

  get hasUnbind() {
    return true;
  }

  evaluate(f, s, hs, l, c) {
    return this.expression.evaluate(f, s, hs, l, c);
  }

  assign(f, s, hs, l, val) {
    return this.expression.assign(f, s, hs, l, val);
  }

  bind(f, s, hs, b) {
    if (this.expression.hasBind) {
      this.expression.bind(f, s, hs, b);
    }

    const behavior = b.locator.get(this.behaviorKey);

    if (behavior == null) {
      throw new Error(`BindingBehavior named '${this.name}' could not be found. Did you forget to register it as a dependency?`);
    }

    if (!(behavior instanceof _bindingBehavior.BindingBehaviorFactory)) {
      if (b[this.behaviorKey] === void 0) {
        b[this.behaviorKey] = behavior;
        behavior.bind.call(behavior, f, s, hs, b, ...this.args.map(a => a.evaluate(f, s, hs, b.locator, null)));
      } else {
        throw new Error(`BindingBehavior named '${this.name}' already applied.`);
      }
    }
  }

  unbind(f, s, hs, b) {
    const key = this.behaviorKey;
    const $b = b;

    if ($b[key] !== void 0) {
      if (typeof $b[key].unbind === 'function') {
        $b[key].unbind(f, s, hs, b);
      }

      $b[key] = void 0;
    }

    if (this.expression.hasUnbind) {
      this.expression.unbind(f, s, hs, b);
    }
  }

  accept(visitor) {
    return visitor.visitBindingBehavior(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}

exports.BindingBehaviorExpression = BindingBehaviorExpression;

class ValueConverterExpression {
  constructor(expression, name, args) {
    this.expression = expression;
    this.name = name;
    this.args = args;
    this.converterKey = _valueConverter.ValueConverter.keyFrom(name);
  }

  get $kind() {
    return 36913
    /* ValueConverter */
    ;
  }

  get hasBind() {
    return false;
  }

  get hasUnbind() {
    return true;
  }

  evaluate(f, s, hs, l, c) {
    const vc = l.get(this.converterKey);

    if (vc == null) {
      throw new Error(`ValueConverter named '${this.name}' could not be found. Did you forget to register it as a dependency?`);
    } // note: the cast is expected. To connect, it just needs to be a IConnectable
    // though to work with signal, it needs to have `handleChange`
    // so having `handleChange` as a guard in the connectable as a safe measure is needed
    // to make sure signaler works


    if (c !== null && 'handleChange' in c) {
      const signals = vc.signals;

      if (signals != null) {
        const signaler = l.get(_signaler.ISignaler);

        for (let i = 0, ii = signals.length; i < ii; ++i) {
          signaler.addSignalListener(signals[i], c);
        }
      }
    }

    if ('toView' in vc) {
      return vc.toView(this.expression.evaluate(f, s, hs, l, c), ...this.args.map(a => a.evaluate(f, s, hs, l, c)));
    }

    return this.expression.evaluate(f, s, hs, l, c);
  }

  assign(f, s, hs, l, val) {
    const vc = l.get(this.converterKey);

    if (vc == null) {
      throw new Error(`ValueConverter named '${this.name}' could not be found. Did you forget to register it as a dependency?`);
    }

    if ('fromView' in vc) {
      val = vc.fromView(val, ...this.args.map(a => a.evaluate(f, s, hs, l, null)));
    }

    return this.expression.assign(f, s, hs, l, val);
  }

  unbind(_f, _s, _hs, b) {
    const vc = b.locator.get(this.converterKey);

    if (vc.signals === void 0) {
      return;
    }

    const signaler = b.locator.get(_signaler.ISignaler);

    for (let i = 0; i < vc.signals.length; ++i) {
      // the cast is correct, as the value converter expression would only add
      // a IConnectable that also implements `ISubscriber` interface to the signaler
      signaler.removeSignalListener(vc.signals[i], b);
    }
  }

  accept(visitor) {
    return visitor.visitValueConverter(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}

exports.ValueConverterExpression = ValueConverterExpression;

class AssignExpression {
  constructor(target, value) {
    this.target = target;
    this.value = value;
  }

  get $kind() {
    return 8208
    /* Assign */
    ;
  }

  get hasBind() {
    return false;
  }

  get hasUnbind() {
    return false;
  }

  evaluate(f, s, hs, l, c) {
    return this.target.assign(f, s, hs, l, this.value.evaluate(f, s, hs, l, c));
  }

  assign(f, s, hs, l, val) {
    this.value.assign(f, s, hs, l, val);
    return this.target.assign(f, s, hs, l, val);
  }

  accept(visitor) {
    return visitor.visitAssign(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}

exports.AssignExpression = AssignExpression;

class ConditionalExpression {
  constructor(condition, yes, no) {
    this.condition = condition;
    this.yes = yes;
    this.no = no;
  }

  get $kind() {
    return 63
    /* Conditional */
    ;
  }

  get hasBind() {
    return false;
  }

  get hasUnbind() {
    return false;
  }

  evaluate(f, s, hs, l, c) {
    return this.condition.evaluate(f, s, hs, l, c) ? this.yes.evaluate(f, s, hs, l, c) : this.no.evaluate(f, s, hs, l, c);
  }

  assign(_f, _s, _hs, _l, _obj) {
    return void 0;
  }

  accept(visitor) {
    return visitor.visitConditional(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}

exports.ConditionalExpression = ConditionalExpression;

class AccessThisExpression {
  constructor(ancestor = 0) {
    this.ancestor = ancestor;
  }

  get $kind() {
    return 1793
    /* AccessThis */
    ;
  }

  get hasBind() {
    return false;
  }

  get hasUnbind() {
    return false;
  }

  evaluate(_f, s, hs, _l, _c) {
    if (this === AccessThisExpression.$host) {
      s = chooseScope(true, s, hs);
    }

    let oc = s.overrideContext;
    let currentScope = s;
    let i = this.ancestor;

    while (i-- && oc) {
      currentScope = currentScope.parentScope;
      oc = currentScope?.overrideContext ?? null;
    }

    return i < 1 && oc ? oc.bindingContext : void 0;
  }

  assign(_f, _s, _hs, _l, _obj) {
    return void 0;
  }

  accept(visitor) {
    return visitor.visitAccessThis(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}

exports.AccessThisExpression = AccessThisExpression;
AccessThisExpression.$this = new AccessThisExpression(0); // $host and $this are loosely the same thing. $host is used in the context of `au-slot` with the primary objective of determining the s.

AccessThisExpression.$host = new AccessThisExpression(0);
AccessThisExpression.$parent = new AccessThisExpression(1);

class AccessScopeExpression {
  constructor(name, ancestor = 0, accessHostScope = false) {
    this.name = name;
    this.ancestor = ancestor;
    this.accessHostScope = accessHostScope;
  }

  get $kind() {
    return 10082
    /* AccessScope */
    ;
  }

  get hasBind() {
    return false;
  }

  get hasUnbind() {
    return false;
  }

  evaluate(f, s, hs, _l, c) {
    const obj = _bindingContext.BindingContext.get(chooseScope(this.accessHostScope, s, hs), this.name, this.ancestor, f, hs);

    if (c !== null) {
      c.observeProperty(obj, this.name);
    }

    const evaluatedValue = obj[this.name];

    if (f & 4
    /* isStrictBindingStrategy */
    ) {
        return evaluatedValue;
      }

    return evaluatedValue == null ? '' : evaluatedValue;
  }

  assign(f, s, hs, _l, val) {
    const obj = _bindingContext.BindingContext.get(chooseScope(this.accessHostScope, s, hs), this.name, this.ancestor, f, hs);

    if (obj instanceof Object) {
      if (obj.$observers?.[this.name] !== void 0) {
        obj.$observers[this.name].setValue(val, f);
        return val;
      } else {
        return obj[this.name] = val;
      }
    }

    return void 0;
  }

  accept(visitor) {
    return visitor.visitAccessScope(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}

exports.AccessScopeExpression = AccessScopeExpression;

class AccessMemberExpression {
  constructor(object, name) {
    this.object = object;
    this.name = name;
  }

  get $kind() {
    return 9323
    /* AccessMember */
    ;
  }

  get hasBind() {
    return false;
  }

  get hasUnbind() {
    return false;
  }

  evaluate(f, s, hs, l, c) {
    const instance = this.object.evaluate(f, s, hs, l, (f & 2048
    /* observeLeafPropertiesOnly */
    ) > 0 ? null : c);

    if (f & 4
    /* isStrictBindingStrategy */
    ) {
        if (instance == null) {
          return instance;
        }

        if (c !== null) {
          c.observeProperty(instance, this.name);
        }

        return instance[this.name];
      }

    if (c !== null && instance instanceof Object) {
      c.observeProperty(instance, this.name);
    }

    return instance ? instance[this.name] : '';
  }

  assign(f, s, hs, l, val) {
    const obj = this.object.evaluate(f, s, hs, l, null);

    if (obj instanceof Object) {
      if (obj.$observers !== void 0 && obj.$observers[this.name] !== void 0) {
        obj.$observers[this.name].setValue(val, f);
      } else {
        obj[this.name] = val;
      }
    } else {
      this.object.assign(f, s, hs, l, {
        [this.name]: val
      });
    }

    return val;
  }

  accept(visitor) {
    return visitor.visitAccessMember(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}

exports.AccessMemberExpression = AccessMemberExpression;

class AccessKeyedExpression {
  constructor(object, key) {
    this.object = object;
    this.key = key;
  }

  get $kind() {
    return 9324
    /* AccessKeyed */
    ;
  }

  get hasBind() {
    return false;
  }

  get hasUnbind() {
    return false;
  }

  evaluate(f, s, hs, l, c) {
    const instance = this.object.evaluate(f, s, hs, l, (f & 2048
    /* observeLeafPropertiesOnly */
    ) > 0 ? null : c);

    if (instance instanceof Object) {
      const key = this.key.evaluate(f, s, hs, l, (f & 2048
      /* observeLeafPropertiesOnly */
      ) > 0 ? null : c);

      if (c !== null) {
        c.observeProperty(instance, key);
      }

      return instance[key];
    }

    return void 0;
  }

  assign(f, s, hs, l, val) {
    const instance = this.object.evaluate(f, s, hs, l, null);
    const key = this.key.evaluate(f, s, hs, l, null);
    return instance[key] = val;
  }

  accept(visitor) {
    return visitor.visitAccessKeyed(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}

exports.AccessKeyedExpression = AccessKeyedExpression;

class CallScopeExpression {
  constructor(name, args, ancestor = 0, accessHostScope = false) {
    this.name = name;
    this.args = args;
    this.ancestor = ancestor;
    this.accessHostScope = accessHostScope;
  }

  get $kind() {
    return 1448
    /* CallScope */
    ;
  }

  get hasBind() {
    return false;
  }

  get hasUnbind() {
    return false;
  }

  evaluate(f, s, hs, l, c) {
    s = chooseScope(this.accessHostScope, s, hs);
    const args = this.args.map(a => a.evaluate(f, s, hs, l, c));

    const context = _bindingContext.BindingContext.get(s, this.name, this.ancestor, f, hs); // ideally, should observe property represents by this.name as well
    // because it could be changed
    // todo: did it ever surprise anyone?


    const func = getFunction(f, context, this.name);

    if (func) {
      return func.apply(context, args);
    }

    return void 0;
  }

  assign(_f, _s, _hs, _l, _obj) {
    return void 0;
  }

  accept(visitor) {
    return visitor.visitCallScope(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}

exports.CallScopeExpression = CallScopeExpression;

class CallMemberExpression {
  constructor(object, name, args) {
    this.object = object;
    this.name = name;
    this.args = args;
  }

  get $kind() {
    return 1161
    /* CallMember */
    ;
  }

  get hasBind() {
    return false;
  }

  get hasUnbind() {
    return false;
  }

  evaluate(f, s, hs, l, c) {
    const instance = this.object.evaluate(f, s, hs, l, (f & 2048
    /* observeLeafPropertiesOnly */
    ) > 0 ? null : c);
    const args = this.args.map(a => a.evaluate(f, s, hs, l, c));
    const func = getFunction(f, instance, this.name);

    if (func) {
      return func.apply(instance, args);
    }

    return void 0;
  }

  assign(_f, _s, _hs, _l, _obj) {
    return void 0;
  }

  accept(visitor) {
    return visitor.visitCallMember(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}

exports.CallMemberExpression = CallMemberExpression;

class CallFunctionExpression {
  constructor(func, args) {
    this.func = func;
    this.args = args;
  }

  get $kind() {
    return 1162
    /* CallFunction */
    ;
  }

  get hasBind() {
    return false;
  }

  get hasUnbind() {
    return false;
  }

  evaluate(f, s, hs, l, c) {
    const func = this.func.evaluate(f, s, hs, l, c);

    if (typeof func === 'function') {
      return func(...this.args.map(a => a.evaluate(f, s, hs, l, c)));
    }

    if (!(f & 128
    /* mustEvaluate */
    ) && func == null) {
      return void 0;
    }

    throw new Error(`Expression is not a function.`);
  }

  assign(_f, _s, _hs, _l, _obj) {
    return void 0;
  }

  accept(visitor) {
    return visitor.visitCallFunction(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}

exports.CallFunctionExpression = CallFunctionExpression;

class BinaryExpression {
  constructor(operation, left, right) {
    this.operation = operation;
    this.left = left;
    this.right = right;
  }

  get $kind() {
    return 46
    /* Binary */
    ;
  }

  get hasBind() {
    return false;
  }

  get hasUnbind() {
    return false;
  }

  evaluate(f, s, hs, l, c) {
    switch (this.operation) {
      case '&&':
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        return this.left.evaluate(f, s, hs, l, c) && this.right.evaluate(f, s, hs, l, c);

      case '||':
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        return this.left.evaluate(f, s, hs, l, c) || this.right.evaluate(f, s, hs, l, c);

      case '==':
        return this.left.evaluate(f, s, hs, l, c) == this.right.evaluate(f, s, hs, l, c);

      case '===':
        return this.left.evaluate(f, s, hs, l, c) === this.right.evaluate(f, s, hs, l, c);

      case '!=':
        return this.left.evaluate(f, s, hs, l, c) != this.right.evaluate(f, s, hs, l, c);

      case '!==':
        return this.left.evaluate(f, s, hs, l, c) !== this.right.evaluate(f, s, hs, l, c);

      case 'instanceof':
        {
          const right = this.right.evaluate(f, s, hs, l, c);

          if (typeof right === 'function') {
            return this.left.evaluate(f, s, hs, l, c) instanceof right;
          }

          return false;
        }

      case 'in':
        {
          const right = this.right.evaluate(f, s, hs, l, c);

          if (right instanceof Object) {
            return this.left.evaluate(f, s, hs, l, c) in right;
          }

          return false;
        }
      // note: autoConvertAdd (and the null check) is removed because the default spec behavior is already largely similar
      // and where it isn't, you kind of want it to behave like the spec anyway (e.g. return NaN when adding a number to undefined)
      // this makes bugs in user code easier to track down for end users
      // also, skipping these checks and leaving it to the runtime is a nice little perf boost and simplifies our code

      case '+':
        {
          const left = this.left.evaluate(f, s, hs, l, c);
          const right = this.right.evaluate(f, s, hs, l, c);

          if ((f & 4
          /* isStrictBindingStrategy */
          ) > 0) {
            return left + right;
          } // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions


          if (!left || !right) {
            if ((0, _kernel.isNumberOrBigInt)(left) || (0, _kernel.isNumberOrBigInt)(right)) {
              return (left || 0) + (right || 0);
            }

            if ((0, _kernel.isStringOrDate)(left) || (0, _kernel.isStringOrDate)(right)) {
              return (left || '') + (right || '');
            }
          }

          return left + right;
        }

      case '-':
        return this.left.evaluate(f, s, hs, l, c) - this.right.evaluate(f, s, hs, l, c);

      case '*':
        return this.left.evaluate(f, s, hs, l, c) * this.right.evaluate(f, s, hs, l, c);

      case '/':
        return this.left.evaluate(f, s, hs, l, c) / this.right.evaluate(f, s, hs, l, c);

      case '%':
        return this.left.evaluate(f, s, hs, l, c) % this.right.evaluate(f, s, hs, l, c);

      case '<':
        return this.left.evaluate(f, s, hs, l, c) < this.right.evaluate(f, s, hs, l, c);

      case '>':
        return this.left.evaluate(f, s, hs, l, c) > this.right.evaluate(f, s, hs, l, c);

      case '<=':
        return this.left.evaluate(f, s, hs, l, c) <= this.right.evaluate(f, s, hs, l, c);

      case '>=':
        return this.left.evaluate(f, s, hs, l, c) >= this.right.evaluate(f, s, hs, l, c);

      default:
        throw new Error(`Unknown binary operator: '${this.operation}'`);
    }
  }

  assign(_f, _s, _hs, _l, _obj) {
    return void 0;
  }

  accept(visitor) {
    return visitor.visitBinary(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}

exports.BinaryExpression = BinaryExpression;

class UnaryExpression {
  constructor(operation, expression) {
    this.operation = operation;
    this.expression = expression;
  }

  get $kind() {
    return 39
    /* Unary */
    ;
  }

  get hasBind() {
    return false;
  }

  get hasUnbind() {
    return false;
  }

  evaluate(f, s, hs, l, c) {
    switch (this.operation) {
      case 'void':
        return void this.expression.evaluate(f, s, hs, l, c);

      case 'typeof':
        return typeof this.expression.evaluate(f | 4
        /* isStrictBindingStrategy */
        , s, hs, l, c);

      case '!':
        return !this.expression.evaluate(f, s, hs, l, c);

      case '-':
        return -this.expression.evaluate(f, s, hs, l, c);

      case '+':
        return +this.expression.evaluate(f, s, hs, l, c);

      default:
        throw new Error(`Unknown unary operator: '${this.operation}'`);
    }
  }

  assign(_f, _s, _hs, _l, _obj) {
    return void 0;
  }

  accept(visitor) {
    return visitor.visitUnary(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}

exports.UnaryExpression = UnaryExpression;

class PrimitiveLiteralExpression {
  constructor(value) {
    this.value = value;
  }

  get $kind() {
    return 17925
    /* PrimitiveLiteral */
    ;
  }

  get hasBind() {
    return false;
  }

  get hasUnbind() {
    return false;
  }

  evaluate(_f, _s, _hs, _l, _c) {
    return this.value;
  }

  assign(_f, _s, _hs, _l, _obj) {
    return void 0;
  }

  accept(visitor) {
    return visitor.visitPrimitiveLiteral(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}

exports.PrimitiveLiteralExpression = PrimitiveLiteralExpression;
PrimitiveLiteralExpression.$undefined = new PrimitiveLiteralExpression(void 0);
PrimitiveLiteralExpression.$null = new PrimitiveLiteralExpression(null);
PrimitiveLiteralExpression.$true = new PrimitiveLiteralExpression(true);
PrimitiveLiteralExpression.$false = new PrimitiveLiteralExpression(false);
PrimitiveLiteralExpression.$empty = new PrimitiveLiteralExpression('');

class HtmlLiteralExpression {
  constructor(parts) {
    this.parts = parts;
  }

  get $kind() {
    return 51
    /* HtmlLiteral */
    ;
  }

  get hasBind() {
    return false;
  }

  get hasUnbind() {
    return false;
  }

  evaluate(f, s, hs, l, c) {
    let result = '';

    for (let i = 0; i < this.parts.length; ++i) {
      const v = this.parts[i].evaluate(f, s, hs, l, c);

      if (v == null) {
        continue;
      }

      result += v;
    }

    return result;
  }

  assign(_f, _s, _hs, _l, _obj, _projection) {
    return void 0;
  }

  accept(visitor) {
    return visitor.visitHtmlLiteral(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}

exports.HtmlLiteralExpression = HtmlLiteralExpression;

class ArrayLiteralExpression {
  constructor(elements) {
    this.elements = elements;
  }

  get $kind() {
    return 17955
    /* ArrayLiteral */
    ;
  }

  get hasBind() {
    return false;
  }

  get hasUnbind() {
    return false;
  }

  evaluate(f, s, hs, l, c) {
    return this.elements.map(e => e.evaluate(f, s, hs, l, c));
  }

  assign(_f, _s, _hs, _l, _obj) {
    return void 0;
  }

  accept(visitor) {
    return visitor.visitArrayLiteral(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}

exports.ArrayLiteralExpression = ArrayLiteralExpression;
ArrayLiteralExpression.$empty = new ArrayLiteralExpression(_kernel.emptyArray);

class ObjectLiteralExpression {
  constructor(keys, values) {
    this.keys = keys;
    this.values = values;
  }

  get $kind() {
    return 17956
    /* ObjectLiteral */
    ;
  }

  get hasBind() {
    return false;
  }

  get hasUnbind() {
    return false;
  }

  evaluate(f, s, hs, l, c) {
    const instance = {};

    for (let i = 0; i < this.keys.length; ++i) {
      instance[this.keys[i]] = this.values[i].evaluate(f, s, hs, l, c);
    }

    return instance;
  }

  assign(_f, _s, _hs, _l, _obj) {
    return void 0;
  }

  accept(visitor) {
    return visitor.visitObjectLiteral(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}

exports.ObjectLiteralExpression = ObjectLiteralExpression;
ObjectLiteralExpression.$empty = new ObjectLiteralExpression(_kernel.emptyArray, _kernel.emptyArray);

class TemplateExpression {
  constructor(cooked, expressions = _kernel.emptyArray) {
    this.cooked = cooked;
    this.expressions = expressions;
  }

  get $kind() {
    return 17958
    /* Template */
    ;
  }

  get hasBind() {
    return false;
  }

  get hasUnbind() {
    return false;
  }

  evaluate(f, s, hs, l, c) {
    let result = this.cooked[0];

    for (let i = 0; i < this.expressions.length; ++i) {
      result += String(this.expressions[i].evaluate(f, s, hs, l, c));
      result += this.cooked[i + 1];
    }

    return result;
  }

  assign(_f, _s, _hs, _l, _obj) {
    return void 0;
  }

  accept(visitor) {
    return visitor.visitTemplate(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}

exports.TemplateExpression = TemplateExpression;
TemplateExpression.$empty = new TemplateExpression(['']);

class TaggedTemplateExpression {
  constructor(cooked, raw, func, expressions = _kernel.emptyArray) {
    this.cooked = cooked;
    this.func = func;
    this.expressions = expressions;
    cooked.raw = raw;
  }

  get $kind() {
    return 1197
    /* TaggedTemplate */
    ;
  }

  get hasBind() {
    return false;
  }

  get hasUnbind() {
    return false;
  }

  evaluate(f, s, hs, l, c) {
    const results = this.expressions.map(e => e.evaluate(f, s, hs, l, c));
    const func = this.func.evaluate(f, s, hs, l, c);

    if (typeof func !== 'function') {
      throw new Error(`Left-hand side of tagged template expression is not a function.`);
    }

    return func(this.cooked, ...results);
  }

  assign(_f, _s, _hs, _l, _obj) {
    return void 0;
  }

  accept(visitor) {
    return visitor.visitTaggedTemplate(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}

exports.TaggedTemplateExpression = TaggedTemplateExpression;

class ArrayBindingPattern {
  // We'll either have elements, or keys+values, but never all 3
  constructor(elements) {
    this.elements = elements;
  }

  get $kind() {
    return 65556
    /* ArrayBindingPattern */
    ;
  }

  get hasBind() {
    return false;
  }

  get hasUnbind() {
    return false;
  }

  evaluate(_f, _s, _hs, _l, _c) {
    // TODO: this should come after batch
    // as a destructuring expression like [x, y] = value
    //
    // should only trigger change only once:
    // batch(() => {
    //   object.x = value[0]
    //   object.y = value[1]
    // })
    //
    // instead of twice:
    // object.x = value[0]
    // object.y = value[1]
    return void 0;
  }

  assign(_f, _s, _hs, _l, _obj) {
    // TODO
    return void 0;
  }

  accept(visitor) {
    return visitor.visitArrayBindingPattern(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}

exports.ArrayBindingPattern = ArrayBindingPattern;

class ObjectBindingPattern {
  // We'll either have elements, or keys+values, but never all 3
  constructor(keys, values) {
    this.keys = keys;
    this.values = values;
  }

  get $kind() {
    return 65557
    /* ObjectBindingPattern */
    ;
  }

  get hasBind() {
    return false;
  }

  get hasUnbind() {
    return false;
  }

  evaluate(_f, _s, _hs, _l, _c) {
    // TODO
    // similar to array binding ast, this should only come after batch
    // for a single notification per destructing,
    // regardless number of property assignments on the scope binding context
    return void 0;
  }

  assign(_f, _s, _hs, _l, _obj) {
    // TODO
    return void 0;
  }

  accept(visitor) {
    return visitor.visitObjectBindingPattern(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}

exports.ObjectBindingPattern = ObjectBindingPattern;

class BindingIdentifier {
  constructor(name) {
    this.name = name;
  }

  get $kind() {
    return 65558
    /* BindingIdentifier */
    ;
  }

  get hasBind() {
    return false;
  }

  get hasUnbind() {
    return false;
  }

  evaluate(_f, _s, _hs, _l, _c) {
    return this.name;
  }

  accept(visitor) {
    return visitor.visitBindingIdentifier(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}

exports.BindingIdentifier = BindingIdentifier;
const toStringTag = Object.prototype.toString; // https://tc39.github.io/ecma262/#sec-iteration-statements
// https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements

class ForOfStatement {
  constructor(declaration, iterable) {
    this.declaration = declaration;
    this.iterable = iterable;
  }

  get $kind() {
    return 6199
    /* ForOfStatement */
    ;
  }

  get hasBind() {
    return false;
  }

  get hasUnbind() {
    return false;
  }

  evaluate(f, s, hs, l, c) {
    return this.iterable.evaluate(f, s, hs, l, c);
  }

  assign(_f, _s, _hs, _l, _obj) {
    return void 0;
  }

  count(_f, result) {
    switch (toStringTag.call(result)) {
      case '[object Array]':
        return result.length;

      case '[object Map]':
        return result.size;

      case '[object Set]':
        return result.size;

      case '[object Number]':
        return result;

      case '[object Null]':
        return 0;

      case '[object Undefined]':
        return 0;

      default:
        throw new Error(`Cannot count ${toStringTag.call(result)}`);
    }
  } // deepscan-disable-next-line


  iterate(f, result, func) {
    switch (toStringTag.call(result)) {
      case '[object Array]':
        return $array(result, func);

      case '[object Map]':
        return $map(result, func);

      case '[object Set]':
        return $set(result, func);

      case '[object Number]':
        return $number(result, func);

      case '[object Null]':
        return;

      case '[object Undefined]':
        return;

      default:
        throw new Error(`Cannot iterate over ${toStringTag.call(result)}`);
    }
  }

  bind(f, s, hs, b) {
    if (this.iterable.hasBind) {
      this.iterable.bind(f, s, hs, b);
    }
  }

  unbind(f, s, hs, b) {
    if (this.iterable.hasUnbind) {
      this.iterable.unbind(f, s, hs, b);
    }
  }

  accept(visitor) {
    return visitor.visitForOfStatement(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}
/*
* Note: this implementation is far simpler than the one in vCurrent and might be missing important stuff (not sure yet)
* so while this implementation is identical to Template and we could reuse that one, we don't want to lock outselves in to potentially the wrong abstraction
* but this class might be a candidate for removal if it turns out it does provide all we need
*/


exports.ForOfStatement = ForOfStatement;

class Interpolation {
  constructor(parts, expressions = _kernel.emptyArray) {
    this.parts = parts;
    this.expressions = expressions;
    this.isMulti = expressions.length > 1;
    this.firstExpression = expressions[0];
  }

  get $kind() {
    return 24
    /* Interpolation */
    ;
  }

  get hasBind() {
    return false;
  }

  get hasUnbind() {
    return false;
  }

  evaluate(f, s, hs, l, c) {
    if (this.isMulti) {
      let result = this.parts[0];

      for (let i = 0; i < this.expressions.length; ++i) {
        result += String(this.expressions[i].evaluate(f, s, hs, l, c));
        result += this.parts[i + 1];
      }

      return result;
    } else {
      return `${this.parts[0]}${this.firstExpression.evaluate(f, s, hs, l, c)}${this.parts[1]}`;
    }
  }

  assign(_f, _s, _hs, _l, _obj) {
    return void 0;
  }

  accept(visitor) {
    return visitor.visitInterpolation(this);
  }

  toString() {
    return Unparser.unparse(this);
  }

}

exports.Interpolation = Interpolation;

function getFunction(f, obj, name) {
  const func = obj == null ? null : obj[name];

  if (typeof func === 'function') {
    return func;
  }

  if (!(f & 128
  /* mustEvaluate */
  ) && func == null) {
    return null;
  }

  throw new Error(`Expected '${name}' to be a function`);
}

function $array(result, func) {
  for (let i = 0, ii = result.length; i < ii; ++i) {
    func(result, i, result[i]);
  }
}

function $map(result, func) {
  const arr = Array(result.size);
  let i = -1;

  for (const entry of result.entries()) {
    arr[++i] = entry;
  }

  $array(arr, func);
}

function $set(result, func) {
  const arr = Array(result.size);
  let i = -1;

  for (const key of result.keys()) {
    arr[++i] = key;
  }

  $array(arr, func);
}

function $number(result, func) {
  const arr = Array(result);

  for (let i = 0; i < result; ++i) {
    arr[i] = i;
  }

  $array(arr, func);
}
});

;define.alias('@aurelia/runtime/binding/ast.js','@aurelia/runtime/dist/esm/binding/ast.js');
define('@aurelia/runtime/dist/esm/binding/connectable.js',['require','exports','module','../utilities-objects.js','../observation/array-observer.js','../observation/set-observer.js','../observation/map-observer.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.connectable = connectable;
exports.BindingMediator = exports.BindingObserverRecord = void 0;

var _utilitiesObjects = require("../utilities-objects.js");

var _arrayObserver = require("../observation/array-observer.js");

var _setObserver = require("../observation/set-observer.js");

var _mapObserver = require("../observation/map-observer.js");

// TODO: add connect-queue (or something similar) back in when everything else is working, to improve startup time
const slotNames = [];
const versionSlotNames = [];
let lastSlot = -1;

function ensureEnoughSlotNames(currentSlot) {
  if (currentSlot === lastSlot) {
    lastSlot += 5;
    const ii = slotNames.length = versionSlotNames.length = lastSlot + 1;

    for (let i = currentSlot + 1; i < ii; ++i) {
      slotNames[i] = `_o${i}`;
      versionSlotNames[i] = `_v${i}`;
    }
  }
}

ensureEnoughSlotNames(-1);

function observeProperty(obj, key) {
  const observer = this.observerLocator.getObserver(obj, key);
  /* Note: we need to cast here because we can indeed get an accessor instead of an observer,
   *  in which case the call to observer.subscribe will throw. It's not very clean and we can solve this in 2 ways:
   *  1. Fail earlier: only let the locator resolve observers from .getObserver, and throw if no branches are left (e.g. it would otherwise return an accessor)
   *  2. Fail silently (without throwing): give all accessors a no-op subscribe method
   *
   * We'll probably want to implement some global configuration (like a "strict" toggle) so users can pick between enforced correctness vs. ease-of-use
   */

  this.obs.add(observer);
}

function getObserverRecord() {
  const record = new BindingObserverRecord(this);
  (0, _utilitiesObjects.defineHiddenProp)(this, 'obs', record);
  return record;
}

function observeCollection(collection) {
  let obs;

  if (collection instanceof Array) {
    obs = (0, _arrayObserver.getArrayObserver)(collection);
  } else if (collection instanceof Set) {
    obs = (0, _setObserver.getSetObserver)(collection);
  } else if (collection instanceof Map) {
    obs = (0, _mapObserver.getMapObserver)(collection);
  } else {
    throw new Error('Unrecognised collection type.');
  }

  this.obs.add(obs);
}

function noopHandleChange() {
  throw new Error('method "handleChange" not implemented');
}

function noopHandleCollectionChange() {
  throw new Error('method "handleCollectionChange" not implemented');
}

class BindingObserverRecord {
  constructor(binding) {
    this.binding = binding;
    this.version = 0;
    this.count = 0;
    connectable.assignIdTo(this);
  }

  handleChange(value, oldValue, flags) {
    return this.binding.interceptor.handleChange(value, oldValue, flags);
  }

  handleCollectionChange(indexMap, flags) {
    this.binding.interceptor.handleCollectionChange(indexMap, flags);
  }
  /**
   * Add, and subscribe to a given observer
   */


  add(observer) {
    // find the observer.
    const observerSlots = this.count == null ? 0 : this.count;
    let i = observerSlots;

    while (i-- && this[slotNames[i]] !== observer); // if we are not already observing, put the observer in an open slot and subscribe.


    if (i === -1) {
      i = 0;

      while (this[slotNames[i]]) {
        i++;
      }

      this[slotNames[i]] = observer;
      observer.subscribe(this);
      observer[this.id] |= 8
      /* updateTarget */
      ; // increment the slot count.

      if (i === observerSlots) {
        this.count = i + 1;
      }
    }

    this[versionSlotNames[i]] = this.version;
    ensureEnoughSlotNames(i);
  }
  /**
   * Unsubscribe the observers that are not up to date with the record version
   */


  clear(all) {
    const slotCount = this.count;
    let slotName;
    let observer;
    let i = 0;

    if (all === true) {
      for (; i < slotCount; ++i) {
        slotName = slotNames[i];
        observer = this[slotName];

        if (observer != null) {
          this[slotName] = void 0;
          observer.unsubscribe(this);
          observer[this.id] &= ~8
          /* updateTarget */
          ;
        }
      }

      this.count = 0;
    } else {
      for (; i < slotCount; ++i) {
        if (this[versionSlotNames[i]] !== this.version) {
          slotName = slotNames[i];
          observer = this[slotName];

          if (observer != null) {
            this[slotName] = void 0;
            observer.unsubscribe(this);
            observer[this.id] &= ~8
            /* updateTarget */
            ;
            this.count--;
          }
        }
      }
    }
  }

}

exports.BindingObserverRecord = BindingObserverRecord;

function connectableDecorator(target) {
  const proto = target.prototype;
  (0, _utilitiesObjects.ensureProto)(proto, 'observeProperty', observeProperty, true);
  (0, _utilitiesObjects.ensureProto)(proto, 'observeCollection', observeCollection, true);
  (0, _utilitiesObjects.def)(proto, 'obs', {
    get: getObserverRecord
  }); // optionally add these two methods to normalize a connectable impl

  (0, _utilitiesObjects.ensureProto)(proto, 'handleChange', noopHandleChange);
  (0, _utilitiesObjects.ensureProto)(proto, 'handleCollectionChange', noopHandleCollectionChange);
  return target;
}

function connectable(target) {
  return target == null ? connectableDecorator : connectableDecorator(target);
}

let idValue = 0;

connectable.assignIdTo = instance => {
  instance.id = ++idValue;
}; // @connectable


class BindingMediator {
  constructor(key, binding, observerLocator, locator) {
    this.key = key;
    this.binding = binding;
    this.observerLocator = observerLocator;
    this.locator = locator;
    this.interceptor = this;
    connectable.assignIdTo(this);
  }

  $bind(flags, scope, hostScope, projection) {
    throw new Error('Method not implemented.');
  }

  $unbind(flags) {
    throw new Error('Method not implemented.');
  }

  handleChange(newValue, previousValue, flags) {
    this.binding[this.key](newValue, previousValue, flags);
  }

}

exports.BindingMediator = BindingMediator;
connectableDecorator(BindingMediator);
});

;define.alias('@aurelia/runtime/binding/connectable.js','@aurelia/runtime/dist/esm/binding/connectable.js');
define('@aurelia/runtime/dist/esm/binding/expression-parser.js',['require','exports','module','@aurelia/kernel','./ast.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.parseExpression = parseExpression;
exports.parse = parse;
exports.ParserState = exports.BindingType = exports.Precedence = exports.Access = exports.Char = exports.ExpressionParser = exports.IExpressionParser = void 0;

var _kernel = require("@aurelia/kernel");

var _ast = require("./ast.js");

const IExpressionParser = _kernel.DI.createInterface('IExpressionParser', x => x.singleton(ExpressionParser));

exports.IExpressionParser = IExpressionParser;

class ExpressionParser {
  constructor() {
    this.expressionLookup = Object.create(null);
    this.forOfLookup = Object.create(null);
    this.interpolationLookup = Object.create(null);
  }

  parse(expression, bindingType) {
    switch (bindingType) {
      case 2048
      /* Interpolation */
      :
        {
          let found = this.interpolationLookup[expression];

          if (found === void 0) {
            found = this.interpolationLookup[expression] = this.$parse(expression, bindingType);
          }

          return found;
        }

      case 539
      /* ForCommand */
      :
        {
          let found = this.forOfLookup[expression];

          if (found === void 0) {
            found = this.forOfLookup[expression] = this.$parse(expression, bindingType);
          }

          return found;
        }

      default:
        {
          // Allow empty strings for normal bindings and those that are empty by default (such as a custom attribute without an equals sign)
          // But don't cache it, because empty strings are always invalid for any other type of binding
          if (expression.length === 0 && bindingType & (53
          /* BindCommand */
          | 49
          /* OneTimeCommand */
          | 50
          /* ToViewCommand */
          )) {
            return _ast.PrimitiveLiteralExpression.$empty;
          }

          let found = this.expressionLookup[expression];

          if (found === void 0) {
            found = this.expressionLookup[expression] = this.$parse(expression, bindingType);
          }

          return found;
        }
    }
  }

  $parse(expression, bindingType) {
    $state.input = expression;
    $state.length = expression.length;
    $state.index = 0;
    $state.currentChar = expression.charCodeAt(0);
    return parse($state, 0
    /* Reset */
    , 61
    /* Variadic */
    , bindingType === void 0 ? 53
    /* BindCommand */
    : bindingType);
  }

}

exports.ExpressionParser = ExpressionParser;
var Char;
exports.Char = Char;

(function (Char) {
  Char[Char["Null"] = 0] = "Null";
  Char[Char["Backspace"] = 8] = "Backspace";
  Char[Char["Tab"] = 9] = "Tab";
  Char[Char["LineFeed"] = 10] = "LineFeed";
  Char[Char["VerticalTab"] = 11] = "VerticalTab";
  Char[Char["FormFeed"] = 12] = "FormFeed";
  Char[Char["CarriageReturn"] = 13] = "CarriageReturn";
  Char[Char["Space"] = 32] = "Space";
  Char[Char["Exclamation"] = 33] = "Exclamation";
  Char[Char["DoubleQuote"] = 34] = "DoubleQuote";
  Char[Char["Dollar"] = 36] = "Dollar";
  Char[Char["Percent"] = 37] = "Percent";
  Char[Char["Ampersand"] = 38] = "Ampersand";
  Char[Char["SingleQuote"] = 39] = "SingleQuote";
  Char[Char["OpenParen"] = 40] = "OpenParen";
  Char[Char["CloseParen"] = 41] = "CloseParen";
  Char[Char["Asterisk"] = 42] = "Asterisk";
  Char[Char["Plus"] = 43] = "Plus";
  Char[Char["Comma"] = 44] = "Comma";
  Char[Char["Minus"] = 45] = "Minus";
  Char[Char["Dot"] = 46] = "Dot";
  Char[Char["Slash"] = 47] = "Slash";
  Char[Char["Semicolon"] = 59] = "Semicolon";
  Char[Char["Backtick"] = 96] = "Backtick";
  Char[Char["OpenBracket"] = 91] = "OpenBracket";
  Char[Char["Backslash"] = 92] = "Backslash";
  Char[Char["CloseBracket"] = 93] = "CloseBracket";
  Char[Char["Caret"] = 94] = "Caret";
  Char[Char["Underscore"] = 95] = "Underscore";
  Char[Char["OpenBrace"] = 123] = "OpenBrace";
  Char[Char["Bar"] = 124] = "Bar";
  Char[Char["CloseBrace"] = 125] = "CloseBrace";
  Char[Char["Colon"] = 58] = "Colon";
  Char[Char["LessThan"] = 60] = "LessThan";
  Char[Char["Equals"] = 61] = "Equals";
  Char[Char["GreaterThan"] = 62] = "GreaterThan";
  Char[Char["Question"] = 63] = "Question";
  Char[Char["Zero"] = 48] = "Zero";
  Char[Char["One"] = 49] = "One";
  Char[Char["Two"] = 50] = "Two";
  Char[Char["Three"] = 51] = "Three";
  Char[Char["Four"] = 52] = "Four";
  Char[Char["Five"] = 53] = "Five";
  Char[Char["Six"] = 54] = "Six";
  Char[Char["Seven"] = 55] = "Seven";
  Char[Char["Eight"] = 56] = "Eight";
  Char[Char["Nine"] = 57] = "Nine";
  Char[Char["UpperA"] = 65] = "UpperA";
  Char[Char["UpperB"] = 66] = "UpperB";
  Char[Char["UpperC"] = 67] = "UpperC";
  Char[Char["UpperD"] = 68] = "UpperD";
  Char[Char["UpperE"] = 69] = "UpperE";
  Char[Char["UpperF"] = 70] = "UpperF";
  Char[Char["UpperG"] = 71] = "UpperG";
  Char[Char["UpperH"] = 72] = "UpperH";
  Char[Char["UpperI"] = 73] = "UpperI";
  Char[Char["UpperJ"] = 74] = "UpperJ";
  Char[Char["UpperK"] = 75] = "UpperK";
  Char[Char["UpperL"] = 76] = "UpperL";
  Char[Char["UpperM"] = 77] = "UpperM";
  Char[Char["UpperN"] = 78] = "UpperN";
  Char[Char["UpperO"] = 79] = "UpperO";
  Char[Char["UpperP"] = 80] = "UpperP";
  Char[Char["UpperQ"] = 81] = "UpperQ";
  Char[Char["UpperR"] = 82] = "UpperR";
  Char[Char["UpperS"] = 83] = "UpperS";
  Char[Char["UpperT"] = 84] = "UpperT";
  Char[Char["UpperU"] = 85] = "UpperU";
  Char[Char["UpperV"] = 86] = "UpperV";
  Char[Char["UpperW"] = 87] = "UpperW";
  Char[Char["UpperX"] = 88] = "UpperX";
  Char[Char["UpperY"] = 89] = "UpperY";
  Char[Char["UpperZ"] = 90] = "UpperZ";
  Char[Char["LowerA"] = 97] = "LowerA";
  Char[Char["LowerB"] = 98] = "LowerB";
  Char[Char["LowerC"] = 99] = "LowerC";
  Char[Char["LowerD"] = 100] = "LowerD";
  Char[Char["LowerE"] = 101] = "LowerE";
  Char[Char["LowerF"] = 102] = "LowerF";
  Char[Char["LowerG"] = 103] = "LowerG";
  Char[Char["LowerH"] = 104] = "LowerH";
  Char[Char["LowerI"] = 105] = "LowerI";
  Char[Char["LowerJ"] = 106] = "LowerJ";
  Char[Char["LowerK"] = 107] = "LowerK";
  Char[Char["LowerL"] = 108] = "LowerL";
  Char[Char["LowerM"] = 109] = "LowerM";
  Char[Char["LowerN"] = 110] = "LowerN";
  Char[Char["LowerO"] = 111] = "LowerO";
  Char[Char["LowerP"] = 112] = "LowerP";
  Char[Char["LowerQ"] = 113] = "LowerQ";
  Char[Char["LowerR"] = 114] = "LowerR";
  Char[Char["LowerS"] = 115] = "LowerS";
  Char[Char["LowerT"] = 116] = "LowerT";
  Char[Char["LowerU"] = 117] = "LowerU";
  Char[Char["LowerV"] = 118] = "LowerV";
  Char[Char["LowerW"] = 119] = "LowerW";
  Char[Char["LowerX"] = 120] = "LowerX";
  Char[Char["LowerY"] = 121] = "LowerY";
  Char[Char["LowerZ"] = 122] = "LowerZ";
})(Char || (exports.Char = Char = {}));

function unescapeCode(code) {
  switch (code) {
    case 98
    /* LowerB */
    :
      return 8
      /* Backspace */
      ;

    case 116
    /* LowerT */
    :
      return 9
      /* Tab */
      ;

    case 110
    /* LowerN */
    :
      return 10
      /* LineFeed */
      ;

    case 118
    /* LowerV */
    :
      return 11
      /* VerticalTab */
      ;

    case 102
    /* LowerF */
    :
      return 12
      /* FormFeed */
      ;

    case 114
    /* LowerR */
    :
      return 13
      /* CarriageReturn */
      ;

    case 34
    /* DoubleQuote */
    :
      return 34
      /* DoubleQuote */
      ;

    case 39
    /* SingleQuote */
    :
      return 39
      /* SingleQuote */
      ;

    case 92
    /* Backslash */
    :
      return 92
      /* Backslash */
      ;

    default:
      return code;
  }
}

var Access;
exports.Access = Access;

(function (Access) {
  Access[Access["Reset"] = 0] = "Reset";
  Access[Access["Ancestor"] = 511] = "Ancestor";
  Access[Access["This"] = 512] = "This";
  Access[Access["Scope"] = 1024] = "Scope";
  Access[Access["Member"] = 2048] = "Member";
  Access[Access["Keyed"] = 4096] = "Keyed";
})(Access || (exports.Access = Access = {}));

var Precedence;
exports.Precedence = Precedence;

(function (Precedence) {
  Precedence[Precedence["Variadic"] = 61] = "Variadic";
  Precedence[Precedence["Assign"] = 62] = "Assign";
  Precedence[Precedence["Conditional"] = 63] = "Conditional";
  Precedence[Precedence["LogicalOR"] = 64] = "LogicalOR";
  Precedence[Precedence["LogicalAND"] = 128] = "LogicalAND";
  Precedence[Precedence["Equality"] = 192] = "Equality";
  Precedence[Precedence["Relational"] = 256] = "Relational";
  Precedence[Precedence["Additive"] = 320] = "Additive";
  Precedence[Precedence["Multiplicative"] = 384] = "Multiplicative";
  Precedence[Precedence["Binary"] = 448] = "Binary";
  Precedence[Precedence["LeftHandSide"] = 449] = "LeftHandSide";
  Precedence[Precedence["Primary"] = 450] = "Primary";
  Precedence[Precedence["Unary"] = 451] = "Unary";
})(Precedence || (exports.Precedence = Precedence = {}));

var Token;

(function (Token) {
  Token[Token["EOF"] = 1572864] = "EOF";
  Token[Token["ExpressionTerminal"] = 1048576] = "ExpressionTerminal";
  Token[Token["AccessScopeTerminal"] = 524288] = "AccessScopeTerminal";
  Token[Token["ClosingToken"] = 262144] = "ClosingToken";
  Token[Token["OpeningToken"] = 131072] = "OpeningToken";
  Token[Token["BinaryOp"] = 65536] = "BinaryOp";
  Token[Token["UnaryOp"] = 32768] = "UnaryOp";
  Token[Token["LeftHandSide"] = 16384] = "LeftHandSide";
  Token[Token["StringOrNumericLiteral"] = 12288] = "StringOrNumericLiteral";
  Token[Token["NumericLiteral"] = 8192] = "NumericLiteral";
  Token[Token["StringLiteral"] = 4096] = "StringLiteral";
  Token[Token["IdentifierName"] = 3072] = "IdentifierName";
  Token[Token["Keyword"] = 2048] = "Keyword";
  Token[Token["Identifier"] = 1024] = "Identifier";
  Token[Token["Contextual"] = 512] = "Contextual";
  Token[Token["Precedence"] = 448] = "Precedence";
  Token[Token["Type"] = 63] = "Type";
  Token[Token["FalseKeyword"] = 2048] = "FalseKeyword";
  Token[Token["TrueKeyword"] = 2049] = "TrueKeyword";
  Token[Token["NullKeyword"] = 2050] = "NullKeyword";
  Token[Token["UndefinedKeyword"] = 2051] = "UndefinedKeyword";
  Token[Token["ThisScope"] = 3076] = "ThisScope";
  Token[Token["HostScope"] = 3077] = "HostScope";
  Token[Token["ParentScope"] = 3078] = "ParentScope";
  Token[Token["OpenParen"] = 671751] = "OpenParen";
  Token[Token["OpenBrace"] = 131080] = "OpenBrace";
  Token[Token["Dot"] = 16393] = "Dot";
  Token[Token["CloseBrace"] = 1835018] = "CloseBrace";
  Token[Token["CloseParen"] = 1835019] = "CloseParen";
  Token[Token["Comma"] = 1572876] = "Comma";
  Token[Token["OpenBracket"] = 671757] = "OpenBracket";
  Token[Token["CloseBracket"] = 1835022] = "CloseBracket";
  Token[Token["Colon"] = 1572879] = "Colon";
  Token[Token["Question"] = 1572880] = "Question";
  Token[Token["Ampersand"] = 1572883] = "Ampersand";
  Token[Token["Bar"] = 1572884] = "Bar";
  Token[Token["BarBar"] = 1638549] = "BarBar";
  Token[Token["AmpersandAmpersand"] = 1638614] = "AmpersandAmpersand";
  Token[Token["EqualsEquals"] = 1638679] = "EqualsEquals";
  Token[Token["ExclamationEquals"] = 1638680] = "ExclamationEquals";
  Token[Token["EqualsEqualsEquals"] = 1638681] = "EqualsEqualsEquals";
  Token[Token["ExclamationEqualsEquals"] = 1638682] = "ExclamationEqualsEquals";
  Token[Token["LessThan"] = 1638747] = "LessThan";
  Token[Token["GreaterThan"] = 1638748] = "GreaterThan";
  Token[Token["LessThanEquals"] = 1638749] = "LessThanEquals";
  Token[Token["GreaterThanEquals"] = 1638750] = "GreaterThanEquals";
  Token[Token["InKeyword"] = 1640799] = "InKeyword";
  Token[Token["InstanceOfKeyword"] = 1640800] = "InstanceOfKeyword";
  Token[Token["Plus"] = 623009] = "Plus";
  Token[Token["Minus"] = 623010] = "Minus";
  Token[Token["TypeofKeyword"] = 34851] = "TypeofKeyword";
  Token[Token["VoidKeyword"] = 34852] = "VoidKeyword";
  Token[Token["Asterisk"] = 1638885] = "Asterisk";
  Token[Token["Percent"] = 1638886] = "Percent";
  Token[Token["Slash"] = 1638887] = "Slash";
  Token[Token["Equals"] = 1048616] = "Equals";
  Token[Token["Exclamation"] = 32809] = "Exclamation";
  Token[Token["TemplateTail"] = 540714] = "TemplateTail";
  Token[Token["TemplateContinuation"] = 540715] = "TemplateContinuation";
  Token[Token["OfKeyword"] = 1051180] = "OfKeyword";
})(Token || (Token = {}));

const $false = _ast.PrimitiveLiteralExpression.$false;
const $true = _ast.PrimitiveLiteralExpression.$true;
const $null = _ast.PrimitiveLiteralExpression.$null;
const $undefined = _ast.PrimitiveLiteralExpression.$undefined;
const $this = _ast.AccessThisExpression.$this;
const $host = _ast.AccessThisExpression.$host;
const $parent = _ast.AccessThisExpression.$parent;
var BindingType;
exports.BindingType = BindingType;

(function (BindingType) {
  BindingType[BindingType["None"] = 0] = "None";
  BindingType[BindingType["IgnoreCustomAttr"] = 4096] = "IgnoreCustomAttr";
  BindingType[BindingType["Interpolation"] = 2048] = "Interpolation";
  BindingType[BindingType["IsRef"] = 5376] = "IsRef";
  BindingType[BindingType["IsIterator"] = 512] = "IsIterator";
  BindingType[BindingType["IsCustom"] = 256] = "IsCustom";
  BindingType[BindingType["IsFunction"] = 128] = "IsFunction";
  BindingType[BindingType["IsEvent"] = 64] = "IsEvent";
  BindingType[BindingType["IsProperty"] = 32] = "IsProperty";
  BindingType[BindingType["IsCommand"] = 16] = "IsCommand";
  BindingType[BindingType["IsPropertyCommand"] = 48] = "IsPropertyCommand";
  BindingType[BindingType["IsEventCommand"] = 80] = "IsEventCommand";
  BindingType[BindingType["DelegationStrategyDelta"] = 6] = "DelegationStrategyDelta";
  BindingType[BindingType["Command"] = 15] = "Command";
  BindingType[BindingType["OneTimeCommand"] = 49] = "OneTimeCommand";
  BindingType[BindingType["ToViewCommand"] = 50] = "ToViewCommand";
  BindingType[BindingType["FromViewCommand"] = 51] = "FromViewCommand";
  BindingType[BindingType["TwoWayCommand"] = 52] = "TwoWayCommand";
  BindingType[BindingType["BindCommand"] = 53] = "BindCommand";
  BindingType[BindingType["TriggerCommand"] = 4182] = "TriggerCommand";
  BindingType[BindingType["CaptureCommand"] = 4183] = "CaptureCommand";
  BindingType[BindingType["DelegateCommand"] = 4184] = "DelegateCommand";
  BindingType[BindingType["CallCommand"] = 153] = "CallCommand";
  BindingType[BindingType["OptionsCommand"] = 26] = "OptionsCommand";
  BindingType[BindingType["ForCommand"] = 539] = "ForCommand";
  BindingType[BindingType["CustomCommand"] = 284] = "CustomCommand";
})(BindingType || (exports.BindingType = BindingType = {}));
/* eslint-enable @typescript-eslint/indent */

/** @internal */


class ParserState {
  constructor(input) {
    this.input = input;
    this.index = 0;
    this.startIndex = 0;
    this.lastIndex = 0;
    this.currentToken = 1572864
    /* EOF */
    ;
    this.tokenValue = '';
    this.assignable = true;
    this.length = input.length;
    this.currentChar = input.charCodeAt(0);
  }

  get tokenRaw() {
    return this.input.slice(this.startIndex, this.index);
  }

}

exports.ParserState = ParserState;
const $state = new ParserState('');
/** @internal */

function parseExpression(input, bindingType) {
  $state.input = input;
  $state.length = input.length;
  $state.index = 0;
  $state.currentChar = input.charCodeAt(0);
  return parse($state, 0
  /* Reset */
  , 61
  /* Variadic */
  , bindingType === void 0 ? 53
  /* BindCommand */
  : bindingType);
}
/** @internal */
// This is performance-critical code which follows a subset of the well-known ES spec.
// Knowing the spec, or parsers in general, will help with understanding this code and it is therefore not the
// single source of information for being able to figure it out.
// It generally does not need to change unless the spec changes or spec violations are found, or optimization
// opportunities are found (which would likely not fix these warnings in any case).
// It's therefore not considered to have any tangible impact on the maintainability of the code base.
// For reference, most of the parsing logic is based on: https://tc39.github.io/ecma262/#sec-ecmascript-language-expressions
// eslint-disable-next-line max-lines-per-function


function parse(state, access, minPrecedence, bindingType) {
  if (bindingType === 284
  /* CustomCommand */
  ) {
      return new _ast.CustomExpression(state.input);
    }

  if (state.index === 0) {
    if (bindingType & 2048
    /* Interpolation */
    ) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return parseInterpolation(state);
      }

    nextToken(state);

    if (state.currentToken & 1048576
    /* ExpressionTerminal */
    ) {
        throw new Error(`Invalid start of expression: '${state.input}'`);
      }
  }

  state.assignable = 448
  /* Binary */
  > minPrecedence;
  let result = void 0;

  if (state.currentToken & 32768
  /* UnaryOp */
  ) {
      /** parseUnaryExpression
       * https://tc39.github.io/ecma262/#sec-unary-operators
       *
       * UnaryExpression :
       * 1. LeftHandSideExpression
       * 2. void UnaryExpression
       * 3. typeof UnaryExpression
       * 4. + UnaryExpression
       * 5. - UnaryExpression
       * 6. ! UnaryExpression
       *
       * IsValidAssignmentTarget
       * 2,3,4,5,6 = false
       * 1 = see parseLeftHandSideExpression
       *
       * Note: technically we should throw on ++ / -- / +++ / ---, but there's nothing to gain from that
       */
      const op = TokenValues[state.currentToken & 63
      /* Type */
      ];
      nextToken(state);
      result = new _ast.UnaryExpression(op, parse(state, access, 449
      /* LeftHandSide */
      , bindingType));
      state.assignable = false;
    } else {
    /** parsePrimaryExpression
     * https://tc39.github.io/ecma262/#sec-primary-expression
     *
     * PrimaryExpression :
     * 1. this
     * 2. IdentifierName
     * 3. Literal
     * 4. ArrayLiteralExpression
     * 5. ObjectLiteralExpression
     * 6. TemplateLiteral
     * 7. ParenthesizedExpression
     *
     * Literal :
     * NullLiteral
     * BooleanLiteral
     * NumericLiteral
     * StringLiteral
     *
     * ParenthesizedExpression :
     * ( AssignmentExpression )
     *
     * IsValidAssignmentTarget
     * 1,3,4,5,6,7 = false
     * 2 = true
     */
    primary: switch (state.currentToken) {
      case 3078
      /* ParentScope */
      :
        // $parent
        state.assignable = false;

        do {
          nextToken(state);
          access++; // ancestor

          if (consumeOpt(state, 16393
          /* Dot */
          )) {
            if (state.currentToken === 16393
            /* Dot */
            ) {
                throw new Error(`Double dot and spread operators are not supported: '${state.input}'`);
              } else if (state.currentToken === 1572864
            /* EOF */
            ) {
                throw new Error(`Expected identifier: '${state.input}'`);
              }
          } else if (state.currentToken & 524288
          /* AccessScopeTerminal */
          ) {
              const ancestor = access & 511
              /* Ancestor */
              ;
              result = ancestor === 0 ? $this : ancestor === 1 ? $parent : new _ast.AccessThisExpression(ancestor);
              access = 512
              /* This */
              ;
              break primary;
            } else {
            throw new Error(`Invalid member expression: '${state.input}'`);
          }
        } while (state.currentToken === 3078
        /* ParentScope */
        );

      // falls through

      case 1024
      /* Identifier */
      :
        // identifier
        if (bindingType & 512
        /* IsIterator */
        ) {
            result = new _ast.BindingIdentifier(state.tokenValue);
          } else {
          result = new _ast.AccessScopeExpression(state.tokenValue, access & 511
          /* Ancestor */
          );
          access = 1024
          /* Scope */
          ;
        }

        state.assignable = true;
        nextToken(state);
        break;

      case 3076
      /* ThisScope */
      :
        // $this
        state.assignable = false;
        nextToken(state);
        result = $this;
        access = 512
        /* This */
        ;
        break;

      case 3077
      /* HostScope */
      :
        // $host
        state.assignable = false;
        nextToken(state);
        result = $host;
        access = 512
        /* This */
        ;
        break;

      case 671751
      /* OpenParen */
      :
        // parenthesized expression
        nextToken(state);
        result = parse(state, 0
        /* Reset */
        , 62
        /* Assign */
        , bindingType);
        consume(state, 1835019
        /* CloseParen */
        );
        access = 0
        /* Reset */
        ;
        break;

      case 671757
      /* OpenBracket */
      :
        result = parseArrayLiteralExpression(state, access, bindingType);
        access = 0
        /* Reset */
        ;
        break;

      case 131080
      /* OpenBrace */
      :
        result = parseObjectLiteralExpression(state, bindingType);
        access = 0
        /* Reset */
        ;
        break;

      case 540714
      /* TemplateTail */
      :
        result = new _ast.TemplateExpression([state.tokenValue]);
        state.assignable = false;
        nextToken(state);
        access = 0
        /* Reset */
        ;
        break;

      case 540715
      /* TemplateContinuation */
      :
        result = parseTemplate(state, access, bindingType, result, false);
        access = 0
        /* Reset */
        ;
        break;

      case 4096
      /* StringLiteral */
      :
      case 8192
      /* NumericLiteral */
      :
        result = new _ast.PrimitiveLiteralExpression(state.tokenValue);
        state.assignable = false;
        nextToken(state);
        access = 0
        /* Reset */
        ;
        break;

      case 2050
      /* NullKeyword */
      :
      case 2051
      /* UndefinedKeyword */
      :
      case 2049
      /* TrueKeyword */
      :
      case 2048
      /* FalseKeyword */
      :
        result = TokenValues[state.currentToken & 63
        /* Type */
        ];
        state.assignable = false;
        nextToken(state);
        access = 0
        /* Reset */
        ;
        break;

      default:
        if (state.index >= state.length) {
          throw new Error(`Unexpected end of expression: '${state.input}'`);
        } else {
          throw new Error(`Unconsumed token: '${state.input}'`);
        }

    }

    if (bindingType & 512
    /* IsIterator */
    ) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return parseForOfStatement(state, result);
      }

    if (449
    /* LeftHandSide */
    < minPrecedence) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return result;
    }
    /** parseMemberExpression (Token.Dot, Token.OpenBracket, Token.TemplateContinuation)
     * MemberExpression :
     * 1. PrimaryExpression
     * 2. MemberExpression [ AssignmentExpression ]
     * 3. MemberExpression . IdentifierName
     * 4. MemberExpression TemplateLiteral
     *
     * IsValidAssignmentTarget
     * 1,4 = false
     * 2,3 = true
     *
     *
     * parseCallExpression (Token.OpenParen)
     * CallExpression :
     * 1. MemberExpression Arguments
     * 2. CallExpression Arguments
     * 3. CallExpression [ AssignmentExpression ]
     * 4. CallExpression . IdentifierName
     * 5. CallExpression TemplateLiteral
     *
     * IsValidAssignmentTarget
     * 1,2,5 = false
     * 3,4 = true
     */


    let name = state.tokenValue;

    while ((state.currentToken & 16384
    /* LeftHandSide */
    ) > 0) {
      const args = [];
      let strings;

      switch (state.currentToken) {
        case 16393
        /* Dot */
        :
          state.assignable = true;
          nextToken(state);

          if ((state.currentToken & 3072
          /* IdentifierName */
          ) === 0) {
            throw new Error(`Expected identifier: '${state.input}'`);
          }

          name = state.tokenValue;
          nextToken(state); // Change $This to $Scope, change $Scope to $Member, keep $Member as-is, change $Keyed to $Member, disregard other flags

          access = (access & (512
          /* This */
          | 1024
          /* Scope */
          )) << 1 | access & 2048
          /* Member */
          | (access & 4096
          /* Keyed */
          ) >> 1;

          if (state.currentToken === 671751
          /* OpenParen */
          ) {
              if (access === 0
              /* Reset */
              ) {
                  // if the left hand side is a literal, make sure we parse a CallMemberExpression
                  access = 2048
                  /* Member */
                  ;
                }

              continue;
            }

          if (access & 1024
          /* Scope */
          ) {
              result = new _ast.AccessScopeExpression(name, result.ancestor, result === $host);
            } else {
            // if it's not $Scope, it's $Member
            result = new _ast.AccessMemberExpression(result, name);
          }

          continue;

        case 671757
        /* OpenBracket */
        :
          state.assignable = true;
          nextToken(state);
          access = 4096
          /* Keyed */
          ;
          result = new _ast.AccessKeyedExpression(result, parse(state, 0
          /* Reset */
          , 62
          /* Assign */
          , bindingType));
          consume(state, 1835022
          /* CloseBracket */
          );
          break;

        case 671751
        /* OpenParen */
        :
          state.assignable = false;
          nextToken(state);

          while (state.currentToken !== 1835019
          /* CloseParen */
          ) {
            args.push(parse(state, 0
            /* Reset */
            , 62
            /* Assign */
            , bindingType));

            if (!consumeOpt(state, 1572876
            /* Comma */
            )) {
              break;
            }
          }

          consume(state, 1835019
          /* CloseParen */
          );

          if (access & 1024
          /* Scope */
          ) {
              result = new _ast.CallScopeExpression(name, args, result.ancestor, result === $host);
            } else if (access & 2048
          /* Member */
          ) {
              result = new _ast.CallMemberExpression(result, name, args);
            } else {
            result = new _ast.CallFunctionExpression(result, args);
          }

          access = 0;
          break;

        case 540714
        /* TemplateTail */
        :
          state.assignable = false;
          strings = [state.tokenValue];
          result = new _ast.TaggedTemplateExpression(strings, strings, result);
          nextToken(state);
          break;

        case 540715
        /* TemplateContinuation */
        :
          result = parseTemplate(state, access, bindingType, result, true);

        default:
      }
    }
  }

  if (448
  /* Binary */
  < minPrecedence) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return result;
  }
  /** parseBinaryExpression
   * https://tc39.github.io/ecma262/#sec-multiplicative-operators
   *
   * MultiplicativeExpression : (local precedence 6)
   * UnaryExpression
   * MultiplicativeExpression * / % UnaryExpression
   *
   * AdditiveExpression : (local precedence 5)
   * MultiplicativeExpression
   * AdditiveExpression + - MultiplicativeExpression
   *
   * RelationalExpression : (local precedence 4)
   * AdditiveExpression
   * RelationalExpression < > <= >= instanceof in AdditiveExpression
   *
   * EqualityExpression : (local precedence 3)
   * RelationalExpression
   * EqualityExpression == != === !== RelationalExpression
   *
   * LogicalANDExpression : (local precedence 2)
   * EqualityExpression
   * LogicalANDExpression && EqualityExpression
   *
   * LogicalORExpression : (local precedence 1)
   * LogicalANDExpression
   * LogicalORExpression || LogicalANDExpression
   */


  while ((state.currentToken & 65536
  /* BinaryOp */
  ) > 0) {
    const opToken = state.currentToken;

    if ((opToken & 448
    /* Precedence */
    ) <= minPrecedence) {
      break;
    }

    nextToken(state);
    result = new _ast.BinaryExpression(TokenValues[opToken & 63
    /* Type */
    ], result, parse(state, access, opToken & 448
    /* Precedence */
    , bindingType));
    state.assignable = false;
  }

  if (63
  /* Conditional */
  < minPrecedence) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return result;
  }
  /**
   * parseConditionalExpression
   * https://tc39.github.io/ecma262/#prod-ConditionalExpression
   *
   * ConditionalExpression :
   * 1. BinaryExpression
   * 2. BinaryExpression ? AssignmentExpression : AssignmentExpression
   *
   * IsValidAssignmentTarget
   * 1,2 = false
   */


  if (consumeOpt(state, 1572880
  /* Question */
  )) {
    const yes = parse(state, access, 62
    /* Assign */
    , bindingType);
    consume(state, 1572879
    /* Colon */
    );
    result = new _ast.ConditionalExpression(result, yes, parse(state, access, 62
    /* Assign */
    , bindingType));
    state.assignable = false;
  }

  if (62
  /* Assign */
  < minPrecedence) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return result;
  }
  /** parseAssignmentExpression
   * https://tc39.github.io/ecma262/#prod-AssignmentExpression
   * Note: AssignmentExpression here is equivalent to ES Expression because we don't parse the comma operator
   *
   * AssignmentExpression :
   * 1. ConditionalExpression
   * 2. LeftHandSideExpression = AssignmentExpression
   *
   * IsValidAssignmentTarget
   * 1,2 = false
   */


  if (consumeOpt(state, 1048616
  /* Equals */
  )) {
    if (!state.assignable) {
      throw new Error(`Left hand side of expression is not assignable: '${state.input}'`);
    }

    result = new _ast.AssignExpression(result, parse(state, access, 62
    /* Assign */
    , bindingType));
  }

  if (61
  /* Variadic */
  < minPrecedence) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return result;
  }
  /** parseValueConverter
   */


  while (consumeOpt(state, 1572884
  /* Bar */
  )) {
    if (state.currentToken === 1572864
    /* EOF */
    ) {
        throw new Error(`Expected identifier to come after ValueConverter operator: '${state.input}'`);
      }

    const name = state.tokenValue;
    nextToken(state);
    const args = new Array();

    while (consumeOpt(state, 1572879
    /* Colon */
    )) {
      args.push(parse(state, access, 62
      /* Assign */
      , bindingType));
    }

    result = new _ast.ValueConverterExpression(result, name, args);
  }
  /** parseBindingBehavior
   */


  while (consumeOpt(state, 1572883
  /* Ampersand */
  )) {
    if (state.currentToken === 1572864
    /* EOF */
    ) {
        throw new Error(`Expected identifier to come after BindingBehavior operator: '${state.input}'`);
      }

    const name = state.tokenValue;
    nextToken(state);
    const args = new Array();

    while (consumeOpt(state, 1572879
    /* Colon */
    )) {
      args.push(parse(state, access, 62
      /* Assign */
      , bindingType));
    }

    result = new _ast.BindingBehaviorExpression(result, name, args);
  }

  if (state.currentToken !== 1572864
  /* EOF */
  ) {
      if (bindingType & 2048
      /* Interpolation */
      ) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return result;
        }

      if (state.tokenRaw === 'of') {
        throw new Error(`Unexpected keyword "of": '${state.input}'`);
      }

      throw new Error(`Unconsumed token: '${state.input}'`);
    } // eslint-disable-next-line @typescript-eslint/no-explicit-any


  return result;
}
/**
 * parseArrayLiteralExpression
 * https://tc39.github.io/ecma262/#prod-ArrayLiteralExpression
 *
 * ArrayLiteralExpression :
 * [ Elision(opt) ]
 * [ ElementList ]
 * [ ElementList, Elision(opt) ]
 *
 * ElementList :
 * Elision(opt) AssignmentExpression
 * ElementList, Elision(opt) AssignmentExpression
 *
 * Elision :
 * ,
 * Elision ,
 */


function parseArrayLiteralExpression(state, access, bindingType) {
  nextToken(state);
  const elements = new Array();

  while (state.currentToken !== 1835022
  /* CloseBracket */
  ) {
    if (consumeOpt(state, 1572876
    /* Comma */
    )) {
      elements.push($undefined);

      if (state.currentToken === 1835022
      /* CloseBracket */
      ) {
          break;
        }
    } else {
      elements.push(parse(state, access, 62
      /* Assign */
      , bindingType & ~512
      /* IsIterator */
      ));

      if (consumeOpt(state, 1572876
      /* Comma */
      )) {
        if (state.currentToken === 1835022
        /* CloseBracket */
        ) {
            break;
          }
      } else {
        break;
      }
    }
  }

  consume(state, 1835022
  /* CloseBracket */
  );

  if (bindingType & 512
  /* IsIterator */
  ) {
      return new _ast.ArrayBindingPattern(elements);
    } else {
    state.assignable = false;
    return new _ast.ArrayLiteralExpression(elements);
  }
}

function parseForOfStatement(state, result) {
  if ((result.$kind & 65536
  /* IsForDeclaration */
  ) === 0) {
    throw new Error(`Invalid BindingIdentifier at left hand side of "of": '${state.input}'`);
  }

  if (state.currentToken !== 1051180
  /* OfKeyword */
  ) {
      throw new Error(`Invalid BindingIdentifier at left hand side of "of": '${state.input}'`);
    }

  nextToken(state);
  const declaration = result;
  const statement = parse(state, 0
  /* Reset */
  , 61
  /* Variadic */
  , 0
  /* None */
  );
  return new _ast.ForOfStatement(declaration, statement);
}
/**
 * parseObjectLiteralExpression
 * https://tc39.github.io/ecma262/#prod-Literal
 *
 * ObjectLiteralExpression :
 * { }
 * { PropertyDefinitionList }
 *
 * PropertyDefinitionList :
 * PropertyDefinition
 * PropertyDefinitionList, PropertyDefinition
 *
 * PropertyDefinition :
 * IdentifierName
 * PropertyName : AssignmentExpression
 *
 * PropertyName :
 * IdentifierName
 * StringLiteral
 * NumericLiteral
 */


function parseObjectLiteralExpression(state, bindingType) {
  const keys = new Array();
  const values = new Array();
  nextToken(state);

  while (state.currentToken !== 1835018
  /* CloseBrace */
  ) {
    keys.push(state.tokenValue); // Literal = mandatory colon

    if (state.currentToken & 12288
    /* StringOrNumericLiteral */
    ) {
        nextToken(state);
        consume(state, 1572879
        /* Colon */
        );
        values.push(parse(state, 0
        /* Reset */
        , 62
        /* Assign */
        , bindingType & ~512
        /* IsIterator */
        ));
      } else if (state.currentToken & 3072
    /* IdentifierName */
    ) {
        // IdentifierName = optional colon
        const {
          currentChar,
          currentToken,
          index
        } = state;
        nextToken(state);

        if (consumeOpt(state, 1572879
        /* Colon */
        )) {
          values.push(parse(state, 0
          /* Reset */
          , 62
          /* Assign */
          , bindingType & ~512
          /* IsIterator */
          ));
        } else {
          // Shorthand
          state.currentChar = currentChar;
          state.currentToken = currentToken;
          state.index = index;
          values.push(parse(state, 0
          /* Reset */
          , 450
          /* Primary */
          , bindingType & ~512
          /* IsIterator */
          ));
        }
      } else {
      throw new Error(`Invalid or unsupported property definition in object literal: '${state.input}'`);
    }

    if (state.currentToken !== 1835018
    /* CloseBrace */
    ) {
        consume(state, 1572876
        /* Comma */
        );
      }
  }

  consume(state, 1835018
  /* CloseBrace */
  );

  if (bindingType & 512
  /* IsIterator */
  ) {
      return new _ast.ObjectBindingPattern(keys, values);
    } else {
    state.assignable = false;
    return new _ast.ObjectLiteralExpression(keys, values);
  }
}

function parseInterpolation(state) {
  const parts = [];
  const expressions = [];
  const length = state.length;
  let result = '';

  while (state.index < length) {
    switch (state.currentChar) {
      case 36
      /* Dollar */
      :
        if (state.input.charCodeAt(state.index + 1) === 123
        /* OpenBrace */
        ) {
            parts.push(result);
            result = '';
            state.index += 2;
            state.currentChar = state.input.charCodeAt(state.index);
            nextToken(state);
            const expression = parse(state, 0
            /* Reset */
            , 61
            /* Variadic */
            , 2048
            /* Interpolation */
            );
            expressions.push(expression);
            continue;
          } else {
          result += '$';
        }

        break;

      case 92
      /* Backslash */
      :
        result += String.fromCharCode(unescapeCode(nextChar(state)));
        break;

      default:
        result += String.fromCharCode(state.currentChar);
    }

    nextChar(state);
  }

  if (expressions.length) {
    parts.push(result);
    return new _ast.Interpolation(parts, expressions);
  }

  return null;
}
/**
 * parseTemplateLiteralExpression
 * https://tc39.github.io/ecma262/#prod-Literal
 *
 * TemplateExpression :
 * NoSubstitutionTemplate
 * TemplateHead
 *
 * NoSubstitutionTemplate :
 * ` TemplateCharacters(opt) `
 *
 * TemplateHead :
 * ` TemplateCharacters(opt) ${
 *
 * TemplateSubstitutionTail :
 * TemplateMiddle
 * TemplateTail
 *
 * TemplateMiddle :
 * } TemplateCharacters(opt) ${
 *
 * TemplateTail :
 * } TemplateCharacters(opt) `
 *
 * TemplateCharacters :
 * TemplateCharacter TemplateCharacters(opt)
 *
 * TemplateCharacter :
 * $ [lookahead  {]
 * \ EscapeSequence
 * SourceCharacter (but not one of ` or \ or $)
 */


function parseTemplate(state, access, bindingType, result, tagged) {
  const cooked = [state.tokenValue]; // TODO: properly implement raw parts / decide whether we want this

  consume(state, 540715
  /* TemplateContinuation */
  );
  const expressions = [parse(state, access, 62
  /* Assign */
  , bindingType)];

  while ((state.currentToken = scanTemplateTail(state)) !== 540714
  /* TemplateTail */
  ) {
    cooked.push(state.tokenValue);
    consume(state, 540715
    /* TemplateContinuation */
    );
    expressions.push(parse(state, access, 62
    /* Assign */
    , bindingType));
  }

  cooked.push(state.tokenValue);
  state.assignable = false;

  if (tagged) {
    nextToken(state);
    return new _ast.TaggedTemplateExpression(cooked, cooked, result, expressions);
  } else {
    nextToken(state);
    return new _ast.TemplateExpression(cooked, expressions);
  }
}

function nextToken(state) {
  while (state.index < state.length) {
    state.startIndex = state.index;

    if ((state.currentToken = CharScanners[state.currentChar](state)) != null) {
      // a null token means the character must be skipped
      return;
    }
  }

  state.currentToken = 1572864
  /* EOF */
  ;
}

function nextChar(state) {
  return state.currentChar = state.input.charCodeAt(++state.index);
}

function scanIdentifier(state) {
  // run to the next non-idPart
  while (IdParts[nextChar(state)]);

  const token = KeywordLookup[state.tokenValue = state.tokenRaw];
  return token === undefined ? 1024
  /* Identifier */
  : token;
}

function scanNumber(state, isFloat) {
  let char = state.currentChar;

  if (isFloat === false) {
    do {
      char = nextChar(state);
    } while (char <= 57
    /* Nine */
    && char >= 48
    /* Zero */
    );

    if (char !== 46
    /* Dot */
    ) {
        state.tokenValue = parseInt(state.tokenRaw, 10);
        return 8192
        /* NumericLiteral */
        ;
      } // past this point it's always a float


    char = nextChar(state);

    if (state.index >= state.length) {
      // unless the number ends with a dot - that behaves a little different in native ES expressions
      // but in our AST that behavior has no effect because numbers are always stored in variables
      state.tokenValue = parseInt(state.tokenRaw.slice(0, -1), 10);
      return 8192
      /* NumericLiteral */
      ;
    }
  }

  if (char <= 57
  /* Nine */
  && char >= 48
  /* Zero */
  ) {
      do {
        char = nextChar(state);
      } while (char <= 57
      /* Nine */
      && char >= 48
      /* Zero */
      );
    } else {
    state.currentChar = state.input.charCodeAt(--state.index);
  }

  state.tokenValue = parseFloat(state.tokenRaw);
  return 8192
  /* NumericLiteral */
  ;
}

function scanString(state) {
  const quote = state.currentChar;
  nextChar(state); // Skip initial quote.

  let unescaped = 0;
  const buffer = new Array();
  let marker = state.index;

  while (state.currentChar !== quote) {
    if (state.currentChar === 92
    /* Backslash */
    ) {
        buffer.push(state.input.slice(marker, state.index));
        nextChar(state);
        unescaped = unescapeCode(state.currentChar);
        nextChar(state);
        buffer.push(String.fromCharCode(unescaped));
        marker = state.index;
      } else if (state.index >= state.length) {
      throw new Error(`Unterminated quote in string literal: '${state.input}'`);
    } else {
      nextChar(state);
    }
  }

  const last = state.input.slice(marker, state.index);
  nextChar(state); // Skip terminating quote.
  // Compute the unescaped string value.

  buffer.push(last);
  const unescapedStr = buffer.join('');
  state.tokenValue = unescapedStr;
  return 4096
  /* StringLiteral */
  ;
}

function scanTemplate(state) {
  let tail = true;
  let result = '';

  while (nextChar(state) !== 96
  /* Backtick */
  ) {
    if (state.currentChar === 36
    /* Dollar */
    ) {
        if (state.index + 1 < state.length && state.input.charCodeAt(state.index + 1) === 123
        /* OpenBrace */
        ) {
            state.index++;
            tail = false;
            break;
          } else {
          result += '$';
        }
      } else if (state.currentChar === 92
    /* Backslash */
    ) {
        result += String.fromCharCode(unescapeCode(nextChar(state)));
      } else {
      if (state.index >= state.length) {
        throw new Error(`Unterminated template string: '${state.input}'`);
      }

      result += String.fromCharCode(state.currentChar);
    }
  }

  nextChar(state);
  state.tokenValue = result;

  if (tail) {
    return 540714
    /* TemplateTail */
    ;
  }

  return 540715
  /* TemplateContinuation */
  ;
}

function scanTemplateTail(state) {
  if (state.index >= state.length) {
    throw new Error(`Unterminated template string: '${state.input}'`);
  }

  state.index--;
  return scanTemplate(state);
}

function consumeOpt(state, token) {
  if (state.currentToken === token) {
    nextToken(state);
    return true;
  }

  return false;
}

function consume(state, token) {
  if (state.currentToken === token) {
    nextToken(state);
  } else {
    throw new Error(`Missing expected token: '${state.input}'`);
  }
}
/**
 * Array for mapping tokens to token values. The indices of the values
 * correspond to the token bits 0-38.
 * For this to work properly, the values in the array must be kept in
 * the same order as the token bits.
 * Usage: TokenValues[token & Token.Type]
 */


const TokenValues = [$false, $true, $null, $undefined, '$this', '$host', '$parent', '(', '{', '.', '}', ')', ',', '[', ']', ':', '?', '\'', '"', '&', '|', '||', '&&', '==', '!=', '===', '!==', '<', '>', '<=', '>=', 'in', 'instanceof', '+', '-', 'typeof', 'void', '*', '%', '/', '=', '!', 540714
/* TemplateTail */
, 540715
/* TemplateContinuation */
, 'of'];
const KeywordLookup = Object.create(null);
KeywordLookup.true = 2049
/* TrueKeyword */
;
KeywordLookup.null = 2050
/* NullKeyword */
;
KeywordLookup.false = 2048
/* FalseKeyword */
;
KeywordLookup.undefined = 2051
/* UndefinedKeyword */
;
KeywordLookup.$this = 3076
/* ThisScope */
;
KeywordLookup.$host = 3077
/* HostScope */
;
KeywordLookup.$parent = 3078
/* ParentScope */
;
KeywordLookup.in = 1640799
/* InKeyword */
;
KeywordLookup.instanceof = 1640800
/* InstanceOfKeyword */
;
KeywordLookup.typeof = 34851
/* TypeofKeyword */
;
KeywordLookup.void = 34852
/* VoidKeyword */
;
KeywordLookup.of = 1051180
/* OfKeyword */
;
/**
 * Ranges of code points in pairs of 2 (eg 0x41-0x5B, 0x61-0x7B, ...) where the second value is not inclusive (5-7 means 5 and 6)
 * Single values are denoted by the second value being a 0
 *
 * Copied from output generated with "node build/generate-unicode.js"
 *
 * See also: https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF
 */

const codes = {
  /* [$0-9A-Za_a-z] */
  AsciiIdPart: [0x24, 0, 0x30, 0x3A, 0x41, 0x5B, 0x5F, 0, 0x61, 0x7B],
  IdStart:
  /* IdentifierStart */
  [0x24, 0, 0x41, 0x5B, 0x5F, 0, 0x61, 0x7B, 0xAA, 0, 0xBA, 0, 0xC0, 0xD7, 0xD8, 0xF7, 0xF8, 0x2B9, 0x2E0, 0x2E5, 0x1D00, 0x1D26, 0x1D2C, 0x1D5D, 0x1D62, 0x1D66, 0x1D6B, 0x1D78, 0x1D79, 0x1DBF, 0x1E00, 0x1F00, 0x2071, 0, 0x207F, 0, 0x2090, 0x209D, 0x212A, 0x212C, 0x2132, 0, 0x214E, 0, 0x2160, 0x2189, 0x2C60, 0x2C80, 0xA722, 0xA788, 0xA78B, 0xA7AF, 0xA7B0, 0xA7B8, 0xA7F7, 0xA800, 0xAB30, 0xAB5B, 0xAB5C, 0xAB65, 0xFB00, 0xFB07, 0xFF21, 0xFF3B, 0xFF41, 0xFF5B],
  Digit:
  /* DecimalNumber */
  [0x30, 0x3A],
  Skip:
  /* Skippable */
  [0, 0x21, 0x7F, 0xA1]
};
/**
 * Decompress the ranges into an array of numbers so that the char code
 * can be used as an index to the lookup
 */

function decompress(lookup, $set, compressed, value) {
  const rangeCount = compressed.length;

  for (let i = 0; i < rangeCount; i += 2) {
    const start = compressed[i];
    let end = compressed[i + 1];
    end = end > 0 ? end : start + 1;

    if (lookup) {
      lookup.fill(value, start, end);
    }

    if ($set) {
      for (let ch = start; ch < end; ch++) {
        $set.add(ch);
      }
    }
  }
} // CharFuncLookup functions


function returnToken(token) {
  return s => {
    nextChar(s);
    return token;
  };
}

const unexpectedCharacter = s => {
  throw new Error(`Unexpected character: '${s.input}'`);
};

unexpectedCharacter.notMapped = true; // ASCII IdentifierPart lookup

const AsciiIdParts = new Set();
decompress(null, AsciiIdParts, codes.AsciiIdPart, true); // IdentifierPart lookup

const IdParts = new Uint8Array(0xFFFF); // eslint-disable-next-line @typescript-eslint/no-explicit-any

decompress(IdParts, null, codes.IdStart, 1); // eslint-disable-next-line @typescript-eslint/no-explicit-any

decompress(IdParts, null, codes.Digit, 1); // Character scanning function lookup

const CharScanners = new Array(0xFFFF);
CharScanners.fill(unexpectedCharacter, 0, 0xFFFF);
decompress(CharScanners, null, codes.Skip, s => {
  nextChar(s);
  return null;
});
decompress(CharScanners, null, codes.IdStart, scanIdentifier);
decompress(CharScanners, null, codes.Digit, s => scanNumber(s, false));

CharScanners[34
/* DoubleQuote */
] = CharScanners[39
/* SingleQuote */
] = s => {
  return scanString(s);
};

CharScanners[96
/* Backtick */
] = s => {
  return scanTemplate(s);
}; // !, !=, !==


CharScanners[33
/* Exclamation */
] = s => {
  if (nextChar(s) !== 61
  /* Equals */
  ) {
      return 32809
      /* Exclamation */
      ;
    }

  if (nextChar(s) !== 61
  /* Equals */
  ) {
      return 1638680
      /* ExclamationEquals */
      ;
    }

  nextChar(s);
  return 1638682
  /* ExclamationEqualsEquals */
  ;
}; // =, ==, ===


CharScanners[61
/* Equals */
] = s => {
  if (nextChar(s) !== 61
  /* Equals */
  ) {
      return 1048616
      /* Equals */
      ;
    }

  if (nextChar(s) !== 61
  /* Equals */
  ) {
      return 1638679
      /* EqualsEquals */
      ;
    }

  nextChar(s);
  return 1638681
  /* EqualsEqualsEquals */
  ;
}; // &, &&


CharScanners[38
/* Ampersand */
] = s => {
  if (nextChar(s) !== 38
  /* Ampersand */
  ) {
      return 1572883
      /* Ampersand */
      ;
    }

  nextChar(s);
  return 1638614
  /* AmpersandAmpersand */
  ;
}; // |, ||


CharScanners[124
/* Bar */
] = s => {
  if (nextChar(s) !== 124
  /* Bar */
  ) {
      return 1572884
      /* Bar */
      ;
    }

  nextChar(s);
  return 1638549
  /* BarBar */
  ;
}; // .


CharScanners[46
/* Dot */
] = s => {
  if (nextChar(s) <= 57
  /* Nine */
  && s.currentChar >= 48
  /* Zero */
  ) {
      return scanNumber(s, true);
    }

  return 16393
  /* Dot */
  ;
}; // <, <=


CharScanners[60
/* LessThan */
] = s => {
  if (nextChar(s) !== 61
  /* Equals */
  ) {
      return 1638747
      /* LessThan */
      ;
    }

  nextChar(s);
  return 1638749
  /* LessThanEquals */
  ;
}; // >, >=


CharScanners[62
/* GreaterThan */
] = s => {
  if (nextChar(s) !== 61
  /* Equals */
  ) {
      return 1638748
      /* GreaterThan */
      ;
    }

  nextChar(s);
  return 1638750
  /* GreaterThanEquals */
  ;
};

CharScanners[37
/* Percent */
] = returnToken(1638886
/* Percent */
);
CharScanners[40
/* OpenParen */
] = returnToken(671751
/* OpenParen */
);
CharScanners[41
/* CloseParen */
] = returnToken(1835019
/* CloseParen */
);
CharScanners[42
/* Asterisk */
] = returnToken(1638885
/* Asterisk */
);
CharScanners[43
/* Plus */
] = returnToken(623009
/* Plus */
);
CharScanners[44
/* Comma */
] = returnToken(1572876
/* Comma */
);
CharScanners[45
/* Minus */
] = returnToken(623010
/* Minus */
);
CharScanners[47
/* Slash */
] = returnToken(1638887
/* Slash */
);
CharScanners[58
/* Colon */
] = returnToken(1572879
/* Colon */
);
CharScanners[63
/* Question */
] = returnToken(1572880
/* Question */
);
CharScanners[91
/* OpenBracket */
] = returnToken(671757
/* OpenBracket */
);
CharScanners[93
/* CloseBracket */
] = returnToken(1835022
/* CloseBracket */
);
CharScanners[123
/* OpenBrace */
] = returnToken(131080
/* OpenBrace */
);
CharScanners[125
/* CloseBrace */
] = returnToken(1835018
/* CloseBrace */
);
});

;define.alias('@aurelia/runtime/binding/expression-parser.js','@aurelia/runtime/dist/esm/binding/expression-parser.js');
define('@aurelia/runtime/dist/esm/index.js',['require','exports','module','@aurelia/kernel','@aurelia/platform','./alias.js','./binding/ast.js','./binding/connectable.js','./binding/expression-parser.js','./observation/array-observer.js','./observation/map-observer.js','./observation/set-observer.js','./observation/binding-context.js','./observation/collection-length-observer.js','./observation/computed-observer.js','./observation/dirty-checker.js','./observation/observable.js','./observation/observer-locator.js','./observation/primitive-observer.js','./observation/property-accessor.js','./observation/proxy-observation.js','./observation/setter-observer.js','./observation/signaler.js','./observation/subscriber-collection.js','./observation/connectable-switcher.js','./binding-behavior.js','./value-converter.js','./observation.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.createIndexMap = exports.cloneIndexMap = exports.copyIndexMap = exports.isIndexMap = exports.DelegationStrategy = exports.CollectionKind = exports.AccessorType = exports.LifecycleFlags = exports.BindingMode = exports.valueConverter = exports.ValueConverterDefinition = exports.ValueConverter = exports.BindingBehaviorStrategy = exports.BindingBehaviorFactory = exports.BindingInterceptor = exports.BindingBehaviorDefinition = exports.BindingBehavior = exports.bindingBehavior = exports.ConnectableSwitcher = exports.subscriberCollection = exports.SubscriberRecord = exports.ISignaler = exports.SetterObserver = exports.ProxyObservable = exports.PropertyAccessor = exports.PrimitiveObserver = exports.ObserverLocator = exports.getCollectionObserver = exports.INodeObserverLocator = exports.IObserverLocator = exports.observable = exports.DirtyCheckSettings = exports.DirtyCheckProperty = exports.IDirtyChecker = exports.ComputedObserver = exports.CollectionSizeObserver = exports.CollectionLengthObserver = exports.OverrideContext = exports.Scope = exports.BindingContext = exports.disableSetObservation = exports.enableSetObservation = exports.SetObserver = exports.disableMapObservation = exports.enableMapObservation = exports.MapObserver = exports.synchronizeIndices = exports.applyMutationsToIndices = exports.disableArrayObservation = exports.enableArrayObservation = exports.ArrayIndexObserver = exports.ArrayObserver = exports.ParserState = exports.parse = exports.Precedence = exports.Access = exports.Char = exports.parseExpression = exports.BindingType = exports.IExpressionParser = exports.BindingObserverRecord = exports.BindingMediator = exports.connectable = exports.Interpolation = exports.ForOfStatement = exports.BindingIdentifier = exports.ObjectBindingPattern = exports.ArrayBindingPattern = exports.TaggedTemplateExpression = exports.TemplateExpression = exports.ObjectLiteralExpression = exports.ArrayLiteralExpression = exports.HtmlLiteralExpression = exports.PrimitiveLiteralExpression = exports.UnaryExpression = exports.BinaryExpression = exports.CallMemberExpression = exports.CallScopeExpression = exports.AccessKeyedExpression = exports.AccessMemberExpression = exports.AccessScopeExpression = exports.AccessThisExpression = exports.ConditionalExpression = exports.AssignExpression = exports.ValueConverterExpression = exports.BindingBehaviorExpression = exports.CustomExpression = exports.CallFunctionExpression = exports.ExpressionKind = exports.registerAliases = exports.alias = exports.TaskStatus = exports.TaskQueuePriority = exports.TaskAbortError = exports.Task = exports.TaskQueue = exports.Platform = exports.IPlatform = void 0;

var _kernel = require("@aurelia/kernel");

exports.IPlatform = _kernel.IPlatform;

var _platform = require("@aurelia/platform");

exports.Platform = _platform.Platform;
exports.TaskQueue = _platform.TaskQueue;
exports.Task = _platform.Task;
exports.TaskAbortError = _platform.TaskAbortError;
exports.TaskQueuePriority = _platform.TaskQueuePriority;
exports.TaskStatus = _platform.TaskStatus;

var _alias = require("./alias.js");

exports.alias = _alias.alias;
exports.registerAliases = _alias.registerAliases;

var _ast = require("./binding/ast.js");

exports.ExpressionKind = _ast.ExpressionKind;
exports.CallFunctionExpression = _ast.CallFunctionExpression;
exports.CustomExpression = _ast.CustomExpression;
exports.BindingBehaviorExpression = _ast.BindingBehaviorExpression;
exports.ValueConverterExpression = _ast.ValueConverterExpression;
exports.AssignExpression = _ast.AssignExpression;
exports.ConditionalExpression = _ast.ConditionalExpression;
exports.AccessThisExpression = _ast.AccessThisExpression;
exports.AccessScopeExpression = _ast.AccessScopeExpression;
exports.AccessMemberExpression = _ast.AccessMemberExpression;
exports.AccessKeyedExpression = _ast.AccessKeyedExpression;
exports.CallScopeExpression = _ast.CallScopeExpression;
exports.CallMemberExpression = _ast.CallMemberExpression;
exports.BinaryExpression = _ast.BinaryExpression;
exports.UnaryExpression = _ast.UnaryExpression;
exports.PrimitiveLiteralExpression = _ast.PrimitiveLiteralExpression;
exports.HtmlLiteralExpression = _ast.HtmlLiteralExpression;
exports.ArrayLiteralExpression = _ast.ArrayLiteralExpression;
exports.ObjectLiteralExpression = _ast.ObjectLiteralExpression;
exports.TemplateExpression = _ast.TemplateExpression;
exports.TaggedTemplateExpression = _ast.TaggedTemplateExpression;
exports.ArrayBindingPattern = _ast.ArrayBindingPattern;
exports.ObjectBindingPattern = _ast.ObjectBindingPattern;
exports.BindingIdentifier = _ast.BindingIdentifier;
exports.ForOfStatement = _ast.ForOfStatement;
exports.Interpolation = _ast.Interpolation;

var _connectable = require("./binding/connectable.js");

exports.connectable = _connectable.connectable;
exports.BindingMediator = _connectable.BindingMediator;
exports.BindingObserverRecord = _connectable.BindingObserverRecord;

var _expressionParser = require("./binding/expression-parser.js");

exports.IExpressionParser = _expressionParser.IExpressionParser;
exports.BindingType = _expressionParser.BindingType;
exports.parseExpression = _expressionParser.parseExpression;
exports.Char = _expressionParser.Char;
exports.Access = _expressionParser.Access;
exports.Precedence = _expressionParser.Precedence;
exports.parse = _expressionParser.parse;
exports.ParserState = _expressionParser.ParserState;

var _arrayObserver = require("./observation/array-observer.js");

exports.ArrayObserver = _arrayObserver.ArrayObserver;
exports.ArrayIndexObserver = _arrayObserver.ArrayIndexObserver;
exports.enableArrayObservation = _arrayObserver.enableArrayObservation;
exports.disableArrayObservation = _arrayObserver.disableArrayObservation;
exports.applyMutationsToIndices = _arrayObserver.applyMutationsToIndices;
exports.synchronizeIndices = _arrayObserver.synchronizeIndices;

var _mapObserver = require("./observation/map-observer.js");

exports.MapObserver = _mapObserver.MapObserver;
exports.enableMapObservation = _mapObserver.enableMapObservation;
exports.disableMapObservation = _mapObserver.disableMapObservation;

var _setObserver = require("./observation/set-observer.js");

exports.SetObserver = _setObserver.SetObserver;
exports.enableSetObservation = _setObserver.enableSetObservation;
exports.disableSetObservation = _setObserver.disableSetObservation;

var _bindingContext = require("./observation/binding-context.js");

exports.BindingContext = _bindingContext.BindingContext;
exports.Scope = _bindingContext.Scope;
exports.OverrideContext = _bindingContext.OverrideContext;

var _collectionLengthObserver = require("./observation/collection-length-observer.js");

exports.CollectionLengthObserver = _collectionLengthObserver.CollectionLengthObserver;
exports.CollectionSizeObserver = _collectionLengthObserver.CollectionSizeObserver;

var _computedObserver = require("./observation/computed-observer.js");

exports.ComputedObserver = _computedObserver.ComputedObserver;

var _dirtyChecker = require("./observation/dirty-checker.js");

exports.IDirtyChecker = _dirtyChecker.IDirtyChecker;
exports.DirtyCheckProperty = _dirtyChecker.DirtyCheckProperty;
exports.DirtyCheckSettings = _dirtyChecker.DirtyCheckSettings;

var _observable = require("./observation/observable.js");

exports.observable = _observable.observable;

var _observerLocator = require("./observation/observer-locator.js");

exports.IObserverLocator = _observerLocator.IObserverLocator;
exports.INodeObserverLocator = _observerLocator.INodeObserverLocator;
exports.getCollectionObserver = _observerLocator.getCollectionObserver;
exports.ObserverLocator = _observerLocator.ObserverLocator;

var _primitiveObserver = require("./observation/primitive-observer.js");

exports.PrimitiveObserver = _primitiveObserver.PrimitiveObserver;

var _propertyAccessor = require("./observation/property-accessor.js");

exports.PropertyAccessor = _propertyAccessor.PropertyAccessor;

var _proxyObservation = require("./observation/proxy-observation.js");

exports.ProxyObservable = _proxyObservation.ProxyObservable;

var _setterObserver = require("./observation/setter-observer.js");

exports.SetterObserver = _setterObserver.SetterObserver;

var _signaler = require("./observation/signaler.js");

exports.ISignaler = _signaler.ISignaler;

var _subscriberCollection = require("./observation/subscriber-collection.js");

exports.SubscriberRecord = _subscriberCollection.SubscriberRecord;
exports.subscriberCollection = _subscriberCollection.subscriberCollection;

var _connectableSwitcher = require("./observation/connectable-switcher.js");

exports.ConnectableSwitcher = _connectableSwitcher.ConnectableSwitcher;

var _bindingBehavior = require("./binding-behavior.js");

exports.bindingBehavior = _bindingBehavior.bindingBehavior;
exports.BindingBehavior = _bindingBehavior.BindingBehavior;
exports.BindingBehaviorDefinition = _bindingBehavior.BindingBehaviorDefinition;
exports.BindingInterceptor = _bindingBehavior.BindingInterceptor;
exports.BindingBehaviorFactory = _bindingBehavior.BindingBehaviorFactory;
exports.BindingBehaviorStrategy = _bindingBehavior.BindingBehaviorStrategy;

var _valueConverter = require("./value-converter.js");

exports.ValueConverter = _valueConverter.ValueConverter;
exports.ValueConverterDefinition = _valueConverter.ValueConverterDefinition;
exports.valueConverter = _valueConverter.valueConverter;

var _observation = require("./observation.js");

exports.BindingMode = _observation.BindingMode;
exports.LifecycleFlags = _observation.LifecycleFlags;
exports.AccessorType = _observation.AccessorType;
exports.CollectionKind = _observation.CollectionKind;
exports.DelegationStrategy = _observation.DelegationStrategy;
exports.isIndexMap = _observation.isIndexMap;
exports.copyIndexMap = _observation.copyIndexMap;
exports.cloneIndexMap = _observation.cloneIndexMap;
exports.createIndexMap = _observation.createIndexMap;
});

;define.alias('@aurelia/runtime','@aurelia/runtime/dist/esm/index.js');
define('@aurelia/runtime/dist/esm/observation.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.copyIndexMap = copyIndexMap;
exports.createIndexMap = createIndexMap;
exports.cloneIndexMap = cloneIndexMap;
exports.isIndexMap = isIndexMap;
exports.AccessorType = exports.CollectionKind = exports.DelegationStrategy = exports.SubscriberFlags = exports.LifecycleFlags = exports.BindingMode = void 0;

/*
* Note: the oneTime binding now has a non-zero value for 2 reasons:
*  - plays nicer with bitwise operations (more consistent code, more explicit settings)
*  - allows for potentially having something like BindingMode.oneTime | BindingMode.fromView, where an initial value is set once to the view but updates from the view also propagate back to the view model
*
* Furthermore, the "default" mode would be for simple ".bind" expressions to make it explicit for our logic that the default is being used.
* This essentially adds extra information which binding could use to do smarter things and allows bindingBehaviors that add a mode instead of simply overwriting it
*/
var BindingMode;
exports.BindingMode = BindingMode;

(function (BindingMode) {
  BindingMode[BindingMode["oneTime"] = 1] = "oneTime";
  BindingMode[BindingMode["toView"] = 2] = "toView";
  BindingMode[BindingMode["fromView"] = 4] = "fromView";
  BindingMode[BindingMode["twoWay"] = 6] = "twoWay";
  BindingMode[BindingMode["default"] = 8] = "default";
})(BindingMode || (exports.BindingMode = BindingMode = {}));

var LifecycleFlags;
exports.LifecycleFlags = LifecycleFlags;

(function (LifecycleFlags) {
  LifecycleFlags[LifecycleFlags["none"] = 0] = "none"; // Bitmask for flags that need to be stored on a binding during $bind for mutation
  // callbacks outside of $bind

  LifecycleFlags[LifecycleFlags["persistentBindingFlags"] = 15367] = "persistentBindingFlags";
  LifecycleFlags[LifecycleFlags["allowParentScopeTraversal"] = 1024] = "allowParentScopeTraversal";
  LifecycleFlags[LifecycleFlags["observeLeafPropertiesOnly"] = 2048] = "observeLeafPropertiesOnly";
  LifecycleFlags[LifecycleFlags["targetObserverFlags"] = 12295] = "targetObserverFlags";
  LifecycleFlags[LifecycleFlags["noFlush"] = 4096] = "noFlush";
  LifecycleFlags[LifecycleFlags["persistentTargetObserverQueue"] = 8192] = "persistentTargetObserverQueue";
  LifecycleFlags[LifecycleFlags["bindingStrategy"] = 7] = "bindingStrategy";
  LifecycleFlags[LifecycleFlags["getterSetterStrategy"] = 1] = "getterSetterStrategy";
  LifecycleFlags[LifecycleFlags["proxyStrategy"] = 2] = "proxyStrategy";
  LifecycleFlags[LifecycleFlags["isStrictBindingStrategy"] = 4] = "isStrictBindingStrategy";
  LifecycleFlags[LifecycleFlags["update"] = 24] = "update";
  LifecycleFlags[LifecycleFlags["updateTarget"] = 8] = "updateTarget";
  LifecycleFlags[LifecycleFlags["updateSource"] = 16] = "updateSource";
  LifecycleFlags[LifecycleFlags["from"] = 96] = "from";
  LifecycleFlags[LifecycleFlags["fromBind"] = 32] = "fromBind";
  LifecycleFlags[LifecycleFlags["fromUnbind"] = 64] = "fromUnbind";
  LifecycleFlags[LifecycleFlags["mustEvaluate"] = 128] = "mustEvaluate";
  LifecycleFlags[LifecycleFlags["isTraversingParentScope"] = 256] = "isTraversingParentScope";
  LifecycleFlags[LifecycleFlags["dispose"] = 512] = "dispose";
})(LifecycleFlags || (exports.LifecycleFlags = LifecycleFlags = {}));
/** @internal */


var SubscriberFlags;
exports.SubscriberFlags = SubscriberFlags;

(function (SubscriberFlags) {
  SubscriberFlags[SubscriberFlags["None"] = 0] = "None";
  SubscriberFlags[SubscriberFlags["Subscriber0"] = 1] = "Subscriber0";
  SubscriberFlags[SubscriberFlags["Subscriber1"] = 2] = "Subscriber1";
  SubscriberFlags[SubscriberFlags["Subscriber2"] = 4] = "Subscriber2";
  SubscriberFlags[SubscriberFlags["SubscribersRest"] = 8] = "SubscribersRest";
  SubscriberFlags[SubscriberFlags["Any"] = 15] = "Any";
})(SubscriberFlags || (exports.SubscriberFlags = SubscriberFlags = {}));

var DelegationStrategy;
exports.DelegationStrategy = DelegationStrategy;

(function (DelegationStrategy) {
  DelegationStrategy[DelegationStrategy["none"] = 0] = "none";
  DelegationStrategy[DelegationStrategy["capturing"] = 1] = "capturing";
  DelegationStrategy[DelegationStrategy["bubbling"] = 2] = "bubbling";
})(DelegationStrategy || (exports.DelegationStrategy = DelegationStrategy = {}));

var CollectionKind;
exports.CollectionKind = CollectionKind;

(function (CollectionKind) {
  CollectionKind[CollectionKind["indexed"] = 8] = "indexed";
  CollectionKind[CollectionKind["keyed"] = 4] = "keyed";
  CollectionKind[CollectionKind["array"] = 9] = "array";
  CollectionKind[CollectionKind["map"] = 6] = "map";
  CollectionKind[CollectionKind["set"] = 7] = "set";
})(CollectionKind || (exports.CollectionKind = CollectionKind = {}));

var AccessorType;
exports.AccessorType = AccessorType;

(function (AccessorType) {
  AccessorType[AccessorType["None"] = 0] = "None";
  AccessorType[AccessorType["Observer"] = 1] = "Observer";
  AccessorType[AccessorType["Node"] = 2] = "Node"; // misc characteristic of accessors/observers when update
  //
  // by default, everything is synchronous
  // except changes that are supposed to cause reflow/heavy computation
  // an observer can use this flag to signal binding that don't carelessly tell it to update
  // queue it instead
  // todo: https://gist.github.com/paulirish/5d52fb081b3570c81e3a
  // todo: https://csstriggers.com/

  AccessorType[AccessorType["Layout"] = 4] = "Layout"; // by default, everything is an object
  // eg: a property is accessed on an object
  // unless explicitly not so

  AccessorType[AccessorType["Primtive"] = 8] = "Primtive";
  AccessorType[AccessorType["Array"] = 18] = "Array";
  AccessorType[AccessorType["Set"] = 34] = "Set";
  AccessorType[AccessorType["Map"] = 66] = "Map";
})(AccessorType || (exports.AccessorType = AccessorType = {}));

function copyIndexMap(existing, deletedItems) {
  const {
    length
  } = existing;
  const arr = Array(length);
  let i = 0;

  while (i < length) {
    arr[i] = existing[i];
    ++i;
  }

  if (deletedItems !== void 0) {
    arr.deletedItems = deletedItems.slice(0);
  } else if (existing.deletedItems !== void 0) {
    arr.deletedItems = existing.deletedItems.slice(0);
  } else {
    arr.deletedItems = [];
  }

  arr.isIndexMap = true;
  return arr;
}

function createIndexMap(length = 0) {
  const arr = Array(length);
  let i = 0;

  while (i < length) {
    arr[i] = i++;
  }

  arr.deletedItems = [];
  arr.isIndexMap = true;
  return arr;
}

function cloneIndexMap(indexMap) {
  const clone = indexMap.slice();
  clone.deletedItems = indexMap.deletedItems.slice();
  clone.isIndexMap = true;
  return clone;
}

function isIndexMap(value) {
  return value instanceof Array && value.isIndexMap === true;
}
});

;define.alias('@aurelia/runtime/observation.js','@aurelia/runtime/dist/esm/observation.js');
define('@aurelia/runtime/dist/esm/observation/array-observer.js',['require','exports','module','../observation.js','./collection-length-observer.js','./subscriber-collection.js','../utilities-objects.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.enableArrayObservation = enableArrayObservation;
exports.disableArrayObservation = disableArrayObservation;
exports.getArrayObserver = getArrayObserver;
exports.applyMutationsToIndices = applyMutationsToIndices;
exports.synchronizeIndices = synchronizeIndices;
exports.ArrayIndexObserver = exports.ArrayObserver = void 0;

var _observation = require("../observation.js");

var _collectionLengthObserver = require("./collection-length-observer.js");

var _subscriberCollection = require("./subscriber-collection.js");

var _utilitiesObjects = require("../utilities-objects.js");

const observerLookup = new WeakMap(); // https://tc39.github.io/ecma262/#sec-sortcompare

function sortCompare(x, y) {
  if (x === y) {
    return 0;
  }

  x = x === null ? 'null' : x.toString();
  y = y === null ? 'null' : y.toString();
  return x < y ? -1 : 1;
}

function preSortCompare(x, y) {
  if (x === void 0) {
    if (y === void 0) {
      return 0;
    } else {
      return 1;
    }
  }

  if (y === void 0) {
    return -1;
  }

  return 0;
}

function insertionSort(arr, indexMap, from, to, compareFn) {
  let velement, ielement, vtmp, itmp, order;
  let i, j;

  for (i = from + 1; i < to; i++) {
    velement = arr[i];
    ielement = indexMap[i];

    for (j = i - 1; j >= from; j--) {
      vtmp = arr[j];
      itmp = indexMap[j];
      order = compareFn(vtmp, velement);

      if (order > 0) {
        arr[j + 1] = vtmp;
        indexMap[j + 1] = itmp;
      } else {
        break;
      }
    }

    arr[j + 1] = velement;
    indexMap[j + 1] = ielement;
  }
}

function quickSort(arr, indexMap, from, to, compareFn) {
  let thirdIndex = 0,
      i = 0;
  let v0, v1, v2;
  let i0, i1, i2;
  let c01, c02, c12;
  let vtmp, itmp;
  let vpivot, ipivot, lowEnd, highStart;
  let velement, ielement, order, vtopElement; // eslint-disable-next-line no-constant-condition

  while (true) {
    if (to - from <= 10) {
      insertionSort(arr, indexMap, from, to, compareFn);
      return;
    }

    thirdIndex = from + (to - from >> 1);
    v0 = arr[from];
    i0 = indexMap[from];
    v1 = arr[to - 1];
    i1 = indexMap[to - 1];
    v2 = arr[thirdIndex];
    i2 = indexMap[thirdIndex];
    c01 = compareFn(v0, v1);

    if (c01 > 0) {
      vtmp = v0;
      itmp = i0;
      v0 = v1;
      i0 = i1;
      v1 = vtmp;
      i1 = itmp;
    }

    c02 = compareFn(v0, v2);

    if (c02 >= 0) {
      vtmp = v0;
      itmp = i0;
      v0 = v2;
      i0 = i2;
      v2 = v1;
      i2 = i1;
      v1 = vtmp;
      i1 = itmp;
    } else {
      c12 = compareFn(v1, v2);

      if (c12 > 0) {
        vtmp = v1;
        itmp = i1;
        v1 = v2;
        i1 = i2;
        v2 = vtmp;
        i2 = itmp;
      }
    }

    arr[from] = v0;
    indexMap[from] = i0;
    arr[to - 1] = v2;
    indexMap[to - 1] = i2;
    vpivot = v1;
    ipivot = i1;
    lowEnd = from + 1;
    highStart = to - 1;
    arr[thirdIndex] = arr[lowEnd];
    indexMap[thirdIndex] = indexMap[lowEnd];
    arr[lowEnd] = vpivot;
    indexMap[lowEnd] = ipivot;

    partition: for (i = lowEnd + 1; i < highStart; i++) {
      velement = arr[i];
      ielement = indexMap[i];
      order = compareFn(velement, vpivot);

      if (order < 0) {
        arr[i] = arr[lowEnd];
        indexMap[i] = indexMap[lowEnd];
        arr[lowEnd] = velement;
        indexMap[lowEnd] = ielement;
        lowEnd++;
      } else if (order > 0) {
        do {
          highStart--; // eslint-disable-next-line eqeqeq

          if (highStart == i) {
            break partition;
          }

          vtopElement = arr[highStart];
          order = compareFn(vtopElement, vpivot);
        } while (order > 0);

        arr[i] = arr[highStart];
        indexMap[i] = indexMap[highStart];
        arr[highStart] = velement;
        indexMap[highStart] = ielement;

        if (order < 0) {
          velement = arr[i];
          ielement = indexMap[i];
          arr[i] = arr[lowEnd];
          indexMap[i] = indexMap[lowEnd];
          arr[lowEnd] = velement;
          indexMap[lowEnd] = ielement;
          lowEnd++;
        }
      }
    }

    if (to - highStart < lowEnd - from) {
      quickSort(arr, indexMap, highStart, to, compareFn);
      to = lowEnd;
    } else {
      quickSort(arr, indexMap, from, lowEnd, compareFn);
      from = highStart;
    }
  }
}

const proto = Array.prototype;
const $push = proto.push;
const $unshift = proto.unshift;
const $pop = proto.pop;
const $shift = proto.shift;
const $splice = proto.splice;
const $reverse = proto.reverse;
const $sort = proto.sort;
const native = {
  push: $push,
  unshift: $unshift,
  pop: $pop,
  shift: $shift,
  splice: $splice,
  reverse: $reverse,
  sort: $sort
};
const methods = ['push', 'unshift', 'pop', 'shift', 'splice', 'reverse', 'sort'];
const observe = {
  // https://tc39.github.io/ecma262/#sec-array.prototype.push
  push: function (...args) {
    const o = observerLookup.get(this);

    if (o === void 0) {
      return $push.apply(this, args);
    }

    const len = this.length;
    const argCount = args.length;

    if (argCount === 0) {
      return len;
    }

    this.length = o.indexMap.length = len + argCount;
    let i = len;

    while (i < this.length) {
      this[i] = args[i - len];
      o.indexMap[i] = -2;
      i++;
    }

    o.notify();
    return this.length;
  },
  // https://tc39.github.io/ecma262/#sec-array.prototype.unshift
  unshift: function (...args) {
    const o = observerLookup.get(this);

    if (o === void 0) {
      return $unshift.apply(this, args);
    }

    const argCount = args.length;
    const inserts = new Array(argCount);
    let i = 0;

    while (i < argCount) {
      inserts[i++] = -2;
    }

    $unshift.apply(o.indexMap, inserts);
    const len = $unshift.apply(this, args);
    o.notify();
    return len;
  },
  // https://tc39.github.io/ecma262/#sec-array.prototype.pop
  pop: function () {
    const o = observerLookup.get(this);

    if (o === void 0) {
      return $pop.call(this);
    }

    const indexMap = o.indexMap;
    const element = $pop.call(this); // only mark indices as deleted if they actually existed in the original array

    const index = indexMap.length - 1;

    if (indexMap[index] > -1) {
      indexMap.deletedItems.push(indexMap[index]);
    }

    $pop.call(indexMap);
    o.notify();
    return element;
  },
  // https://tc39.github.io/ecma262/#sec-array.prototype.shift
  shift: function () {
    const o = observerLookup.get(this);

    if (o === void 0) {
      return $shift.call(this);
    }

    const indexMap = o.indexMap;
    const element = $shift.call(this); // only mark indices as deleted if they actually existed in the original array

    if (indexMap[0] > -1) {
      indexMap.deletedItems.push(indexMap[0]);
    }

    $shift.call(indexMap);
    o.notify();
    return element;
  },
  // https://tc39.github.io/ecma262/#sec-array.prototype.splice
  splice: function (...args) {
    const start = args[0];
    const deleteCount = args[1];
    const o = observerLookup.get(this);

    if (o === void 0) {
      return $splice.apply(this, args);
    }

    const len = this.length;
    const relativeStart = start | 0;
    const actualStart = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
    const indexMap = o.indexMap;
    const argCount = args.length;
    const actualDeleteCount = argCount === 0 ? 0 : argCount === 1 ? len - actualStart : deleteCount;

    if (actualDeleteCount > 0) {
      let i = actualStart;
      const to = i + actualDeleteCount;

      while (i < to) {
        if (indexMap[i] > -1) {
          indexMap.deletedItems.push(indexMap[i]);
        }

        i++;
      }
    }

    if (argCount > 2) {
      const itemCount = argCount - 2;
      const inserts = new Array(itemCount);
      let i = 0;

      while (i < itemCount) {
        inserts[i++] = -2;
      }

      $splice.call(indexMap, start, deleteCount, ...inserts);
    } else {
      $splice.apply(indexMap, args);
    }

    const deleted = $splice.apply(this, args);
    o.notify();
    return deleted;
  },
  // https://tc39.github.io/ecma262/#sec-array.prototype.reverse
  reverse: function () {
    const o = observerLookup.get(this);

    if (o === void 0) {
      $reverse.call(this);
      return this;
    }

    const len = this.length;
    const middle = len / 2 | 0;
    let lower = 0;

    while (lower !== middle) {
      const upper = len - lower - 1;
      const lowerValue = this[lower];
      const lowerIndex = o.indexMap[lower];
      const upperValue = this[upper];
      const upperIndex = o.indexMap[upper];
      this[lower] = upperValue;
      o.indexMap[lower] = upperIndex;
      this[upper] = lowerValue;
      o.indexMap[upper] = lowerIndex;
      lower++;
    }

    o.notify();
    return this;
  },
  // https://tc39.github.io/ecma262/#sec-array.prototype.sort
  // https://github.com/v8/v8/blob/master/src/js/array.js
  sort: function (compareFn) {
    const o = observerLookup.get(this);

    if (o === void 0) {
      $sort.call(this, compareFn);
      return this;
    }

    const len = this.length;

    if (len < 2) {
      return this;
    }

    quickSort(this, o.indexMap, 0, len, preSortCompare);
    let i = 0;

    while (i < len) {
      if (this[i] === void 0) {
        break;
      }

      i++;
    }

    if (compareFn === void 0 || typeof compareFn !== 'function'
    /* spec says throw a TypeError, should we do that too? */
    ) {
        compareFn = sortCompare;
      }

    quickSort(this, o.indexMap, 0, i, compareFn);
    o.notify();
    return this;
  }
};

for (const method of methods) {
  (0, _utilitiesObjects.def)(observe[method], 'observing', {
    value: true,
    writable: false,
    configurable: false,
    enumerable: false
  });
}

let enableArrayObservationCalled = false;

function enableArrayObservation() {
  for (const method of methods) {
    if (proto[method].observing !== true) {
      (0, _utilitiesObjects.defineHiddenProp)(proto, method, observe[method]);
    }
  }
}

function disableArrayObservation() {
  for (const method of methods) {
    if (proto[method].observing === true) {
      (0, _utilitiesObjects.defineHiddenProp)(proto, method, native[method]);
    }
  }
}

class ArrayObserver {
  constructor(array) {
    this.type = 18
    /* Array */
    ;

    if (!enableArrayObservationCalled) {
      enableArrayObservationCalled = true;
      enableArrayObservation();
    }

    this.indexObservers = {};
    this.collection = array;
    this.indexMap = (0, _observation.createIndexMap)(array.length);
    this.lenObs = void 0;
    observerLookup.set(array, this);
  }

  notify() {
    const indexMap = this.indexMap;
    const length = this.collection.length;
    this.indexMap = (0, _observation.createIndexMap)(length);
    this.subs.notifyCollection(indexMap, 8
    /* updateTarget */
    );
  }

  getLengthObserver() {
    return this.lenObs ?? (this.lenObs = new _collectionLengthObserver.CollectionLengthObserver(this));
  }

  getIndexObserver(index) {
    var _a; // It's unnecessary to destroy/recreate index observer all the time,
    // so just create once, and add/remove instead


    return (_a = this.indexObservers)[index] ?? (_a[index] = new ArrayIndexObserver(this, index));
  }

}

exports.ArrayObserver = ArrayObserver;

class ArrayIndexObserver {
  constructor(owner, index) {
    this.owner = owner;
    this.index = index;
    this.value = this.getValue();
  }

  getValue() {
    return this.owner.collection[this.index];
  }

  setValue(newValue, flags) {
    if (newValue === this.getValue()) {
      return;
    }

    const arrayObserver = this.owner;
    const index = this.index;
    const indexMap = arrayObserver.indexMap;

    if (indexMap[index] > -1) {
      indexMap.deletedItems.push(indexMap[index]);
    }

    indexMap[index] = -2; // do not need to update current value here
    // as it will be updated inside handle collection change

    arrayObserver.collection[index] = newValue;
    arrayObserver.notify();
  }
  /**
   * From interface `ICollectionSubscriber`
   */


  handleCollectionChange(indexMap, flags) {
    const index = this.index;
    const noChange = indexMap[index] === index;

    if (noChange) {
      return;
    }

    const prevValue = this.value;
    const currValue = this.value = this.getValue(); // hmm

    if (prevValue !== currValue) {
      this.subs.notify(currValue, prevValue, flags);
    }
  }

  subscribe(subscriber) {
    if (this.subs.add(subscriber) && this.subs.count === 1) {
      this.owner.subscribe(this);
    }
  }

  unsubscribe(subscriber) {
    if (this.subs.remove(subscriber) && this.subs.count === 0) {
      this.owner.unsubscribe(this);
    }
  }

}

exports.ArrayIndexObserver = ArrayIndexObserver;
(0, _subscriberCollection.subscriberCollection)(ArrayObserver);
(0, _subscriberCollection.subscriberCollection)(ArrayIndexObserver);

function getArrayObserver(array) {
  let observer = observerLookup.get(array);

  if (observer === void 0) {
    observer = new ArrayObserver(array);
  }

  return observer;
}
/**
 * Applies offsets to the non-negative indices in the IndexMap
 * based on added and deleted items relative to those indices.
 *
 * e.g. turn `[-2, 0, 1]` into `[-2, 1, 2]`, allowing the values at the indices to be
 * used for sorting/reordering items if needed
 */


function applyMutationsToIndices(indexMap) {
  let offset = 0;
  let j = 0;
  const len = indexMap.length;

  for (let i = 0; i < len; ++i) {
    while (indexMap.deletedItems[j] <= i - offset) {
      ++j;
      --offset;
    }

    if (indexMap[i] === -2) {
      ++offset;
    } else {
      indexMap[i] += offset;
    }
  }
}
/**
 * After `applyMutationsToIndices`, this function can be used to reorder items in a derived
 * array (e.g.  the items in the `views` in the repeater are derived from the `items` property)
 */


function synchronizeIndices(items, indexMap) {
  const copy = items.slice();
  const len = indexMap.length;
  let to = 0;
  let from = 0;

  while (to < len) {
    from = indexMap[to];

    if (from !== -2) {
      items[to] = copy[from];
    }

    ++to;
  }
}
});

;define.alias('@aurelia/runtime/observation/array-observer.js','@aurelia/runtime/dist/esm/observation/array-observer.js');
define('@aurelia/runtime/dist/esm/observation/binding-context.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.OverrideContext = exports.Scope = exports.BindingContext = void 0;
const marker = Object.freeze({});

class BindingContext {
  constructor(keyOrObj, value) {
    if (keyOrObj !== void 0) {
      if (value !== void 0) {
        // if value is defined then it's just a property and a value to initialize with
        this[keyOrObj] = value;
      } else {
        // can either be some random object or another bindingContext to clone from
        for (const prop in keyOrObj) {
          if (Object.prototype.hasOwnProperty.call(keyOrObj, prop)) {
            this[prop] = keyOrObj[prop];
          }
        }
      }
    }
  }

  static create(keyOrObj, value) {
    return new BindingContext(keyOrObj, value);
  }

  static get(scope, name, ancestor, flags, hostScope) {
    if (scope == null && hostScope == null) {
      throw new Error(`Scope is ${scope} and HostScope is ${hostScope}.`);
    }

    const hasOtherScope = hostScope !== scope && hostScope != null;
    /* eslint-disable jsdoc/check-indentation */

    /**
     * This fallback is needed to support the following case:
     * <div au-slot="s1">
     *  <let outer-host.bind="$host"></let>
     *  ${outerHost.prop}
     * </div>
     * To enable the `let` binding for 'hostScope', the property is added to `hostScope.overrideContext`. That enables us to use such let binding also inside a repeater.
     * However, as the expression `${outerHost.prop}` does not start with `$host`, it is considered that to evaluate this expression, we don't need the access to hostScope.
     * This artifact raises the need for this fallback.
     */

    /* eslint-enable jsdoc/check-indentation */

    let context = chooseContext(scope, name, ancestor);

    if (context !== null && ((context == null ? false : name in context) || !hasOtherScope)) {
      return context;
    }

    if (hasOtherScope) {
      context = chooseContext(hostScope, name, ancestor);

      if (context !== null) {
        return context;
      }
    } // still nothing found. return the root binding context (or null
    // if this is a parent scope traversal, to ensure we fall back to the
    // correct level)


    if (flags & 256
    /* isTraversingParentScope */
    ) {
        return marker;
      }

    return scope.bindingContext || scope.overrideContext;
  }

}

exports.BindingContext = BindingContext;

function chooseContext(scope, name, ancestor) {
  let overrideContext = scope.overrideContext;
  let currentScope = scope;

  if (ancestor > 0) {
    // jump up the required number of ancestor contexts (eg $parent.$parent requires two jumps)
    while (ancestor > 0) {
      ancestor--;
      currentScope = currentScope.parentScope;

      if (currentScope?.overrideContext == null) {
        return void 0;
      }
    }

    overrideContext = currentScope.overrideContext;
    return name in overrideContext ? overrideContext : overrideContext.bindingContext;
  } // traverse the context and it's ancestors, searching for a context that has the name.


  while (!currentScope?.isComponentBoundary && overrideContext && !(name in overrideContext) && !(overrideContext.bindingContext && name in overrideContext.bindingContext)) {
    currentScope = currentScope.parentScope ?? null;
    overrideContext = currentScope?.overrideContext ?? null;
  }

  if (overrideContext) {
    return name in overrideContext ? overrideContext : overrideContext.bindingContext;
  }

  return null;
}

class Scope {
  constructor(parentScope, bindingContext, overrideContext, isComponentBoundary) {
    this.parentScope = parentScope;
    this.bindingContext = bindingContext;
    this.overrideContext = overrideContext;
    this.isComponentBoundary = isComponentBoundary;
  }

  static create(bc, oc, isComponentBoundary) {
    return new Scope(null, bc, oc == null ? OverrideContext.create(bc) : oc, isComponentBoundary ?? false);
  }

  static fromOverride(oc) {
    if (oc == null) {
      throw new Error(`OverrideContext is ${oc}`);
    }

    return new Scope(null, oc.bindingContext, oc, false);
  }

  static fromParent(ps, bc) {
    if (ps == null) {
      throw new Error(`ParentScope is ${ps}`);
    }

    return new Scope(ps, bc, OverrideContext.create(bc), false);
  }

}

exports.Scope = Scope;

class OverrideContext {
  constructor(bindingContext) {
    this.bindingContext = bindingContext;
  }

  static create(bc) {
    return new OverrideContext(bc);
  }

}

exports.OverrideContext = OverrideContext;
});

;define.alias('@aurelia/runtime/observation/binding-context.js','@aurelia/runtime/dist/esm/observation/binding-context.js');
define('@aurelia/runtime/dist/esm/observation/collection-length-observer.js',['require','exports','module','@aurelia/kernel','./subscriber-collection.js','../utilities-objects.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.CollectionSizeObserver = exports.CollectionLengthObserver = void 0;

var _kernel = require("@aurelia/kernel");

var _subscriberCollection = require("./subscriber-collection.js");

var _utilitiesObjects = require("../utilities-objects.js");

class CollectionLengthObserver {
  constructor(owner) {
    this.owner = owner;
    this.type = 18
    /* Array */
    ;
    this.value = (this.obj = owner.collection).length;
  }

  getValue() {
    return this.obj.length;
  }

  setValue(newValue, flags) {
    const currentValue = this.value; // if in the template, length is two-way bound directly
    // then there's a chance that the new value is invalid
    // add a guard so that we don't accidentally broadcast invalid values

    if (newValue !== currentValue && (0, _kernel.isArrayIndex)(newValue)) {
      if ((flags & 4096
      /* noFlush */
      ) === 0) {
        this.obj.length = newValue;
      }

      this.value = newValue;
      this.subs.notify(newValue, currentValue, flags | 8
      /* updateTarget */
      );
    }
  }

  handleCollectionChange(_, flags) {
    const oldValue = this.value;
    const value = this.obj.length;

    if ((this.value = value) !== oldValue) {
      this.subs.notify(value, oldValue, flags);
    }
  }

}

exports.CollectionLengthObserver = CollectionLengthObserver;

class CollectionSizeObserver {
  constructor(owner) {
    this.owner = owner;
    this.value = (this.obj = owner.collection).size;
    this.type = this.obj instanceof Map ? 66
    /* Map */
    : 34
    /* Set */
    ;
  }

  getValue() {
    return this.obj.size;
  }

  setValue() {
    throw new Error('Map/Set "size" is a readonly property');
  }

  handleCollectionChange(_, flags) {
    const oldValue = this.value;
    const value = this.obj.size;
    this.value = value;

    if (value !== oldValue) {
      this.subs.notify(value, oldValue, flags);
    }
  }

}

exports.CollectionSizeObserver = CollectionSizeObserver;

function implementLengthObserver(klass) {
  const proto = klass.prototype;
  (0, _utilitiesObjects.ensureProto)(proto, 'subscribe', subscribe, true);
  (0, _utilitiesObjects.ensureProto)(proto, 'unsubscribe', unsubscribe, true);
  (0, _subscriberCollection.subscriberCollection)(klass);
}

function subscribe(subscriber) {
  if (this.subs.add(subscriber) && this.subs.count === 1) {
    this.owner.subscribe(this);
  }
}

function unsubscribe(subscriber) {
  if (this.subs.remove(subscriber) && this.subs.count === 0) {
    this.owner.subscribe(this);
  }
}

implementLengthObserver(CollectionLengthObserver);
implementLengthObserver(CollectionSizeObserver);
});

;define.alias('@aurelia/runtime/observation/collection-length-observer.js','@aurelia/runtime/dist/esm/observation/collection-length-observer.js');
define('@aurelia/runtime/dist/esm/observation/computed-observer.js',['require','exports','module','./subscriber-collection.js','./connectable-switcher.js','../binding/connectable.js','./proxy-observation.js','../utilities-objects.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.ComputedObserver = void 0;

var _subscriberCollection = require("./subscriber-collection.js");

var _connectableSwitcher = require("./connectable-switcher.js");

var _connectable = require("../binding/connectable.js");

var _proxyObservation = require("./proxy-observation.js");

var _utilitiesObjects = require("../utilities-objects.js");

class ComputedObserver {
  constructor(obj, get, set, useProxy, observerLocator) {
    this.obj = obj;
    this.get = get;
    this.set = set;
    this.useProxy = useProxy;
    this.observerLocator = observerLocator;
    this.interceptor = this;
    this.type = 1
    /* Observer */
    ;
    this.value = void 0; // todo: maybe use a counter allow recursive call to a certain level

    /**
     * @internal
     */

    this.running = false;
    this.isDirty = false;

    _connectable.connectable.assignIdTo(this);
  }

  static create(obj, key, descriptor, observerLocator, useProxy) {
    const getter = descriptor.get;
    const setter = descriptor.set;
    const observer = new ComputedObserver(obj, getter, setter, useProxy, observerLocator);

    const $get = () =>
    /* Computed Observer */
    observer.getValue();

    $get.getObserver = () => observer;

    (0, _utilitiesObjects.def)(obj, key, {
      enumerable: descriptor.enumerable,
      configurable: true,
      get: $get,
      set:
      /* Computed Observer */
      v => {
        observer.setValue(v, 0
        /* none */
        );
      }
    });
    return observer;
  }

  getValue() {
    if (this.subs.count === 0) {
      return this.get.call(this.obj, this);
    }

    if (this.isDirty) {
      this.compute();
      this.isDirty = false;
    }

    return this.value;
  } // deepscan-disable-next-line


  setValue(v, _flags) {
    if (typeof this.set === 'function') {
      if (v !== this.value) {
        // setting running true as a form of batching
        this.running = true;
        this.set.call(this.obj, v);
        this.running = false;
        this.run();
      }
    } else {
      throw new Error('Property is readonly');
    }
  }

  handleChange() {
    this.isDirty = true;

    if (this.subs.count > 0) {
      this.run();
    }
  }

  handleCollectionChange() {
    this.isDirty = true;

    if (this.subs.count > 0) {
      this.run();
    }
  }

  subscribe(subscriber) {
    // in theory, a collection subscriber could be added before a property subscriber
    // and it should be handled similarly in subscribeToCollection
    // though not handling for now, and wait until the merge of normal + collection subscription
    if (this.subs.add(subscriber) && this.subs.count === 1) {
      this.compute();
      this.isDirty = false;
    }
  }

  unsubscribe(subscriber) {
    if (this.subs.remove(subscriber) && this.subs.count === 0) {
      this.isDirty = true;
      this.obs.clear(true);
    }
  }

  run() {
    if (this.running) {
      return;
    }

    const oldValue = this.value;
    const newValue = this.compute();
    this.isDirty = false;

    if (!Object.is(newValue, oldValue)) {
      // should optionally queue
      this.subs.notify(newValue, oldValue, 0
      /* none */
      );
    }
  }

  compute() {
    this.running = true;
    this.obs.version++;

    try {
      (0, _connectableSwitcher.enterConnectable)(this);
      return this.value = (0, _proxyObservation.unwrap)(this.get.call(this.useProxy ? (0, _proxyObservation.wrap)(this.obj) : this.obj, this));
    } finally {
      this.obs.clear(false);
      this.running = false;
      (0, _connectableSwitcher.exitConnectable)(this);
    }
  }

}

exports.ComputedObserver = ComputedObserver;
(0, _connectable.connectable)(ComputedObserver);
(0, _subscriberCollection.subscriberCollection)(ComputedObserver);
});

;define.alias('@aurelia/runtime/observation/computed-observer.js','@aurelia/runtime/dist/esm/observation/computed-observer.js');
define('@aurelia/runtime/dist/esm/observation/connectable-switcher.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.pauseConnecting = pauseConnecting;
exports.resumeConnecting = resumeConnecting;
exports.currentConnectable = currentConnectable;
exports.enterConnectable = enterConnectable;
exports.exitConnectable = exitConnectable;
exports.ConnectableSwitcher = exports.connecting = void 0;

/**
 * Current subscription collector
 */
let _connectable = null;
const connectables = []; // eslint-disable-next-line

let connecting = false; // todo: layer based collection pause/resume?

exports.connecting = connecting;

function pauseConnecting() {
  exports.connecting = connecting = false;
}

function resumeConnecting() {
  exports.connecting = connecting = true;
}

function currentConnectable() {
  return _connectable;
}

function enterConnectable(connectable) {
  if (connectable == null) {
    throw new Error('connectable cannot be null/undefined');
  }

  if (_connectable == null) {
    _connectable = connectable;
    connectables[0] = _connectable;
    exports.connecting = connecting = true;
    return;
  }

  if (_connectable === connectable) {
    throw new Error(`Already in this connectable ${connectable.id}`);
  }

  connectables.push(_connectable);
  _connectable = connectable;
  exports.connecting = connecting = true;
}

function exitConnectable(connectable) {
  if (connectable == null) {
    throw new Error('Connectable cannot be null/undefined');
  }

  if (_connectable !== connectable) {
    throw new Error(`${connectable.id} is not currently collecting`);
  }

  connectables.pop();
  _connectable = connectables.length > 0 ? connectables[connectables.length - 1] : null;
  exports.connecting = connecting = _connectable != null;
}

const ConnectableSwitcher = Object.freeze({
  get current() {
    return _connectable;
  },

  get connecting() {
    return connecting;
  },

  enter: enterConnectable,
  exit: exitConnectable,
  pause: pauseConnecting,
  resume: resumeConnecting
});
exports.ConnectableSwitcher = ConnectableSwitcher;
});

;define.alias('@aurelia/runtime/observation/connectable-switcher.js','@aurelia/runtime/dist/esm/observation/connectable-switcher.js');
define('@aurelia/runtime/dist/esm/observation/dirty-checker.js',['require','exports','module','@aurelia/kernel','./subscriber-collection.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.DirtyCheckProperty = exports.DirtyChecker = exports.DirtyCheckSettings = exports.IDirtyChecker = void 0;

var _kernel = require("@aurelia/kernel");

var _subscriberCollection = require("./subscriber-collection.js");

const IDirtyChecker = _kernel.DI.createInterface('IDirtyChecker', x => x.singleton(DirtyChecker));

exports.IDirtyChecker = IDirtyChecker;
const DirtyCheckSettings = {
  /**
   * Default: `6`
   *
   * Adjust the global dirty check frequency.
   * Measures in "timeouts per check", such that (given a default of 250 timeouts per second in modern browsers):
   * - A value of 1 will result in 250 dirty checks per second (or 1 dirty check per second for an inactive tab)
   * - A value of 25 will result in 10 dirty checks per second (or 1 dirty check per 25 seconds for an inactive tab)
   */
  timeoutsPerCheck: 25,

  /**
   * Default: `false`
   *
   * Disable dirty-checking entirely. Properties that cannot be observed without dirty checking
   * or an adapter, will simply not be observed.
   */
  disabled: false,

  /**
   * Default: `false`
   *
   * Throw an error if a property is being dirty-checked.
   */
  throw: false,

  /**
   * Resets all dirty checking settings to the framework's defaults.
   */
  resetToDefault() {
    this.timeoutsPerCheck = 6;
    this.disabled = false;
    this.throw = false;
  }

};
exports.DirtyCheckSettings = DirtyCheckSettings;
const queueTaskOpts = {
  persistent: true
};

class DirtyChecker {
  constructor(platform) {
    this.platform = platform;
    this.tracked = [];
    this.task = null;
    this.elapsedFrames = 0;

    this.check = () => {
      if (DirtyCheckSettings.disabled) {
        return;
      }

      if (++this.elapsedFrames < DirtyCheckSettings.timeoutsPerCheck) {
        return;
      }

      this.elapsedFrames = 0;
      const tracked = this.tracked;
      const len = tracked.length;
      let current;
      let i = 0;

      for (; i < len; ++i) {
        current = tracked[i];

        if (current.isDirty()) {
          current.flush(0
          /* none */
          );
        }
      }
    };
  }

  createProperty(obj, propertyName) {
    if (DirtyCheckSettings.throw) {
      throw new Error(`Property '${propertyName}' is being dirty-checked.`);
    }

    return new DirtyCheckProperty(this, obj, propertyName);
  }

  addProperty(property) {
    this.tracked.push(property);

    if (this.tracked.length === 1) {
      this.task = this.platform.macroTaskQueue.queueTask(this.check, queueTaskOpts);
    }
  }

  removeProperty(property) {
    this.tracked.splice(this.tracked.indexOf(property), 1);

    if (this.tracked.length === 0) {
      this.task.cancel();
      this.task = null;
    }
  }

}
/**
 * @internal
 */


exports.DirtyChecker = DirtyChecker;
DirtyChecker.inject = [_kernel.IPlatform];

class DirtyCheckProperty {
  constructor(dirtyChecker, obj, propertyKey) {
    this.dirtyChecker = dirtyChecker;
    this.obj = obj;
    this.propertyKey = propertyKey;
    this.type = 0
    /* None */
    ;
  }

  getValue() {
    return this.obj[this.propertyKey];
  }

  setValue(v, f) {
    // todo: this should be allowed, probably
    // but the construction of dirty checker should throw instead
    throw new Error(`Trying to set value for property ${this.propertyKey} in dirty checker`);
  }

  isDirty() {
    return this.oldValue !== this.obj[this.propertyKey];
  }

  flush(flags) {
    const oldValue = this.oldValue;
    const newValue = this.getValue();
    this.subs.notify(newValue, oldValue, flags | 8
    /* updateTarget */
    );
    this.oldValue = newValue;
  }

  subscribe(subscriber) {
    if (this.subs.add(subscriber) && this.subs.count === 1) {
      this.oldValue = this.obj[this.propertyKey];
      this.dirtyChecker.addProperty(this);
    }
  }

  unsubscribe(subscriber) {
    if (this.subs.remove(subscriber) && this.subs.count === 0) {
      this.dirtyChecker.removeProperty(this);
    }
  }

}

exports.DirtyCheckProperty = DirtyCheckProperty;
(0, _subscriberCollection.subscriberCollection)(DirtyCheckProperty);
});

;define.alias('@aurelia/runtime/observation/dirty-checker.js','@aurelia/runtime/dist/esm/observation/dirty-checker.js');
define('@aurelia/runtime/dist/esm/observation/map-observer.js',['require','exports','module','../observation.js','./collection-length-observer.js','./subscriber-collection.js','../utilities-objects.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.enableMapObservation = enableMapObservation;
exports.disableMapObservation = disableMapObservation;
exports.getMapObserver = getMapObserver;
exports.MapObserver = void 0;

var _observation = require("../observation.js");

var _collectionLengthObserver = require("./collection-length-observer.js");

var _subscriberCollection = require("./subscriber-collection.js");

var _utilitiesObjects = require("../utilities-objects.js");

const observerLookup = new WeakMap();
const proto = Map.prototype;
const $set = proto.set;
const $clear = proto.clear;
const $delete = proto.delete;
const native = {
  set: $set,
  clear: $clear,
  delete: $delete
};
const methods = ['set', 'clear', 'delete']; // note: we can't really do much with Map due to the internal data structure not being accessible so we're just using the native calls
// fortunately, map/delete/clear are easy to reconstruct for the indexMap

const observe = {
  // https://tc39.github.io/ecma262/#sec-map.prototype.map
  set: function (key, value) {
    const o = observerLookup.get(this);

    if (o === undefined) {
      $set.call(this, key, value);
      return this;
    }

    const oldValue = this.get(key);
    const oldSize = this.size;
    $set.call(this, key, value);
    const newSize = this.size;

    if (newSize === oldSize) {
      let i = 0;

      for (const entry of this.entries()) {
        if (entry[0] === key) {
          if (entry[1] !== oldValue) {
            o.indexMap.deletedItems.push(o.indexMap[i]);
            o.indexMap[i] = -2;
            o.notify();
          }

          return this;
        }

        i++;
      }

      return this;
    }

    o.indexMap[oldSize] = -2;
    o.notify();
    return this;
  },
  // https://tc39.github.io/ecma262/#sec-map.prototype.clear
  clear: function () {
    const o = observerLookup.get(this);

    if (o === undefined) {
      return $clear.call(this);
    }

    const size = this.size;

    if (size > 0) {
      const indexMap = o.indexMap;
      let i = 0; // deepscan-disable-next-line

      for (const _ of this.keys()) {
        if (indexMap[i] > -1) {
          indexMap.deletedItems.push(indexMap[i]);
        }

        i++;
      }

      $clear.call(this);
      indexMap.length = 0;
      o.notify();
    }

    return undefined;
  },
  // https://tc39.github.io/ecma262/#sec-map.prototype.delete
  delete: function (value) {
    const o = observerLookup.get(this);

    if (o === undefined) {
      return $delete.call(this, value);
    }

    const size = this.size;

    if (size === 0) {
      return false;
    }

    let i = 0;
    const indexMap = o.indexMap;

    for (const entry of this.keys()) {
      if (entry === value) {
        if (indexMap[i] > -1) {
          indexMap.deletedItems.push(indexMap[i]);
        }

        indexMap.splice(i, 1);
        const deleteResult = $delete.call(this, value);

        if (deleteResult === true) {
          o.notify();
        }

        return deleteResult;
      }

      ++i;
    }

    return false;
  }
};
const descriptorProps = {
  writable: true,
  enumerable: false,
  configurable: true
};

for (const method of methods) {
  (0, _utilitiesObjects.def)(observe[method], 'observing', {
    value: true,
    writable: false,
    configurable: false,
    enumerable: false
  });
}

let enableMapObservationCalled = false;

function enableMapObservation() {
  for (const method of methods) {
    if (proto[method].observing !== true) {
      (0, _utilitiesObjects.def)(proto, method, { ...descriptorProps,
        value: observe[method]
      });
    }
  }
}

function disableMapObservation() {
  for (const method of methods) {
    if (proto[method].observing === true) {
      (0, _utilitiesObjects.def)(proto, method, { ...descriptorProps,
        value: native[method]
      });
    }
  }
}

class MapObserver {
  constructor(map) {
    this.type = 66
    /* Map */
    ;

    if (!enableMapObservationCalled) {
      enableMapObservationCalled = true;
      enableMapObservation();
    }

    this.collection = map;
    this.indexMap = (0, _observation.createIndexMap)(map.size);
    this.lenObs = void 0;
    observerLookup.set(map, this);
  }

  notify() {
    const indexMap = this.indexMap;
    const size = this.collection.size;
    this.indexMap = (0, _observation.createIndexMap)(size);
    this.subs.notifyCollection(indexMap, 8
    /* updateTarget */
    );
  }

  getLengthObserver() {
    return this.lenObs ?? (this.lenObs = new _collectionLengthObserver.CollectionSizeObserver(this));
  }

}

exports.MapObserver = MapObserver;
(0, _subscriberCollection.subscriberCollection)(MapObserver);

function getMapObserver(map) {
  let observer = observerLookup.get(map);

  if (observer === void 0) {
    observer = new MapObserver(map);
  }

  return observer;
}
});

;define.alias('@aurelia/runtime/observation/map-observer.js','@aurelia/runtime/dist/esm/observation/map-observer.js');
define('@aurelia/runtime/dist/esm/observation/observable.js',['require','exports','module','./setter-observer.js','../utilities-objects.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.observable = observable;

var _setterObserver = require("./setter-observer.js");

var _utilitiesObjects = require("../utilities-objects.js");

function getObserversLookup(obj) {
  if (obj.$observers === void 0) {
    (0, _utilitiesObjects.def)(obj, '$observers', {
      value: {}
    }); // todo: define in a weakmap
  }

  return obj.$observers;
}

const noValue = {}; // impl, wont be seen

function observable(targetOrConfig, key, descriptor) {
  // either this check, or arguments.length === 3
  // or could be both, so can throw against user error for better DX
  if (key == null) {
    // for:
    //    @observable('prop')
    //    class {}
    //
    //    @observable({ name: 'prop', callback: ... })
    //    class {}
    //
    //    class {
    //      @observable() prop
    //      @observable({ callback: ... }) prop2
    //    }
    return (t, k, d) => deco(t, k, d, targetOrConfig);
  } // for:
  //    class {
  //      @observable prop
  //    }


  return deco(targetOrConfig, key, descriptor);

  function deco(target, key, descriptor, config) {
    // class decorator?
    const isClassDecorator = key === void 0;
    config = typeof config !== 'object' ? {
      name: config
    } : config || {};

    if (isClassDecorator) {
      key = config.name;
    }

    if (key == null || key === '') {
      throw new Error('Invalid usage, cannot determine property name for @observable');
    } // determine callback name based on config or convention.


    const callback = config.callback || `${String(key)}Changed`;
    let initialValue = noValue;

    if (descriptor) {
      // we're adding a getter and setter which means the property descriptor
      // cannot have a "value" or "writable" attribute
      delete descriptor.value;
      delete descriptor.writable;
      initialValue = descriptor.initializer?.();
      delete descriptor.initializer;
    } else {
      descriptor = {
        configurable: true
      };
    } // make the accessor enumerable by default, as fields are enumerable


    if (!('enumerable' in descriptor)) {
      descriptor.enumerable = true;
    } // todo(bigopon/fred): discuss string api for converter


    const $set = config.set;

    descriptor.get = function g()
    /* @observable */
    {
      return getNotifier(this, key, callback, initialValue, $set).getValue();
    };

    descriptor.set = function s(newValue) {
      getNotifier(this, key, callback, initialValue, $set).setValue(newValue, 0
      /* none */
      );
    };

    descriptor.get.getObserver = function gO(
    /* @observable */
    obj) {
      return getNotifier(obj, key, callback, initialValue, $set);
    };

    if (isClassDecorator) {
      (0, _utilitiesObjects.def)(target.prototype, key, descriptor);
    } else {
      return descriptor;
    }
  }
}

function getNotifier(obj, key, callbackKey, initialValue, set) {
  const lookup = getObserversLookup(obj);
  let notifier = lookup[key];

  if (notifier == null) {
    notifier = new _setterObserver.SetterNotifier(obj, callbackKey, set, initialValue === noValue ? void 0 : initialValue);
    lookup[key] = notifier;
  }

  return notifier;
}
/*
          | typescript       | babel
----------|------------------|-------------------------
property  | config           | config
w/parens  | target, key      | target, key, descriptor
----------|------------------|-------------------------
property  | target, key      | target, key, descriptor
no parens | n/a              | n/a
----------|------------------|-------------------------
class     | config           | config
          | target           | target
*/
});

;define.alias('@aurelia/runtime/observation/observable.js','@aurelia/runtime/dist/esm/observation/observable.js');
define('@aurelia/runtime/dist/esm/observation/observer-locator.js',['require','exports','module','@aurelia/kernel','./array-observer.js','./computed-observer.js','./dirty-checker.js','./map-observer.js','./primitive-observer.js','./property-accessor.js','./set-observer.js','./setter-observer.js','../utilities-objects.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.getCollectionObserver = getCollectionObserver;
exports.ObserverLocator = exports.INodeObserverLocator = exports.IObserverLocator = exports.propertyAccessor = void 0;

var _kernel = require("@aurelia/kernel");

var _arrayObserver = require("./array-observer.js");

var _computedObserver = require("./computed-observer.js");

var _dirtyChecker = require("./dirty-checker.js");

var _mapObserver = require("./map-observer.js");

var _primitiveObserver = require("./primitive-observer.js");

var _propertyAccessor = require("./property-accessor.js");

var _setObserver = require("./set-observer.js");

var _setterObserver = require("./setter-observer.js");

var _utilitiesObjects = require("../utilities-objects.js");

const propertyAccessor = new _propertyAccessor.PropertyAccessor();
exports.propertyAccessor = propertyAccessor;

const IObserverLocator = _kernel.DI.createInterface('IObserverLocator', x => x.singleton(ObserverLocator));

exports.IObserverLocator = IObserverLocator;

const INodeObserverLocator = _kernel.DI.createInterface('INodeObserverLocator', x => x.cachedCallback(handler => {
  handler.getAll(_kernel.ILogger).forEach(logger => {
    logger.error('Using default INodeObserverLocator implementation. Will not be able to observe nodes (HTML etc...).');
  });
  return new DefaultNodeObserverLocator();
}));

exports.INodeObserverLocator = INodeObserverLocator;

class DefaultNodeObserverLocator {
  handles() {
    return false;
  }

  getObserver() {
    return propertyAccessor;
  }

  getAccessor() {
    return propertyAccessor;
  }

}

class ObserverLocator {
  constructor(dirtyChecker, nodeObserverLocator) {
    this.dirtyChecker = dirtyChecker;
    this.nodeObserverLocator = nodeObserverLocator;
    this.adapters = [];
  }

  addAdapter(adapter) {
    this.adapters.push(adapter);
  }

  getObserver(obj, key) {
    return obj.$observers?.[key] ?? this.cache(obj, key, this.createObserver(obj, key));
  }

  getAccessor(obj, key) {
    const cached = obj.$observers?.[key];

    if (cached !== void 0) {
      return cached;
    }

    if (this.nodeObserverLocator.handles(obj, key, this)) {
      return this.nodeObserverLocator.getAccessor(obj, key, this);
    }

    return propertyAccessor;
  }

  getArrayObserver(observedArray) {
    return (0, _arrayObserver.getArrayObserver)(observedArray);
  }

  getMapObserver(observedMap) {
    return (0, _mapObserver.getMapObserver)(observedMap);
  }

  getSetObserver(observedSet) {
    return (0, _setObserver.getSetObserver)(observedSet);
  }

  createObserver(obj, key) {
    if (!(obj instanceof Object)) {
      return new _primitiveObserver.PrimitiveObserver(obj, key);
    }

    if (this.nodeObserverLocator.handles(obj, key, this)) {
      return this.nodeObserverLocator.getObserver(obj, key, this);
    }

    switch (key) {
      case 'length':
        if (obj instanceof Array) {
          return (0, _arrayObserver.getArrayObserver)(obj).getLengthObserver();
        }

        break;

      case 'size':
        if (obj instanceof Map) {
          return (0, _mapObserver.getMapObserver)(obj).getLengthObserver();
        } else if (obj instanceof Set) {
          return (0, _setObserver.getSetObserver)(obj).getLengthObserver();
        }

        break;

      default:
        if (obj instanceof Array && (0, _kernel.isArrayIndex)(key)) {
          return (0, _arrayObserver.getArrayObserver)(obj).getIndexObserver(Number(key));
        }

        break;
    }

    let pd = Object.getOwnPropertyDescriptor(obj, key); // Only instance properties will yield a descriptor here, otherwise walk up the proto chain

    if (pd === void 0) {
      let proto = Object.getPrototypeOf(obj);

      while (proto !== null) {
        pd = Object.getOwnPropertyDescriptor(proto, key);

        if (pd === void 0) {
          proto = Object.getPrototypeOf(proto);
        } else {
          break;
        }
      }
    } // If the descriptor does not have a 'value' prop, it must have a getter and/or setter


    if (pd !== void 0 && !Object.prototype.hasOwnProperty.call(pd, 'value')) {
      let obs = this.getAdapterObserver(obj, key, pd);

      if (obs == null) {
        obs = (pd.get?.getObserver ?? pd.set?.getObserver)?.(obj, this);
      }

      return obs == null ? pd.configurable ? _computedObserver.ComputedObserver.create(obj, key, pd, this,
      /* AOT: not true for IE11 */
      true) : this.dirtyChecker.createProperty(obj, key) : obs;
    } // Ordinary get/set observation (the common use case)
    // TODO: think about how to handle a data property that does not sit on the instance (should we do anything different?)


    return new _setterObserver.SetterObserver(obj, key);
  }

  getAdapterObserver(obj, propertyName, pd) {
    if (this.adapters.length > 0) {
      for (const adapter of this.adapters) {
        const observer = adapter.getObserver(obj, propertyName, pd, this);

        if (observer != null) {
          return observer;
        }
      }
    }

    return null;
  }

  cache(obj, key, observer) {
    if (observer.doNotCache === true) {
      return observer;
    }

    if (obj.$observers === void 0) {
      (0, _utilitiesObjects.def)(obj, '$observers', {
        value: {
          [key]: observer
        }
      });
      return observer;
    }

    return obj.$observers[key] = observer;
  }

}

exports.ObserverLocator = ObserverLocator;
ObserverLocator.inject = [_dirtyChecker.IDirtyChecker, INodeObserverLocator];

function getCollectionObserver(collection) {
  let obs;

  if (collection instanceof Array) {
    obs = (0, _arrayObserver.getArrayObserver)(collection);
  } else if (collection instanceof Map) {
    obs = (0, _mapObserver.getMapObserver)(collection);
  } else if (collection instanceof Set) {
    obs = (0, _setObserver.getSetObserver)(collection);
  }

  return obs;
}
});

;define.alias('@aurelia/runtime/observation/observer-locator.js','@aurelia/runtime/dist/esm/observation/observer-locator.js');
define('@aurelia/runtime/dist/esm/observation/primitive-observer.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.PrimitiveObserver = void 0;

class PrimitiveObserver {
  constructor(obj, propertyKey) {
    this.obj = obj;
    this.propertyKey = propertyKey;
    this.type = 0
    /* None */
    ;
  }

  get doNotCache() {
    return true;
  }

  getValue() {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-explicit-any
    return this.obj[this.propertyKey];
  }

  setValue() {}

  subscribe() {}

  unsubscribe() {}

}

exports.PrimitiveObserver = PrimitiveObserver;
});

;define.alias('@aurelia/runtime/observation/primitive-observer.js','@aurelia/runtime/dist/esm/observation/primitive-observer.js');
define('@aurelia/runtime/dist/esm/observation/property-accessor.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.PropertyAccessor = void 0;

class PropertyAccessor {
  constructor() {
    // the only thing can be guaranteed is it's an object
    // even if this property accessor is used to access an element
    this.type = 0
    /* None */
    ;
  }

  getValue(obj, key) {
    return obj[key];
  }

  setValue(value, flags, obj, key) {
    obj[key] = value;
  }

}

exports.PropertyAccessor = PropertyAccessor;
});

;define.alias('@aurelia/runtime/observation/property-accessor.js','@aurelia/runtime/dist/esm/observation/property-accessor.js');
define('@aurelia/runtime/dist/esm/observation/proxy-observation.js',['require','exports','module','./connectable-switcher.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.wrap = wrap;
exports.getProxy = getProxy;
exports.getRaw = getRaw;
exports.unwrap = unwrap;
exports.ProxyObservable = exports.rawKey = void 0;

var _connectableSwitcher = require("./connectable-switcher.js");

const R$get = Reflect.get;
const toStringTag = Object.prototype.toString;
const proxyMap = new WeakMap();

function canWrap(obj) {
  switch (toStringTag.call(obj)) {
    case '[object Object]':
    case '[object Array]':
    case '[object Map]':
    case '[object Set]':
      // it's unlikely that methods on the following 2 objects need to be observed for changes
      // so while they are valid/ we don't wrap them either
      // case '[object Math]':
      // case '[object Reflect]':
      return true;

    default:
      return false;
  }
}

const rawKey = '__raw__';
exports.rawKey = rawKey;

function wrap(v) {
  return canWrap(v) ? getProxy(v) : v;
}

function getProxy(obj) {
  // deepscan-disable-next-line
  return proxyMap.get(obj) ?? createProxy(obj);
}

function getRaw(obj) {
  // todo: get in a weakmap if null/undef
  return obj[rawKey] ?? obj;
}

function unwrap(v) {
  // eslint-disable-next-line
  return canWrap(v) && v[rawKey] || v;
}

function doNotCollect(key) {
  return key === 'constructor' || key === '__proto__' // probably should revert to v1 naming style for consistency with builtin?
  // __o__ is shorters & less chance of conflict with other libs as well
  || key === '$observers' || key === Symbol.toPrimitive || key === Symbol.toStringTag;
}

function createProxy(obj) {
  const handler = obj instanceof Array ? arrayHandler : obj instanceof Map || obj instanceof Set ? collectionHandler : objectHandler;
  const proxiedObj = new Proxy(obj, handler);
  proxyMap.set(obj, proxiedObj);
  return proxiedObj;
}

const objectHandler = {
  get(target, key, receiver) {
    // maybe use symbol?
    if (key === rawKey) {
      return target;
    }

    const connectable = (0, _connectableSwitcher.currentConnectable)();

    if (!_connectableSwitcher.connecting || doNotCollect(key) || connectable == null) {
      return R$get(target, key, receiver);
    } // todo: static


    connectable.observeProperty(target, key);
    return wrap(R$get(target, key, receiver));
  }

};
const arrayHandler = {
  get(target, key, receiver) {
    // maybe use symbol?
    if (key === rawKey) {
      return target;
    }

    const connectable = (0, _connectableSwitcher.currentConnectable)();

    if (!_connectableSwitcher.connecting || doNotCollect(key) || connectable == null) {
      return R$get(target, key, receiver);
    }

    switch (key) {
      case 'length':
        connectable.observeProperty(target, 'length');
        return target.length;

      case 'map':
        return wrappedArrayMap;

      case 'includes':
        return wrappedArrayIncludes;

      case 'indexOf':
        return wrappedArrayIndexOf;

      case 'lastIndexOf':
        return wrappedArrayLastIndexOf;

      case 'every':
        return wrappedArrayEvery;

      case 'filter':
        return wrappedArrayFilter;

      case 'findIndex':
        return wrappedArrayFindIndex;

      case 'flat':
        return wrappedArrayFlat;

      case 'flatMap':
        return wrappedArrayFlatMap;

      case 'join':
        return wrappedArrayJoin;

      case 'push':
        return wrappedArrayPush;

      case 'pop':
        return wrappedArrayPop;

      case 'reduce':
        return wrappedReduce;

      case 'reduceRight':
        return wrappedReduceRight;

      case 'reverse':
        return wrappedArrayReverse;

      case 'shift':
        return wrappedArrayShift;

      case 'unshift':
        return wrappedArrayUnshift;

      case 'slice':
        return wrappedArraySlice;

      case 'splice':
        return wrappedArraySplice;

      case 'some':
        return wrappedArraySome;

      case 'sort':
        return wrappedArraySort;

      case 'keys':
        return wrappedKeys;

      case 'values':
      case Symbol.iterator:
        return wrappedValues;

      case 'entries':
        return wrappedEntries;
    }

    connectable.observeProperty(target, key);
    return wrap(R$get(target, key, receiver));
  },

  // for (let i in array) ...
  ownKeys(target) {
    (0, _connectableSwitcher.currentConnectable)()?.observeProperty(target, 'length');
    return Reflect.ownKeys(target);
  }

};

function wrappedArrayMap(cb, thisArg) {
  const raw = getRaw(this);
  const res = raw.map((v, i) => // do we wrap `thisArg`?
  unwrap(cb.call(thisArg, wrap(v), i, this)));
  (0, _connectableSwitcher.currentConnectable)()?.observeCollection(raw);
  return wrap(res);
}

function wrappedArrayEvery(cb, thisArg) {
  const raw = getRaw(this);
  const res = raw.every((v, i) => cb.call(thisArg, wrap(v), i, this));
  (0, _connectableSwitcher.currentConnectable)()?.observeCollection(raw);
  return res;
}

function wrappedArrayFilter(cb, thisArg) {
  const raw = getRaw(this);
  const res = raw.filter((v, i) => // do we wrap `thisArg`?
  unwrap(cb.call(thisArg, wrap(v), i, this)));
  (0, _connectableSwitcher.currentConnectable)()?.observeCollection(raw);
  return wrap(res);
}

function wrappedArrayIncludes(v) {
  const raw = getRaw(this);
  const res = raw.includes(unwrap(v));
  (0, _connectableSwitcher.currentConnectable)()?.observeCollection(raw);
  return res;
}

function wrappedArrayIndexOf(v) {
  const raw = getRaw(this);
  const res = raw.indexOf(unwrap(v));
  (0, _connectableSwitcher.currentConnectable)()?.observeCollection(raw);
  return res;
}

function wrappedArrayLastIndexOf(v) {
  const raw = getRaw(this);
  const res = raw.lastIndexOf(unwrap(v));
  (0, _connectableSwitcher.currentConnectable)()?.observeCollection(raw);
  return res;
}

function wrappedArrayFindIndex(cb, thisArg) {
  const raw = getRaw(this);
  const res = raw.findIndex((v, i) => unwrap(cb.call(thisArg, wrap(v), i, this)));
  (0, _connectableSwitcher.currentConnectable)()?.observeCollection(raw);
  return res;
}

function wrappedArrayFlat() {
  const raw = getRaw(this);
  (0, _connectableSwitcher.currentConnectable)()?.observeCollection(raw);
  return wrap(raw.flat());
}

function wrappedArrayFlatMap(cb, thisArg) {
  const raw = getRaw(this);
  (0, _connectableSwitcher.currentConnectable)()?.observeCollection(raw);
  return getProxy(raw.flatMap((v, i) => wrap(cb.call(thisArg, wrap(v), i, this))));
}

function wrappedArrayJoin(separator) {
  const raw = getRaw(this);
  (0, _connectableSwitcher.currentConnectable)()?.observeCollection(raw);
  return raw.join(separator);
}

function wrappedArrayPop() {
  return wrap(getRaw(this).pop());
}

function wrappedArrayPush(...args) {
  return getRaw(this).push(...args);
}

function wrappedArrayShift() {
  return wrap(getRaw(this).shift());
}

function wrappedArrayUnshift(...args) {
  return getRaw(this).unshift(...args);
}

function wrappedArraySplice(...args) {
  return wrap(getRaw(this).splice(...args));
}

function wrappedArrayReverse(...args) {
  const raw = getRaw(this);
  const res = raw.reverse();
  (0, _connectableSwitcher.currentConnectable)()?.observeCollection(raw);
  return wrap(res);
}

function wrappedArraySome(cb, thisArg) {
  const raw = getRaw(this);
  const res = raw.some((v, i) => unwrap(cb.call(thisArg, wrap(v), i, this)));
  (0, _connectableSwitcher.currentConnectable)()?.observeCollection(raw);
  return res;
}

function wrappedArraySort(cb) {
  const raw = getRaw(this);
  const res = raw.sort(cb);
  (0, _connectableSwitcher.currentConnectable)()?.observeCollection(raw);
  return wrap(res);
}

function wrappedArraySlice(start, end) {
  const raw = getRaw(this);
  (0, _connectableSwitcher.currentConnectable)()?.observeCollection(raw);
  return getProxy(raw.slice(start, end));
}

function wrappedReduce(cb, initValue) {
  const raw = getRaw(this);
  const res = raw.reduce((curr, v, i) => cb(curr, wrap(v), i, this), initValue);
  (0, _connectableSwitcher.currentConnectable)()?.observeCollection(raw);
  return wrap(res);
}

function wrappedReduceRight(cb, initValue) {
  const raw = getRaw(this);
  const res = raw.reduceRight((curr, v, i) => cb(curr, wrap(v), i, this), initValue);
  (0, _connectableSwitcher.currentConnectable)()?.observeCollection(raw);
  return wrap(res);
} // the below logic takes inspiration from Vue, Mobx
// much thanks to them for working out this


const collectionHandler = {
  get(target, key, receiver) {
    // maybe use symbol?
    if (key === rawKey) {
      return target;
    }

    const connectable = (0, _connectableSwitcher.currentConnectable)();

    if (!_connectableSwitcher.connecting || doNotCollect(key) || connectable == null) {
      return R$get(target, key, receiver);
    }

    switch (key) {
      case 'size':
        connectable.observeProperty(target, 'size');
        return target.size;

      case 'clear':
        return wrappedClear;

      case 'delete':
        return wrappedDelete;

      case 'forEach':
        return wrappedForEach;

      case 'add':
        if (target instanceof Set) {
          return wrappedAdd;
        }

        break;

      case 'get':
        if (target instanceof Map) {
          return wrappedGet;
        }

        break;

      case 'set':
        if (target instanceof Map) {
          return wrappedSet;
        }

        break;

      case 'has':
        return wrappedHas;

      case 'keys':
        return wrappedKeys;

      case 'values':
        return wrappedValues;

      case 'entries':
        return wrappedEntries;

      case Symbol.iterator:
        return target instanceof Map ? wrappedEntries : wrappedValues;
    }

    return wrap(R$get(target, key, receiver));
  }

};

function wrappedForEach(cb, thisArg) {
  const raw = getRaw(this);
  (0, _connectableSwitcher.currentConnectable)()?.observeCollection(raw);
  return raw.forEach((v, key) => {
    cb.call(
    /* should wrap or not?? */
    thisArg, wrap(v), wrap(key), this);
  });
}

function wrappedHas(v) {
  const raw = getRaw(this);
  (0, _connectableSwitcher.currentConnectable)()?.observeCollection(raw);
  return raw.has(unwrap(v));
}

function wrappedGet(k) {
  const raw = getRaw(this);
  (0, _connectableSwitcher.currentConnectable)()?.observeCollection(raw);
  return wrap(raw.get(unwrap(k)));
}

function wrappedSet(k, v) {
  return wrap(getRaw(this).set(unwrap(k), unwrap(v)));
}

function wrappedAdd(v) {
  return wrap(getRaw(this).add(unwrap(v)));
}

function wrappedClear() {
  return wrap(getRaw(this).clear());
}

function wrappedDelete(k) {
  return wrap(getRaw(this).delete(unwrap(k)));
}

function wrappedKeys() {
  const raw = getRaw(this);
  (0, _connectableSwitcher.currentConnectable)()?.observeCollection(raw);
  const iterator = raw.keys();
  return {
    next() {
      const next = iterator.next();
      const value = next.value;
      const done = next.done;
      return done ? {
        value: void 0,
        done
      } : {
        value: wrap(value),
        done
      };
    },

    [Symbol.iterator]() {
      return this;
    }

  };
}

function wrappedValues() {
  const raw = getRaw(this);
  (0, _connectableSwitcher.currentConnectable)()?.observeCollection(raw);
  const iterator = raw.values();
  return {
    next() {
      const next = iterator.next();
      const value = next.value;
      const done = next.done;
      return done ? {
        value: void 0,
        done
      } : {
        value: wrap(value),
        done
      };
    },

    [Symbol.iterator]() {
      return this;
    }

  };
}

function wrappedEntries() {
  const raw = getRaw(this);
  (0, _connectableSwitcher.currentConnectable)()?.observeCollection(raw);
  const iterator = raw.entries(); // return a wrapped iterator which returns observed versions of the
  // values emitted from the real iterator

  return {
    next() {
      const next = iterator.next();
      const value = next.value;
      const done = next.done;
      return done ? {
        value: void 0,
        done
      } : {
        value: [wrap(value[0]), wrap(value[1])],
        done
      };
    },

    [Symbol.iterator]() {
      return this;
    }

  };
}

const ProxyObservable = Object.freeze({
  getProxy,
  getRaw,
  wrap,
  unwrap,
  rawKey
});
exports.ProxyObservable = ProxyObservable;
});

;define.alias('@aurelia/runtime/observation/proxy-observation.js','@aurelia/runtime/dist/esm/observation/proxy-observation.js');
define('@aurelia/runtime/dist/esm/observation/set-observer.js',['require','exports','module','../observation.js','./collection-length-observer.js','./subscriber-collection.js','../utilities-objects.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.enableSetObservation = enableSetObservation;
exports.disableSetObservation = disableSetObservation;
exports.getSetObserver = getSetObserver;
exports.SetObserver = void 0;

var _observation = require("../observation.js");

var _collectionLengthObserver = require("./collection-length-observer.js");

var _subscriberCollection = require("./subscriber-collection.js");

var _utilitiesObjects = require("../utilities-objects.js");

const observerLookup = new WeakMap();
const proto = Set.prototype;
const $add = proto.add;
const $clear = proto.clear;
const $delete = proto.delete;
const native = {
  add: $add,
  clear: $clear,
  delete: $delete
};
const methods = ['add', 'clear', 'delete']; // note: we can't really do much with Set due to the internal data structure not being accessible so we're just using the native calls
// fortunately, add/delete/clear are easy to reconstruct for the indexMap

const observe = {
  // https://tc39.github.io/ecma262/#sec-set.prototype.add
  add: function (value) {
    const o = observerLookup.get(this);

    if (o === undefined) {
      $add.call(this, value);
      return this;
    }

    const oldSize = this.size;
    $add.call(this, value);
    const newSize = this.size;

    if (newSize === oldSize) {
      return this;
    }

    o.indexMap[oldSize] = -2;
    o.notify();
    return this;
  },
  // https://tc39.github.io/ecma262/#sec-set.prototype.clear
  clear: function () {
    const o = observerLookup.get(this);

    if (o === undefined) {
      return $clear.call(this);
    }

    const size = this.size;

    if (size > 0) {
      const indexMap = o.indexMap;
      let i = 0; // deepscan-disable-next-line

      for (const _ of this.keys()) {
        if (indexMap[i] > -1) {
          indexMap.deletedItems.push(indexMap[i]);
        }

        i++;
      }

      $clear.call(this);
      indexMap.length = 0;
      o.notify();
    }

    return undefined;
  },
  // https://tc39.github.io/ecma262/#sec-set.prototype.delete
  delete: function (value) {
    const o = observerLookup.get(this);

    if (o === undefined) {
      return $delete.call(this, value);
    }

    const size = this.size;

    if (size === 0) {
      return false;
    }

    let i = 0;
    const indexMap = o.indexMap;

    for (const entry of this.keys()) {
      if (entry === value) {
        if (indexMap[i] > -1) {
          indexMap.deletedItems.push(indexMap[i]);
        }

        indexMap.splice(i, 1);
        const deleteResult = $delete.call(this, value);

        if (deleteResult === true) {
          o.notify();
        }

        return deleteResult;
      }

      i++;
    }

    return false;
  }
};
const descriptorProps = {
  writable: true,
  enumerable: false,
  configurable: true
};

for (const method of methods) {
  (0, _utilitiesObjects.def)(observe[method], 'observing', {
    value: true,
    writable: false,
    configurable: false,
    enumerable: false
  });
}

let enableSetObservationCalled = false;

function enableSetObservation() {
  for (const method of methods) {
    if (proto[method].observing !== true) {
      (0, _utilitiesObjects.def)(proto, method, { ...descriptorProps,
        value: observe[method]
      });
    }
  }
}

function disableSetObservation() {
  for (const method of methods) {
    if (proto[method].observing === true) {
      (0, _utilitiesObjects.def)(proto, method, { ...descriptorProps,
        value: native[method]
      });
    }
  }
}

class SetObserver {
  constructor(observedSet) {
    this.type = 34
    /* Set */
    ;

    if (!enableSetObservationCalled) {
      enableSetObservationCalled = true;
      enableSetObservation();
    }

    this.collection = observedSet;
    this.indexMap = (0, _observation.createIndexMap)(observedSet.size);
    this.lenObs = void 0;
    observerLookup.set(observedSet, this);
  }

  notify() {
    const indexMap = this.indexMap;
    const size = this.collection.size;
    this.indexMap = (0, _observation.createIndexMap)(size);
    this.subs.notifyCollection(indexMap, 8
    /* updateTarget */
    );
  }

  getLengthObserver() {
    return this.lenObs ?? (this.lenObs = new _collectionLengthObserver.CollectionSizeObserver(this));
  }

}

exports.SetObserver = SetObserver;
(0, _subscriberCollection.subscriberCollection)(SetObserver);

function getSetObserver(observedSet) {
  let observer = observerLookup.get(observedSet);

  if (observer === void 0) {
    observer = new SetObserver(observedSet);
  }

  return observer;
}
});

;define.alias('@aurelia/runtime/observation/set-observer.js','@aurelia/runtime/dist/esm/observation/set-observer.js');
define('@aurelia/runtime/dist/esm/observation/setter-observer.js',['require','exports','module','./subscriber-collection.js','../utilities-objects.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.SetterNotifier = exports.SetterObserver = void 0;

var _subscriberCollection = require("./subscriber-collection.js");

var _utilitiesObjects = require("../utilities-objects.js");

/**
 * Observer for the mutation of object property value employing getter-setter strategy.
 * This is used for observing object properties that has no decorator.
 */
class SetterObserver {
  constructor(obj, propertyKey) {
    this.obj = obj;
    this.propertyKey = propertyKey;
    this.currentValue = void 0;
    this.oldValue = void 0;
    this.inBatch = false;
    this.observing = false; // todo(bigopon): tweak the flag based on typeof obj (array/set/map/iterator/proxy etc...)

    this.type = 1
    /* Observer */
    ;
  }

  getValue() {
    return this.currentValue;
  }

  setValue(newValue, flags) {
    if (this.observing) {
      const currentValue = this.currentValue;
      this.currentValue = newValue;
      this.subs.notify(newValue, currentValue, flags);
    } else {
      // If subscribe() has been called, the target property descriptor is replaced by these getter/setter methods,
      // so calling obj[propertyKey] will actually return this.currentValue.
      // However, if subscribe() was not yet called (indicated by !this.observing), the target descriptor
      // is unmodified and we need to explicitly set the property value.
      // This will happen in one-time, to-view and two-way bindings during $bind, meaning that the $bind will not actually update the target value.
      // This wasn't visible in vCurrent due to connect-queue always doing a delayed update, so in many cases it didn't matter whether $bind updated the target or not.
      this.obj[this.propertyKey] = newValue;
    }
  }

  subscribe(subscriber) {
    if (this.observing === false) {
      this.start();
    }

    this.subs.add(subscriber);
  }

  start() {
    if (this.observing === false) {
      this.observing = true;
      this.currentValue = this.obj[this.propertyKey];
      (0, _utilitiesObjects.def)(this.obj, this.propertyKey, {
        enumerable: true,
        configurable: true,
        get: () =>
        /* Setter Observer */
        this.getValue(),
        set:
        /* Setter Observer */
        value => {
          this.setValue(value, 0
          /* none */
          );
        }
      });
    }

    return this;
  }

  stop() {
    if (this.observing) {
      (0, _utilitiesObjects.def)(this.obj, this.propertyKey, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.currentValue
      });
      this.observing = false; // todo(bigopon/fred): add .removeAllSubscribers()
    }

    return this;
  }

}

exports.SetterObserver = SetterObserver;

class SetterNotifier {
  constructor(obj, callbackKey, set, initialValue) {
    this.type = 1
    /* Observer */
    ;
    /**
     * @internal
     */

    this.v = void 0;
    this.obj = obj;
    this.s = set;
    const callback = obj[callbackKey];
    this.cb = typeof callback === 'function' ? callback : void 0;
    this.v = initialValue;
  }

  getValue() {
    return this.v;
  }

  setValue(value, flags) {
    if (typeof this.s === 'function') {
      value = this.s(value);
    }

    const oldValue = this.v;

    if (!Object.is(value, oldValue)) {
      this.v = value;
      this.cb?.call(this.obj, value, oldValue, flags); // there's a chance that cb.call(...)
      // changes the latest value of this observer
      // and thus making `value` stale
      // so for now, call with this.v
      // todo: should oldValue be treated the same way?

      this.subs.notify(this.v, oldValue, flags);
    }
  }

}

exports.SetterNotifier = SetterNotifier;
(0, _subscriberCollection.subscriberCollection)(SetterObserver);
(0, _subscriberCollection.subscriberCollection)(SetterNotifier);
});

;define.alias('@aurelia/runtime/observation/setter-observer.js','@aurelia/runtime/dist/esm/observation/setter-observer.js');
define('@aurelia/runtime/dist/esm/observation/signaler.js',['require','exports','module','@aurelia/kernel'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.Signaler = exports.ISignaler = void 0;

var _kernel = require("@aurelia/kernel");

const ISignaler = _kernel.DI.createInterface('ISignaler', x => x.singleton(Signaler));

exports.ISignaler = ISignaler;

class Signaler {
  constructor() {
    this.signals = Object.create(null);
  }

  dispatchSignal(name, flags) {
    const listeners = this.signals[name];

    if (listeners === undefined) {
      return;
    }

    for (const listener of listeners.keys()) {
      listener.handleChange(undefined, undefined, flags | 8
      /* updateTarget */
      );
    }
  }

  addSignalListener(name, listener) {
    const signals = this.signals;
    const listeners = signals[name];

    if (listeners === undefined) {
      signals[name] = new Set([listener]);
    } else {
      listeners.add(listener);
    }
  }

  removeSignalListener(name, listener) {
    const listeners = this.signals[name];

    if (listeners) {
      listeners.delete(listener);
    }
  }

}

exports.Signaler = Signaler;
});

;define.alias('@aurelia/runtime/observation/signaler.js','@aurelia/runtime/dist/esm/observation/signaler.js');
define('@aurelia/runtime/dist/esm/observation/subscriber-collection.js',['require','exports','module','../utilities-objects.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.subscriberCollection = subscriberCollection;
exports.SubscriberRecord = void 0;

var _utilitiesObjects = require("../utilities-objects.js");

function subscriberCollection(target) {
  return target == null ? subscriberCollectionDeco : subscriberCollectionDeco(target);
}

function subscriberCollectionDeco(target) {
  const proto = target.prototype; // not configurable, as in devtool, the getter could be invoked on the prototype,
  // and become permanently broken

  (0, _utilitiesObjects.def)(proto, 'subs', {
    get: getSubscriberRecord
  });
  (0, _utilitiesObjects.ensureProto)(proto, 'subscribe', addSubscriber);
  (0, _utilitiesObjects.ensureProto)(proto, 'unsubscribe', removeSubscriber);
}
/* eslint-enable @typescript-eslint/ban-types */


class SubscriberRecord {
  constructor(owner) {
    /**
     * subscriber flags: bits indicating the existence status of the subscribers of this record
     */
    this._sf = 0
    /* None */
    ;
    this.count = 0;
    this.owner = owner;
  }

  add(subscriber) {
    if (this.has(subscriber)) {
      return false;
    }

    const subscriberFlags = this._sf;

    if ((subscriberFlags & 1
    /* Subscriber0 */
    ) === 0) {
      this._s0 = subscriber;
      this._sf |= 1
      /* Subscriber0 */
      ;
    } else if ((subscriberFlags & 2
    /* Subscriber1 */
    ) === 0) {
      this._s1 = subscriber;
      this._sf |= 2
      /* Subscriber1 */
      ;
    } else if ((subscriberFlags & 4
    /* Subscriber2 */
    ) === 0) {
      this._s2 = subscriber;
      this._sf |= 4
      /* Subscriber2 */
      ;
    } else if ((subscriberFlags & 8
    /* SubscribersRest */
    ) === 0) {
      this._sr = [subscriber];
      this._sf |= 8
      /* SubscribersRest */
      ;
    } else {
      this._sr.push(subscriber); // Non-null is implied by else branch of (subscriberFlags & SF.SubscribersRest) === 0

    }

    ++this.count;
    return true;
  }

  has(subscriber) {
    // Flags here is just a perf tweak
    // Compared to not using flags, it's a moderate speed-up when this collection does not have the subscriber;
    // and minor slow-down when it does, and the former is more common than the latter.
    const subscriberFlags = this._sf;

    if ((subscriberFlags & 1
    /* Subscriber0 */
    ) > 0 && this._s0 === subscriber) {
      return true;
    }

    if ((subscriberFlags & 2
    /* Subscriber1 */
    ) > 0 && this._s1 === subscriber) {
      return true;
    }

    if ((subscriberFlags & 4
    /* Subscriber2 */
    ) > 0 && this._s2 === subscriber) {
      return true;
    }

    if ((subscriberFlags & 8
    /* SubscribersRest */
    ) > 0) {
      const subscribers = this._sr; // Non-null is implied by (subscriberFlags & SF.SubscribersRest) > 0

      const ii = subscribers.length;
      let i = 0;

      for (; i < ii; ++i) {
        if (subscribers[i] === subscriber) {
          return true;
        }
      }
    }

    return false;
  }

  any() {
    return this._sf !== 0
    /* None */
    ;
  }

  remove(subscriber) {
    const subscriberFlags = this._sf;

    if ((subscriberFlags & 1
    /* Subscriber0 */
    ) > 0 && this._s0 === subscriber) {
      this._s0 = void 0;
      this._sf = (this._sf | 1
      /* Subscriber0 */
      ) ^ 1
      /* Subscriber0 */
      ;
      --this.count;
      return true;
    } else if ((subscriberFlags & 2
    /* Subscriber1 */
    ) > 0 && this._s1 === subscriber) {
      this._s1 = void 0;
      this._sf = (this._sf | 2
      /* Subscriber1 */
      ) ^ 2
      /* Subscriber1 */
      ;
      --this.count;
      return true;
    } else if ((subscriberFlags & 4
    /* Subscriber2 */
    ) > 0 && this._s2 === subscriber) {
      this._s2 = void 0;
      this._sf = (this._sf | 4
      /* Subscriber2 */
      ) ^ 4
      /* Subscriber2 */
      ;
      --this.count;
      return true;
    } else if ((subscriberFlags & 8
    /* SubscribersRest */
    ) > 0) {
      const subscribers = this._sr; // Non-null is implied by (subscriberFlags & SF.SubscribersRest) > 0

      const ii = subscribers.length;
      let i = 0;

      for (; i < ii; ++i) {
        if (subscribers[i] === subscriber) {
          subscribers.splice(i, 1);

          if (ii === 1) {
            this._sf = (this._sf | 8
            /* SubscribersRest */
            ) ^ 8
            /* SubscribersRest */
            ;
          }

          --this.count;
          return true;
        }
      }
    }

    return false;
  }

  notify(val, oldVal, flags) {
    /**
     * Note: change handlers may have the side-effect of adding/removing subscribers to this collection during this
     * callSubscribers invocation, so we're caching them all before invoking any.
     * Subscribers added during this invocation are not invoked (and they shouldn't be).
     * Subscribers removed during this invocation will still be invoked (and they also shouldn't be,
     * however this is accounted for via $isBound and similar flags on the subscriber objects)
     */
    const owner = this.owner;
    const sub0 = this._s0;
    const sub1 = this._s1;
    const sub2 = this._s2;
    let subs = this._sr;

    if (subs !== void 0) {
      subs = subs.slice();
    }

    flags = (flags | 24
    /* update */
    ) ^ 24
    /* update */
    ;

    if (sub0 !== void 0) {
      sub0.handleChange(val, oldVal, flags | (
      /* sub own flags */
      sub0.id === void 0 ? 0 : owner[sub0.id]));
    }

    if (sub1 !== void 0) {
      sub1.handleChange(val, oldVal, flags | (
      /* sub own flags */
      sub1.id === void 0 ? 0 : owner[sub1.id]));
    }

    if (sub2 !== void 0) {
      sub2.handleChange(val, oldVal, flags | (
      /* sub own flags */
      sub2.id === void 0 ? 0 : owner[sub2.id]));
    }

    if (subs !== void 0) {
      const ii = subs.length;
      let sub;
      let i = 0;

      for (; i < ii; ++i) {
        sub = subs[i];

        if (sub !== void 0) {
          sub.handleChange(val, oldVal, flags | (
          /* sub own flags */
          sub.id === void 0 ? 0 : owner[sub.id]));
        }
      }
    }
  }

  notifyCollection(indexMap, flags) {
    const sub0 = this._s0;
    const sub1 = this._s1;
    const sub2 = this._s2;
    let subs = this._sr;

    if (subs !== void 0) {
      subs = subs.slice();
    }

    if (sub0 !== void 0) {
      sub0.handleCollectionChange(indexMap, flags);
    }

    if (sub1 !== void 0) {
      sub1.handleCollectionChange(indexMap, flags);
    }

    if (sub2 !== void 0) {
      sub2.handleCollectionChange(indexMap, flags);
    }

    if (subs !== void 0) {
      const ii = subs.length;
      let sub;
      let i = 0;

      for (; i < ii; ++i) {
        sub = subs[i];

        if (sub !== void 0) {
          sub.handleCollectionChange(indexMap, flags);
        }
      }
    }
  }

}

exports.SubscriberRecord = SubscriberRecord;

function getSubscriberRecord() {
  const record = new SubscriberRecord(this);
  (0, _utilitiesObjects.defineHiddenProp)(this, 'subs', record);
  return record;
}

function addSubscriber(subscriber) {
  return this.subs.add(subscriber);
}

function removeSubscriber(subscriber) {
  return this.subs.remove(subscriber);
}
});

;define.alias('@aurelia/runtime/observation/subscriber-collection.js','@aurelia/runtime/dist/esm/observation/subscriber-collection.js');
define('@aurelia/runtime/dist/esm/utilities-objects.js',['require','exports','module'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.defineHiddenProp = defineHiddenProp;
exports.ensureProto = ensureProto;
exports.def = void 0;
const def = Reflect.defineProperty;
exports.def = def;

function defineHiddenProp(obj, key, value) {
  def(obj, key, {
    enumerable: false,
    configurable: true,
    writable: true,
    value
  });
}

function ensureProto(proto, key, defaultValue, force = false) {
  if (force || !Object.prototype.hasOwnProperty.call(proto, key)) {
    defineHiddenProp(proto, key, defaultValue);
  }
}
});

;define.alias('@aurelia/runtime/utilities-objects.js','@aurelia/runtime/dist/esm/utilities-objects.js');
define('@aurelia/runtime/dist/esm/value-converter.js',['require','exports','module','@aurelia/kernel','./alias.js'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.valueConverter = valueConverter;
exports.ValueConverter = exports.ValueConverterDefinition = void 0;

var _kernel = require("@aurelia/kernel");

var _alias = require("./alias.js");

function valueConverter(nameOrDef) {
  return function (target) {
    return ValueConverter.define(nameOrDef, target);
  };
}

class ValueConverterDefinition {
  constructor(Type, name, aliases, key) {
    this.Type = Type;
    this.name = name;
    this.aliases = aliases;
    this.key = key;
  }

  static create(nameOrDef, Type) {
    let name;
    let def;

    if (typeof nameOrDef === 'string') {
      name = nameOrDef;
      def = {
        name
      };
    } else {
      name = nameOrDef.name;
      def = nameOrDef;
    }

    return new ValueConverterDefinition(Type, (0, _kernel.firstDefined)(ValueConverter.getAnnotation(Type, 'name'), name), (0, _kernel.mergeArrays)(ValueConverter.getAnnotation(Type, 'aliases'), def.aliases, Type.aliases), ValueConverter.keyFrom(name));
  }

  register(container) {
    const {
      Type,
      key,
      aliases
    } = this;

    _kernel.Registration.singleton(key, Type).register(container);

    _kernel.Registration.aliasTo(key, Type).register(container);

    (0, _alias.registerAliases)(aliases, ValueConverter, key, container);
  }

}

exports.ValueConverterDefinition = ValueConverterDefinition;
const ValueConverter = {
  name: _kernel.Protocol.resource.keyFor('value-converter'),

  keyFrom(name) {
    return `${ValueConverter.name}:${name}`;
  },

  isType(value) {
    return typeof value === 'function' && _kernel.Metadata.hasOwn(ValueConverter.name, value);
  },

  define(nameOrDef, Type) {
    const definition = ValueConverterDefinition.create(nameOrDef, Type);

    _kernel.Metadata.define(ValueConverter.name, definition, definition.Type);

    _kernel.Metadata.define(ValueConverter.name, definition, definition);

    _kernel.Protocol.resource.appendTo(Type, ValueConverter.name);

    return definition.Type;
  },

  getDefinition(Type) {
    const def = _kernel.Metadata.getOwn(ValueConverter.name, Type);

    if (def === void 0) {
      throw new Error(`No definition found for type ${Type.name}`);
    }

    return def;
  },

  annotate(Type, prop, value) {
    _kernel.Metadata.define(_kernel.Protocol.annotation.keyFor(prop), value, Type);
  },

  getAnnotation(Type, prop) {
    return _kernel.Metadata.getOwn(_kernel.Protocol.annotation.keyFor(prop), Type);
  }

};
exports.ValueConverter = ValueConverter;
});

;define.alias('@aurelia/runtime/value-converter.js','@aurelia/runtime/dist/esm/value-converter.js');
define('aurelia/dist/esm/index.js',['require','exports','module','@aurelia/kernel','@aurelia/runtime-html','@aurelia/platform-browser','@aurelia/fetch-client','@aurelia/router'],function (require, exports, module) {
"use strict";

exports.__esModule = true;
exports.shadowCSS = exports.cssModules = exports.StyleConfiguration = exports.createElement = exports.ShortHandBindingSyntax = exports.getTarget = exports.bindingCommand = exports.IAttrSyntaxTransformer = exports.IAttributePattern = exports.attributePattern = exports.NodeObserverLocator = exports.IAurelia = exports.renderer = exports.LifecycleFlags = exports.BindingMode = exports.IRenderLocation = exports.IEventTarget = exports.INode = exports.registerAliases = exports.alias = exports.IAppRoot = exports.ViewFactory = exports.Controller = exports.children = exports.Bindable = exports.bindable = exports.TaskQueuePriority = exports.AppTask = exports.valueConverter = exports.ValueConverter = exports.useShadowDOM = exports.customElement = exports.containerless = exports.templateController = exports.CustomAttribute = exports.customAttribute = exports.BindingBehavior = exports.bindingBehavior = exports.subscriberCollection = exports.ISignaler = exports.IObserverLocator = exports.watch = exports.Watch = exports.ExpressionWatcher = exports.ComputedWatcher = exports.ComputedObserver = exports.RouterRegistration = exports.RouterConfiguration = exports.ViewportInstruction = exports.Router = exports.IRouter = exports.RouterOptions = exports.NavRoute = exports.bound = exports.toArray = exports.pascalCase = exports.kebabCase = exports.camelCase = exports.isArrayIndex = exports.IEventAggregator = exports.EventAggregator = exports.LogLevel = exports.noop = exports.emptyObject = exports.emptyArray = exports.LoggerConfiguration = exports.ILogger = exports.ColorOptions = exports.Metadata = exports.InstanceProvider = exports.transient = exports.singleton = exports.optional = exports.lazy = exports.IServiceLocator = exports.inject = exports.IContainer = exports.all = exports.IHttpClient = exports.HttpClient = exports.HttpClientConfiguration = exports.json = exports.default = exports.Aurelia = exports.PLATFORM = void 0;

var _kernel = require("@aurelia/kernel");

exports.DI = _kernel.DI;
exports.Registration = _kernel.Registration;
exports.all = _kernel.all;
exports.IContainer = _kernel.IContainer;
exports.inject = _kernel.inject;
exports.IServiceLocator = _kernel.IServiceLocator;
exports.lazy = _kernel.lazy;
exports.optional = _kernel.optional;
exports.singleton = _kernel.singleton;
exports.transient = _kernel.transient;
exports.InstanceProvider = _kernel.InstanceProvider;
exports.Metadata = _kernel.Metadata;
exports.ColorOptions = _kernel.ColorOptions;
exports.ILogger = _kernel.ILogger;
exports.LoggerConfiguration = _kernel.LoggerConfiguration;
exports.emptyArray = _kernel.emptyArray;
exports.emptyObject = _kernel.emptyObject;
exports.noop = _kernel.noop;
exports.LogLevel = _kernel.LogLevel;
exports.EventAggregator = _kernel.EventAggregator;
exports.IEventAggregator = _kernel.IEventAggregator;
exports.isArrayIndex = _kernel.isArrayIndex;
exports.camelCase = _kernel.camelCase;
exports.kebabCase = _kernel.kebabCase;
exports.pascalCase = _kernel.pascalCase;
exports.toArray = _kernel.toArray;
exports.bound = _kernel.bound;

var _runtimeHtml = require("@aurelia/runtime-html");

exports.IPlatform = _runtimeHtml.IPlatform;
exports.CustomElement = _runtimeHtml.CustomElement;
exports.ComputedObserver = _runtimeHtml.ComputedObserver;
exports.ComputedWatcher = _runtimeHtml.ComputedWatcher;
exports.ExpressionWatcher = _runtimeHtml.ExpressionWatcher;
exports.Watch = _runtimeHtml.Watch;
exports.watch = _runtimeHtml.watch;
exports.IObserverLocator = _runtimeHtml.IObserverLocator;
exports.ISignaler = _runtimeHtml.ISignaler;
exports.subscriberCollection = _runtimeHtml.subscriberCollection;
exports.bindingBehavior = _runtimeHtml.bindingBehavior;
exports.BindingBehavior = _runtimeHtml.BindingBehavior;
exports.customAttribute = _runtimeHtml.customAttribute;
exports.CustomAttribute = _runtimeHtml.CustomAttribute;
exports.templateController = _runtimeHtml.templateController;
exports.containerless = _runtimeHtml.containerless;
exports.customElement = _runtimeHtml.customElement;
exports.useShadowDOM = _runtimeHtml.useShadowDOM;
exports.ValueConverter = _runtimeHtml.ValueConverter;
exports.valueConverter = _runtimeHtml.valueConverter;
exports.AppTask = _runtimeHtml.AppTask;
exports.TaskQueuePriority = _runtimeHtml.TaskQueuePriority;
exports.bindable = _runtimeHtml.bindable;
exports.Bindable = _runtimeHtml.Bindable;
exports.children = _runtimeHtml.children;
exports.Controller = _runtimeHtml.Controller;
exports.ViewFactory = _runtimeHtml.ViewFactory;
exports.IAppRoot = _runtimeHtml.IAppRoot;
exports.alias = _runtimeHtml.alias;
exports.registerAliases = _runtimeHtml.registerAliases;
exports.INode = _runtimeHtml.INode;
exports.IEventTarget = _runtimeHtml.IEventTarget;
exports.IRenderLocation = _runtimeHtml.IRenderLocation;
exports.BindingMode = _runtimeHtml.BindingMode;
exports.LifecycleFlags = _runtimeHtml.LifecycleFlags;
exports.renderer = _runtimeHtml.renderer;
exports.IAurelia = _runtimeHtml.IAurelia;
exports.NodeObserverLocator = _runtimeHtml.NodeObserverLocator;
exports.attributePattern = _runtimeHtml.attributePattern;
exports.IAttributePattern = _runtimeHtml.IAttributePattern;
exports.IAttrSyntaxTransformer = _runtimeHtml.IAttrSyntaxTransformer;
exports.bindingCommand = _runtimeHtml.bindingCommand;
exports.getTarget = _runtimeHtml.getTarget;
exports.ShortHandBindingSyntax = _runtimeHtml.ShortHandBindingSyntax;
exports.createElement = _runtimeHtml.createElement;
exports.StyleConfiguration = _runtimeHtml.StyleConfiguration;
exports.cssModules = _runtimeHtml.cssModules;
exports.shadowCSS = _runtimeHtml.shadowCSS;

var _platformBrowser = require("@aurelia/platform-browser");

var _fetchClient = require("@aurelia/fetch-client");

exports.json = _fetchClient.json;
exports.HttpClientConfiguration = _fetchClient.HttpClientConfiguration;
exports.HttpClient = _fetchClient.HttpClient;
exports.IHttpClient = _fetchClient.IHttpClient;

var _router = require("@aurelia/router");

exports.NavRoute = _router.NavRoute;
exports.RouterOptions = _router.RouterOptions;
exports.IRouter = _router.IRouter;
exports.Router = _router.Router;
exports.ViewportInstruction = _router.ViewportInstruction;
exports.RouterConfiguration = _router.RouterConfiguration;
exports.RouterRegistration = _router.RouterRegistration;

const PLATFORM = _platformBrowser.BrowserPlatform.getOrCreate(globalThis);

exports.PLATFORM = PLATFORM;

function createContainer() {
  return _kernel.DI.createContainer().register(_kernel.Registration.instance(_runtimeHtml.IPlatform, PLATFORM), _runtimeHtml.StandardConfiguration);
}

class Aurelia extends _runtimeHtml.Aurelia {
  constructor(container = createContainer()) {
    super(container);
  }

  static start(root) {
    return new Aurelia().start(root);
  }

  static app(config) {
    return new Aurelia().app(config);
  }

  static enhance(config) {
    return new Aurelia().enhance(config);
  }

  static register(...params) {
    return new Aurelia().register(...params);
  }

  app(config) {
    if (_runtimeHtml.CustomElement.isType(config)) {
      // Default to custom element element name
      const definition = _runtimeHtml.CustomElement.getDefinition(config);

      let host = document.querySelector(definition.name);

      if (host === null) {
        // When no target is found, default to body.
        // For example, when user forgot to write <my-app></my-app> in html.
        host = document.body;
      }

      return super.app({
        host: host,
        component: config
      });
    }

    return super.app(config);
  }

}

exports.Aurelia = Aurelia;
var _default = Aurelia;
exports.default = _default;
});

;define.alias('aurelia','aurelia/dist/esm/index.js');
define('dumber/lib/inject-css.js',['require','exports','module'],function (require, exports, module) {
// Alert: this file will be used in users' app for ext:css plugin,
// use plain ES5 JavaScript Syntax.
var cssUrlMatcher = /url\s*\(\s*(?!['"]data)([^) ]+)\s*\)/gi;

// copied from aurelia-templating-resources css-resource
// This behaves differently from webpack's style-loader.
// Here we change './hello.png' to 'foo/hello.png' if base address is 'foo/bar'.
// Note 'foo/hello.png' is technically a relative path in css.
// We inject css into a style tag on html head, it means the 'foo/hello.png'
// is related to current url (not css url on link tag), or <base> tag in html
// head (which is recommended setup of aurelia-router if not using hash).
function fixupCSSUrls(address, css) {
  if (typeof css !== 'string') {
    throw new Error(`Failed loading required CSS file: ${address}`);
  }

  return css.replace(cssUrlMatcher, function(match, p1) {
    var quote = p1.charAt(0);
    if (quote === '\'' || quote === '"') {
      p1 = p1.slice(1, -1);
    }
    var absolutePath = absoluteModuleId(address, p1);
    if (absolutePath === p1) {
      return match;
    }
    return 'url(\'' + absolutePath + '\')';
  });
}

function absoluteModuleId(baseId, moduleId) {
  if (moduleId[0] !== '.') return moduleId;

  var parts = baseId.split('/');
  parts.pop();

  var mParts = moduleId.split('/');
  var p;

  for (p of mParts) {
    if (p === '.') continue;
    if (p === '..') {
      parts.pop();
      continue;
    }
    parts.push(p);
  }

  return parts.join('/');
}

// copied from aurelia-pal-browser DOM.injectStyles
function injectCSS(css, id) {
  if (typeof document === 'undefined' || !css) return;
  css = fixupCSSUrls(id, css);

  if (id) {
    var oldStyle = document.getElementById(id);
    if (oldStyle) {
      var isStyleTag = oldStyle.tagName.toLowerCase() === 'style';

      if (isStyleTag) {
        oldStyle.innerHTML = css;
        return;
      }

      throw new Error('The provided id does not indicate a style tag.');
    }
  }

  var node = document.createElement('style');
  node.innerHTML = css;
  node.type = 'text/css';

  if (id) {
    node.id = id;
  }

  document.head.appendChild(node);
}

// dumber-module-loader plugin ext:css
function load(name, req, load) {
  req(['text!' + name], function(text) {
    var result = splitCssModuleExports(text);
    injectCSS(result.css, name);
    // When css-module is in use, the module exports will be
    // a map of tokens. Otherwise, export original css string.
    load(result.exportTokens || result.css);
  });
}

function splitCssModuleExports(text) {
  if (!text) return {css: ''};
  var m = text.match(/\n\/\*\s*dumber-css-module:\s*(.+?)\s*\*\/\s*$/);
  if (!m) return {css: text};
  var css = text.slice(0, m.index);
  var exportTokens = JSON.parse(m[1]);
  return {css, exportTokens};
}

exports.fixupCSSUrls = fixupCSSUrls;
exports.injectCSS = injectCSS;
exports.splitCssModuleExports = splitCssModuleExports;
exports.load = load;

});

define.switchToUserSpace();
requirejs.config({
  "baseUrl": (typeof REQUIREJS_BASE_URL === "string") ? REQUIREJS_BASE_URL : "/dist",
  "paths": {
    "../src": ""
  },
  "bundles": {
    "app-bundle": {
      "user": [
        "base-worker-page.html.js",
        "base-worker-page.js",
        "ext:css",
        "ext:less",
        "ext:sass",
        "ext:scss",
        "ext:styl",
        "main.js",
        "missing-page.html.js",
        "missing-page.js",
        "my-app.css",
        "my-app.html.js",
        "my-app.js",
        "state-service.js",
        "text!my-app.css",
        "treasury-page.html.js",
        "treasury-page.js",
        "worker-page.html.js",
        "worker-page.js"
      ],
      "package": []
    }
  }
});
//# sourceMappingURL=entry-bundle.js.map